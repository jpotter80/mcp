{"chunk_id": "values-value-semantics-000", "document_id": "values-value-semantics", "content": "Mojo doesn't enforce value semantics or reference semantics. It supports them\nboth and allows each type to define how it is created, copied, and moved (if at\nall). So, if you're building your own type, you can implement it to support\nvalue semantics, reference semantics, or a bit of both. That said, Mojo is\ndesigned with argument behaviors that default to value semantics, and it\nprovides tight controls for reference semantics that avoid memory errors.\n\nThe controls over reference semantics are provided by the [value ownership\nmodel](/mojo/manual/values/ownership), but before we get into the syntax\nand rules for that, it's important that you understand the principles of value\nsemantics. Generally, it means that each variable has unique access to a value,\nand any code outside the scope of that variable cannot modify its value.", "position": 0, "token_count": 173, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "values-value-semantics-000", "document_id": "values-value-semantics", "position": 0, "token_count": 173, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "values/value-semantics.mdx", "url": "https://docs.modular.com/mojo/manual/values/value-semantics", "title": "Value semantics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/value-semantics"}}
{"chunk_id": "values-value-semantics-001", "document_id": "values-value-semantics", "content": "## Intro to value semantics\n\nIn the most basic situation, sharing a value-semantic type means that you create\na copy of the value. This is also known as \"pass by value.\" For example,\nconsider this code:\n\n```mojo\ndef main():\n var x = 1\n var y = x\n y += 1\n\n print(\"x:\", x)\n print(\"y:\", y)\n```\n\n```output\nx: 1\ny: 2\n```\n\nWe assigned the value of `x` to `y`, which creates the value for `y` by making a\ncopy of `x`. When we increment `y`, the value of `x` doesn't change. Each\nvariable has exclusive ownership of a value.\n\nWhereas, if a type instead uses reference semantics, then `y` would point to\nthe same value as `x`, and incrementing either one would affect the value for\nboth. Neither `x` nor `y` would \"own\" the value, and any variable would be\nallowed to reference it and mutate it.\n\nNumeric values in Mojo are value semantic because they're trivial types, which\nare cheap to copy.", "position": 1, "token_count": 250, "has_code": true, "section_hierarchy": ["Intro to value semantics"], "metadata": {"chunk_id": "values-value-semantics-001", "document_id": "values-value-semantics", "position": 1, "token_count": 250, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Intro to value semantics"], "file_path": "values/value-semantics.mdx", "url": "https://docs.modular.com/mojo/manual/values/value-semantics", "title": "Value semantics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/value-semantics#intro-to-value-semantics"}}
{"chunk_id": "values-value-semantics-002", "document_id": "values-value-semantics", "content": "## Value semantics in Mojo functions\n\nValue semantics also apply to function arguments in Mojo by default. However,\nthe way in which they apply differs depending on the [argument\nconvention](/mojo/manual/values/ownership#argument-conventions), which is\ndiscussed in the [Ownership](/mojo/manual/values/ownership) page.\n\nFor example, in the following function, the `y` argument is immutable by\ndefault, so if the function wants to modify the value in the local scope, it\nneeds to make a local copy:\n\n```mojo\nfn add_two(y: Int):\n # y += 2 # This would cause a compiler error because `y` is immutable\n # We can instead make an explicit copy:\n var z = y\n z += 2\n print(\"z:\", z)\n\ndef main():\n var x = 1\n add_two(x)\n print(\"x:\", x)\n```\n\n```output\nz: 3\nx: 1", "position": 2, "token_count": 212, "has_code": true, "section_hierarchy": ["Value semantics in Mojo functions"], "metadata": {"chunk_id": "values-value-semantics-002", "document_id": "values-value-semantics", "position": 2, "token_count": 212, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Value semantics in Mojo functions"], "file_path": "values/value-semantics.mdx", "url": "https://docs.modular.com/mojo/manual/values/value-semantics", "title": "Value semantics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/value-semantics#value-semantics-in-mojo-functions"}}
{"chunk_id": "values-value-semantics-003", "document_id": "values-value-semantics", "content": "```\n\nThis is all consistent with value semantics because each variable maintains\nunique ownership of its value.\n\nThe way the function receives the `y` value is a \"look but don't touch\"\napproach to value semantics. This is also a more memory-efficient approach when\ndealing with memory-intensive arguments, because Mojo doesn't make any copies\nunless we explicitly make the copies ourselves.\n\nThus, the default behavior for function arguments is fully value\nsemantic: arguments are immutable references, and any living\nvariable from the caller is not affected by the function.\n\nBut we must also allow reference semantics (mutable references) because it's\nhow we build performant and memory-efficient programs (making copies of\neverything gets really expensive). The challenge is to introduce reference\nsemantics in a way that does not disturb the predictability and safety of value\nsemantics.\n\nThe way we do that in Mojo is, instead of enforcing that every variable have\n\"exclusive access\" to a value, we ensure that every value has an \"exclusive\nowner,\" and destroy each value when the lifetime of its owner ends.", "position": 3, "token_count": 221, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-value-semantics-003", "document_id": "values-value-semantics", "position": 3, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/value-semantics.mdx", "url": "https://docs.modular.com/mojo/manual/values/value-semantics", "title": "Value semantics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/value-semantics"}}
{"chunk_id": "values-value-semantics-004", "document_id": "values-value-semantics", "content": "The way we do that in Mojo is, instead of enforcing that every variable have\n\"exclusive access\" to a value, we ensure that every value has an \"exclusive\nowner,\" and destroy each value when the lifetime of its owner ends.\n\nOn the next page about [value ownership](/mojo/manual/values/ownership), you'll\nlearn how to modify the default argument conventions, and safely use reference\nsemantics so every value has only one owner at a time.", "position": 4, "token_count": 98, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "values-value-semantics-004", "document_id": "values-value-semantics", "position": 4, "token_count": 98, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/value-semantics.mdx", "url": "https://docs.modular.com/mojo/manual/values/value-semantics", "title": "Value semantics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/value-semantics"}}

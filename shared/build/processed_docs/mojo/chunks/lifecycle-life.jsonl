{"chunk_id": "lifecycle-life-000", "document_id": "lifecycle-life", "content": "The life of a value in Mojo begins when a variable is initialized and continues\nup until the value is last used, at which point Mojo destroys it. This page\ndescribes how every value in Mojo is created, copied, and moved. (The next\npage describes [how values are\ndestroyed](/mojo/manual/lifecycle/death).)\n\nAll data types in Mojo—including basic types in the standard library such as\n[`Bool`](/mojo/stdlib/builtin/bool/Bool), [`Int`](/mojo/stdlib/builtin/int/Int),\nand [`String`](/mojo/stdlib/collections/string/string/String)—are defined as\n[structs](/mojo/manual/structs). This means the creation and destruction of any\npiece of data follows the same lifecycle rules, and you can define your own data\ntypes that work exactly the same way.", "position": 0, "token_count": 208, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-000", "document_id": "lifecycle-life", "position": 0, "token_count": 208, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-001", "document_id": "lifecycle-life", "content": "Mojo structs don't get any default lifecycle methods, such as a\nconstructor, copy constructor, or move constructor. That means you can define\na struct without a constructor, but then you can't instantiate it, and it\nwould be useful only as a sort of namespace for static methods. For example:\n\n```mojo\nstruct NoInstances:\n var state: Int\n\n @staticmethod\n fn print_hello():\n print(\"Hello world!\")", "position": 1, "token_count": 111, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-001", "document_id": "lifecycle-life", "position": 1, "token_count": 111, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-002", "document_id": "lifecycle-life", "content": "```\n\nWithout a constructor, this cannot be instantiated, so it has no lifecycle. The\n`state` field is also useless because it cannot be initialized (Mojo structs do\nnot support default field values—you must initialize them in a constructor).\n\nSo the only thing you can do is call the static method:\n\n```mojo\nNoInstances.print_hello()\n```\n\n```output\nHello world!\n```", "position": 2, "token_count": 100, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-002", "document_id": "lifecycle-life", "position": 2, "token_count": 100, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-003", "document_id": "lifecycle-life", "content": "## Constructor\n\nTo create an instance of a Mojo type, it needs the `__init__()` constructor\nmethod. The main responsibility of the constructor is to initialize all fields.\nFor example:\n\n```mojo\nstruct MyPet:\n var name: String\n var age: Int\n\n fn __init__(out self, name: String, age: Int):\n self.name = name\n self.age = age\n```\n\nNow we can create an instance:\n\n```mojo\nvar mine = MyPet(\"Loki\", 4)", "position": 3, "token_count": 124, "has_code": true, "section_hierarchy": ["Constructor"], "metadata": {"chunk_id": "lifecycle-life-003", "document_id": "lifecycle-life", "position": 3, "token_count": 124, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Constructor"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#constructor"}}
{"chunk_id": "lifecycle-life-004", "document_id": "lifecycle-life", "content": "```\n\nNow we can create an instance:\n\n```mojo\nvar mine = MyPet(\"Loki\", 4)\n```\n\nAn instance of `MyPet` can also be read\nand destroyed, but it currently can't be copied or moved.\n\nWe believe this is a good default starting point, because there are no built-in\nlifecycle events and no surprise behaviors. You—the type author—must\nexplicitly decide whether and how the type can be copied or moved, by\nimplementing the copy and move constructors.\n\nThe pattern shown above—a constructor that takes an argument for each of the\nstruct's fields and initializes the fields directly from the arguments—is called\na *field-wise constructor*. It's a common enough pattern that Mojo includes a\n[`@fieldwise_init`](/mojo/manual/decorators/fieldwise-init) decorator to\nsynthesize the field-wise constructor. So you can rewrite the previous example\nlike this:\n\n```mojo\n@fieldwise_init\nstruct MyPet:\n var name: String\n var age: Int", "position": 4, "token_count": 237, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-004", "document_id": "lifecycle-life", "position": 4, "token_count": 237, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-005", "document_id": "lifecycle-life", "content": "```\n\n[note]\nMojo does not require a destructor to destroy an instance. But in some cases you\nmay need to define a custom destructor to release resources (for example, if a\nstruct dynamically allocates memory using\n[`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer)). We'll\ndiscuss that more in [Death of a value](/mojo/manual/lifecycle/death).\n\nnote The \"constructor\" name\n\nIn a Python class, object construction happens across both the `__new__()` and\n`__init__()` methods, so the `__init__()` method is technically just the\ninitializer for attributes (but it's often still called the constructor).\nHowever, in a Mojo struct, there is no `__new__()` method, so we prefer to\nalways call `__init__()` the constructor.", "position": 5, "token_count": 223, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-005", "document_id": "lifecycle-life", "position": 5, "token_count": 223, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-006", "document_id": "lifecycle-life", "content": "### Overloading the constructor\n\nLike any other function/method, you can\n[overload](/mojo/manual/functions#overloaded-functions) the\n`__init__()` constructor to initialize the object with different arguments. For\nexample, you might want a default constructor that sets some default values and\ntakes no arguments, and then additional constructors that accept more arguments.\n\nJust be aware that, in order to modify any fields, each constructor must\ndeclare the `self` argument with the [`out`\nconvention](/mojo/manual/values/ownership#argument-conventions). If you\nwant to call one constructor from another, you simply call upon that\nconstructor as you would externally (you don't need to pass `self`).\n\nFor example, here's how you can delegate work from an overloaded constructor:\n\n```mojo\nstruct MyPet:\n var name: String\n var age: Int\n\n fn __init__(out self):\n self.name = \"\"\n self.age = 0", "position": 6, "token_count": 228, "has_code": true, "section_hierarchy": ["Overloading the constructor"], "metadata": {"chunk_id": "lifecycle-life-006", "document_id": "lifecycle-life", "position": 6, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Overloading the constructor"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#overloading-the-constructor"}}
{"chunk_id": "lifecycle-life-007", "document_id": "lifecycle-life", "content": "```mojo\nstruct MyPet:\n var name: String\n var age: Int\n\n fn __init__(out self):\n self.name = \"\"\n self.age = 0\n\n fn __init__(out self, name: String):\n self = MyPet()\n self.name = name", "position": 7, "token_count": 72, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-007", "document_id": "lifecycle-life", "position": 7, "token_count": 72, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-008", "document_id": "lifecycle-life", "content": "```", "position": 8, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-008", "document_id": "lifecycle-life", "position": 8, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-009", "document_id": "lifecycle-life", "content": "### Field initialization\n\nNotice in the previous example that, by the end of each constructor, all fields\nmust be initialized. That's the only requirement in the constructor.\n\nIn fact, the `__init__()` constructor is smart enough to treat the `self`\nobject as fully initialized even before the constructor is finished, as long\nas all fields are initialized. For example, this constructor can pass around\n`self` as soon as all fields are initialized:\n\n```mojo\nfn use(arg: MyPet):\n pass\n\nstruct MyPet:\n var name: String\n var age: Int\n\n fn __init__(out self, name: String, age: Int, cond: Bool):\n self.name = name\n if cond:\n self.age = age\n use(self) # Safe to use immediately!\n\n self.age = age\n use(self) # Safe to use immediately!\n```", "position": 9, "token_count": 208, "has_code": true, "section_hierarchy": ["Field initialization"], "metadata": {"chunk_id": "lifecycle-life-009", "document_id": "lifecycle-life", "position": 9, "token_count": 208, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Field initialization"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#field-initialization"}}
{"chunk_id": "lifecycle-life-010", "document_id": "lifecycle-life", "content": "### Constructors and implicit conversion\n\nMojo supports implicit conversion from one type to another. Implicit conversion\ncan happen when one of the following occurs:\n\n- You assign a value of one type to a variable with a different type.\n- You pass a value of one type to a function that requires a different type.\n- You return a value of one type from a function that specifies a different\n return type.\n\nIn all cases, implicit conversion is supported when the target type\ndefines a constructor that meets the following criteria:\n\n- Is declared with the `@implicit` decorator.\n- Has a single required, non-keyword argument of the source type.\n\nFor example:\n\n```mojo\nvar a = Source()\nvar b: Target = a\n```\n\nMojo implicitly converts the `Source` value in `a` to a `Target` value if\n`Target` defines a matching constructor like this:\n\n```mojo\nstruct Target:\n\n @implicit\n fn __init__(out self, s: Source): ...\n```\n\nWith implicit conversion, the assignment above is essentially identical to:\n\n```mojo\nvar b = Target(a)", "position": 10, "token_count": 242, "has_code": true, "section_hierarchy": ["Constructors and implicit conversion"], "metadata": {"chunk_id": "lifecycle-life-010", "document_id": "lifecycle-life", "position": 10, "token_count": 242, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Constructors and implicit conversion"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#constructors-and-implicit-conversion"}}
{"chunk_id": "lifecycle-life-011", "document_id": "lifecycle-life", "content": "```\n\nWith implicit conversion, the assignment above is essentially identical to:\n\n```mojo\nvar b = Target(a)\n```\n\nIn general, types should only support implicit conversions when the conversion\nis lossless, and ideally inexpensive. For example, converting an integer to a\nfloating-point number is usually lossless (except for very large positive and\nnegative integers, where the conversion may be approximate), but converting a\nfloating-point number to an integer is very likely to lose information. So\nMojo supports implicit conversion from `Int` to `Float64`, but not the reverse.\n\nThe constructor used for implicit conversion can take optional arguments, so\nthe following constructor would also support implicit conversion from `Source`\nto `Target`:\n\n```mojo\nstruct Target:\n\n @implicit\n fn __init__(out self, s: Source, reverse: Bool = False): ...", "position": 11, "token_count": 191, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-011", "document_id": "lifecycle-life", "position": 11, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-012", "document_id": "lifecycle-life", "content": "```\n\nImplicit conversion can fail if Mojo can't unambiguously match the conversion to\na constructor. For example, if the target type has two overloaded constructors\nthat take different types, and each of those types supports an implicit\nconversion from the source type, the compiler has two equally-valid paths to\nconvert the values:\n\n```mojo\nstruct A:\n @implicit\n fn __init__(out self, s: Source): ...\n\nstruct B:\n @implicit\n fn __init__(out self, s: Source): ...\n\nstruct OverloadedTarget:\n @implicit\n fn __init__(out self, a: A): ...\n @implicit\n fn __init__(out self, b: B): ...\n\nvar t = OverloadedTarget(Source()) # Error: ambiguous call to '__init__': each\n # candidate requires 1 implicit conversion", "position": 12, "token_count": 215, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-012", "document_id": "lifecycle-life", "position": 12, "token_count": 215, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-013", "document_id": "lifecycle-life", "content": "```\n\nIn this case, you can fix the issue by explicitly casting to one of the\nintermediate types. For example:\n\n```mojo\nvar t = OverloadedTarget(A(Source())) # OK\n```\n\nMojo applies at most one implicit conversion to a variable. For example:\n\n```mojo\nvar t: OverloadedTarget = Source() # Error: can't implicitly convert Source\n # to Target\n```\n\nWould fail because there's no direct conversion from `Source` to\n`OverloadedTarget`.\n\nFor structs with a single field, you can generate an implicit constructor with\nthe `@fieldwise_init(\"implicit\")` decorator.\n\n```mojo\n@fieldwise_init(\"implicit\")\nstruct Counter:\n var count: Int\n\ndef main():\n var c: Counter = 5 # implicitly converts from Int\n```", "position": 13, "token_count": 195, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-013", "document_id": "lifecycle-life", "position": 13, "token_count": 195, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-014", "document_id": "lifecycle-life", "content": "## Copy constructor\n\nIn Mojo, a value can be copied either *explicitly* or *implicitly*:\n\n```mojo", "position": 14, "token_count": 29, "has_code": true, "section_hierarchy": ["Copy constructor"], "metadata": {"chunk_id": "lifecycle-life-014", "document_id": "lifecycle-life", "position": 14, "token_count": 29, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Copy constructor"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#copy-constructor"}}
{"chunk_id": "lifecycle-life-015", "document_id": "lifecycle-life", "content": "# Explicit copy\nvar s = \"Test string\"\nvar s2 = s.copy()", "position": 15, "token_count": 21, "has_code": false, "section_hierarchy": ["Explicit copy"], "metadata": {"chunk_id": "lifecycle-life-015", "document_id": "lifecycle-life", "position": 15, "token_count": 21, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Explicit copy"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#explicit-copy"}}
{"chunk_id": "lifecycle-life-016", "document_id": "lifecycle-life", "content": "# Implicit copy\nvar i = 15\nvar i2 = i\n```\n\nTo make a struct explicitly copyable, you need to:\n\n- Add the `Copyable` trait.\n- (Optionally) define a custom `__copyinit__()` method if needed.\n\nIf you simply add the `Copyable` trait, Mojo will generate a default\n`__copyinit__()` method for you, which copies each field of the existing value\ninto the new value. The `Copyable` trait also defines a default `copy()` method, which\nprovides a more user-friendly way to copy a value than invoking the\ncopy constructor directly.\n\n```mojo\n@fieldwise_init\nstruct MyPet(Copyable):\n var name: String\n var age: Int\n```\n\nNow this code works to make a copy:\n\n```mojo\nvar mine = MyPet(\"Loki\", 4)\nvar yours = mine.copy()", "position": 16, "token_count": 209, "has_code": true, "section_hierarchy": ["Implicit copy"], "metadata": {"chunk_id": "lifecycle-life-016", "document_id": "lifecycle-life", "position": 16, "token_count": 209, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implicit copy"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#implicit-copy"}}
{"chunk_id": "lifecycle-life-017", "document_id": "lifecycle-life", "content": "```\n\nNow this code works to make a copy:\n\n```mojo\nvar mine = MyPet(\"Loki\", 4)\nvar yours = mine.copy()\n```\n\n[note]\nTechnically, you *could* make a struct with a copy constructor and *not* add the\n`Copyable` trait, but this is not recommended. Mojo would be able to copy the\nvalue, but you couldn't use the struct with any generic containers or functions\nthat require the `Copyable` trait.\n\nThe generated copy constructor simply copies each field from the existing value\ninto the new value. For example, if you wrote the `__copyinit__()` method for\n`MyPet`, it would look like this:\n\n```mojo\nfn __copyinit__(out self, existing: Self):\n self.name = existing.name\n self.age = existing.age", "position": 17, "token_count": 197, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-017", "document_id": "lifecycle-life", "position": 17, "token_count": 197, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-018", "document_id": "lifecycle-life", "content": "```\n\nThis default copy constructor works in most cases, but there are a few cases\nwhere you need to define a custom copy constructor:\n\n- One or more of the struct's fields is not `Copyable`.\n- The struct includes a non-owning type (like\n [`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer)), and you\n want to make a deep copy of the data.\n- The struct holds other resources (like file descriptors or network sockets)\n that need to be managed.", "position": 18, "token_count": 127, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-018", "document_id": "lifecycle-life", "position": 18, "token_count": 127, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-019", "document_id": "lifecycle-life", "content": "### Custom copy constructor\n\nWhat makes Mojo's copy behavior different, compared to other languages, is that\n`__copyinit__()` is designed to perform a deep copy of all fields in the type\n(as per [value semantics](/mojo/manual/values/value-semantics)). That is,\nit copies heap-allocated values, rather than just copying the pointer.\n\nHowever, the Mojo compiler doesn't enforce this, so it's the type author's\nresponsibility to implement `__copyinit__()` with value semantics.\n\nFor example, here's a new `HeapArray` type with a custom copy constructor that\nperforms a deep copy:\n\n```mojo\nstruct HeapArray(Copyable):\n var data: UnsafePointer[Int]\n var size: Int\n var cap: Int", "position": 19, "token_count": 183, "has_code": true, "section_hierarchy": ["Custom copy constructor"], "metadata": {"chunk_id": "lifecycle-life-019", "document_id": "lifecycle-life", "position": 19, "token_count": 183, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Custom copy constructor"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#custom-copy-constructor"}}
{"chunk_id": "lifecycle-life-020", "document_id": "lifecycle-life", "content": "```mojo\nstruct HeapArray(Copyable):\n var data: UnsafePointer[Int]\n var size: Int\n var cap: Int\n\n fn __init__(out self, size: Int, val: Int):\n self.size = size\n self.cap = size * 2\n self.data = UnsafePointer[Int].alloc(self.cap)\n for i in range(self.size):\n (self.data + i).init_pointee_copy(val)\n\n fn __copyinit__(out self, existing: Self):\n # Deep-copy the existing value\n self.size = existing.size\n self.cap = existing.cap\n self.data = UnsafePointer[Int].alloc(self.cap)\n for i in range(self.size):\n (self.data + i).init_pointee_copy(existing.data[i])\n # The lifetime of `existing` continues unchanged", "position": 20, "token_count": 212, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-020", "document_id": "lifecycle-life", "position": 20, "token_count": 212, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-021", "document_id": "lifecycle-life", "content": "fn __del__(deinit self):\n # We must free the heap-allocated data, but\n # Mojo knows how to destroy the other fields\n for i in range(self.size):\n (self.data + i).destroy_pointee()\n self.data.free()\n\n fn append(mut self, val: Int):\n # Update the array for demo purposes\n if self.size < self.cap:\n (self.data + self.size).init_pointee_copy(val)\n self.size += 1\n else:\n print(\"Out of bounds\")\n\n fn dump(self):\n # Print the array contents for demo purposes\n print(\"[\", end=\"\")\n for i in range(self.size):\n if i > 0:\n print(\", \", end=\"\")\n print(self.data[i], end=\"\")\n print(\"]\")", "position": 21, "token_count": 205, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-021", "document_id": "lifecycle-life", "position": 21, "token_count": 205, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-022", "document_id": "lifecycle-life", "content": "```\n\nNotice that `__copyinit__()` does not copy the `UnsafePointer` value (doing so\nwould make the copied value refer to the same `data` memory address as the\noriginal value, which is a shallow copy). Instead, we initialize a new\n`UnsafePointer` to allocate a new block of memory, and then copy over all the\nheap-allocated values (this is a deep copy).\n\nThus, when we copy an instance of `HeapArray`, each copy has its own set of\nvalues on the heap, so changes to one array do not affect the other, as shown\nhere:\n\n```mojo\nfn copies():\n var a = HeapArray(2, 1)\n var b = a.copy() # Calls the copy constructor\n a.dump() # Prints [1, 1]\n b.dump() # Prints [1, 1]\n\n b.append(2) # Changes the copied data\n b.dump() # Prints [1, 1, 2]\n a.dump() # Prints [1, 1] (the original did not change)", "position": 22, "token_count": 242, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-022", "document_id": "lifecycle-life", "position": 22, "token_count": 242, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-023", "document_id": "lifecycle-life", "content": "```\n\nTwo other things to note from the `__copyinit__()` method:\n\n- The `existing` argument is type `Self` (capital \"S\"). `Self` is an alias for\n the current type name (`HeapArray`, in this example). Using this alias is a\n best practice to avoid any mistakes when referring to the current struct name.\n\n- The `existing` argument is immutable because the default [argument\n convention](/mojo/manual/values/ownership#argument-conventions) is\n `read`—this is a good thing because this function should not modify the\n contents of the value being copied.\n\n[note]\nIn `HeapArray`, we must use the `__del__()` destructor to free the\nheap-allocated data when the `HeapArray` lifetime ends, but Mojo automatically\ndestroys all other fields when their respective lifetimes end. We'll discuss\nthis destructor more in [Death of a value](/mojo/manual/lifecycle/death).", "position": 23, "token_count": 227, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-023", "document_id": "lifecycle-life", "position": 23, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-024", "document_id": "lifecycle-life", "content": "If your type doesn't use any pointers for heap-allocated data, then writing the\nconstructor and copy constructor is all boilerplate code that you shouldn't have\nto write. For most structs that don't manage memory explicitly, you can just add\nthe `Copyable` trait to your struct definition and Mojo will synthesize the\n`__copyinit__()` method.\n\n[note]\nMojo also calls upon the copy constructor when a value is passed to a\nfunction that takes the argument as\n[`var`](/mojo/manual/values/ownership#transfer-arguments-var-and-)\n*and* when the lifetime of the given value does *not* end at that point. If the\nlifetime of the value does end there (usually indicated with the transfer\nsigil `^`), then Mojo instead invokes the move constructor.", "position": 24, "token_count": 190, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-024", "document_id": "lifecycle-life", "position": 24, "token_count": 190, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-025", "document_id": "lifecycle-life", "content": "### Implicitly-copyable types\n\nTo make a type *implicitly copyable*, add the `ImplicitlyCopyable` trait:\n\n```mojo\n@fieldwise_init\nstruct MyPair(ImplicitlyCopyable, Movable):\n var first: Int\n var second: Int\n\ndef main():\n pair = MyPair(3, 4)\n copy = pair\n print(pair.first, copy.second)\n```\n\nThe `ImplicitlyCopyable` trait inherits from `Copyable`, so adding\n`ImplicitlyCopyable` to your type gives you a copy constructor and a default `copy()`\nmethod. The trait doesn't define any methods of its own: it serves as a signal\nto the compiler that it can insert calls to `__copyinit__()` as needed. For\nexample, in the previous example, the compiler might generate code equivalent\nto:\n\n```mojo\npair = MyPair(3, 4)\ncopy = MyPair.__copyinit__(pair)", "position": 25, "token_count": 230, "has_code": true, "section_hierarchy": ["Implicitly-copyable types"], "metadata": {"chunk_id": "lifecycle-life-025", "document_id": "lifecycle-life", "position": 25, "token_count": 230, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implicitly-copyable types"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#implicitly-copyable-types"}}
{"chunk_id": "lifecycle-life-026", "document_id": "lifecycle-life", "content": "```\n\nA type should be implicitly copyable only if copying the type is inexpensive and\nhas no side effects. Unnecessary copies can be a big drain on memory and\nperformance, so use this trait with caution.\n\nIn particular, any type that dynamically allocates memory or manages other\nresources probably shouldn't be implicitly copyable.", "position": 26, "token_count": 71, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-026", "document_id": "lifecycle-life", "position": 26, "token_count": 71, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-027", "document_id": "lifecycle-life", "content": "## Move constructor\n\nAlthough copying values provides predictable behavior that matches Mojo's\n[value semantics](/mojo/manual/values/value-semantics), copying some data\ntypes can be a significant hit on performance.\n\nMojo uses the move constructor to transfer ownership of a value from one\nvariable to another, **without** copying its fields. A value that's copyable\nbut doesn't have a move constructor can still be transferred by making a copy\nand then discarding the original. So in this case, the move constructor serves\nas an optimization.\n\nTo make a type *movable*:\n\n- Add the `Movable` trait.\n- (Optionally) implement a custom `__moveinit__()` method.\n\nNote that [register-passable values](/mojo/manual/decorators/register-passable)\ntypes are automatically movable, and **cannot** define a custom `__moveinit__()`\nmethod.\n\nHere's a movable version of the `MyPet` struct:", "position": 27, "token_count": 226, "has_code": false, "section_hierarchy": ["Move constructor"], "metadata": {"chunk_id": "lifecycle-life-027", "document_id": "lifecycle-life", "position": 27, "token_count": 226, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Move constructor"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#move-constructor"}}
{"chunk_id": "lifecycle-life-028", "document_id": "lifecycle-life", "content": "Here's a movable version of the `MyPet` struct:\n\n```mojo\n@fieldwise_init\nstruct MyPet(Copyable, Movable):\n var name: String\n var age: Int", "position": 28, "token_count": 50, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-028", "document_id": "lifecycle-life", "position": 28, "token_count": 50, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-029", "document_id": "lifecycle-life", "content": "```\n\nHere's an example showing how to invoke the move constructor for `MyPet`:\n\n```mojo\nfn moves():\n var a = MyPet(\"Bobo\", 2)\n\n print(a.name) # Prints \"bobo\"\n\n var b = a^ # the lifetime of `a` ends here\n\n print(b.name) # prints \"bobo\"\n # print(a.name) # ERROR: use of uninitialized value 'a'\n```\n\nIf you include the `Movable` trait and don't define a move constructor, Mojo\ngenerates a default move constructor for you. This move constructor simply moves\neach of the fields to the new instance.\n\nThe generated move constructor for `MyPet` would look like this if you wrote\nit yourself:\n\n```mojo\nfn __moveinit__(out self, deinit existing: Self):\n self.name = existing.name^\n self.age = existing.age", "position": 29, "token_count": 211, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-029", "document_id": "lifecycle-life", "position": 29, "token_count": 211, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-030", "document_id": "lifecycle-life", "content": "```\n\nThe move constructor takes its `existing` argument using the `deinit`\n[argument convention](/mojo/manual/values/ownership#argument-conventions), which\ngrants exclusive ownership of the value and marks it as destroyed at the end of\nthe function. (For more information on the `deinit` convention, see\n[Field lifetimes during destruct and move](/mojo/manual/lifecycle/death#field-lifetimes-during-destruct-and-move)).\n\nThe move constructor uses the transfer sigil (`^`) to indicate that ownership of\nthe `name` value is being transferred from `existing` to `self`. For\nregister-passable types like `Int`, the transfer sigil is omitted:\nregister-passable types are always treated as movable, but they can't define\ncustom move constructors or destructors, so there's no special logic to run for\na move.", "position": 30, "token_count": 205, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-030", "document_id": "lifecycle-life", "position": 30, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-031", "document_id": "lifecycle-life", "content": "At the end of the `__moveinit__()` method, Mojo immediately invalidates the\noriginal variable, preventing any access to it. It does **not** call the\ndestructor, since that would destroy resources that have been transferred to the\nnew instance. Invalidating the original variable is important to avoid memory\nerrors on heap-allocated data, such as use-after-free and double-free errors.\n\n[note]\nA move constructor is **not required** to transfer ownership of a\nvalue. If a value is copyable but not movable, Mojo can copy the value and\ninvalidate the original instance. You can learn more in the section about\n[ownership\ntransfer](/mojo/manual/values/ownership#transfer-arguments-var-and-).\n\nIf copying a type is expensive, moving it with `__moveinit__()` is much\nmore efficient. For example, if a type has heap-allocated data, `__copyinit__()`\ntypically needs to allocate new storage to make a deep copy of the data.", "position": 31, "token_count": 233, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-031", "document_id": "lifecycle-life", "position": 31, "token_count": 233, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-032", "document_id": "lifecycle-life", "content": "For types without heap-allocated fields, you get no real benefit from the move\nconstructor. Making copies of simple data types on the stack, like integers,\nfloats, and booleans, is very cheap. Yet, if you allow your type to be copied,\nthen there's generally no reason to disallow moves.", "position": 32, "token_count": 69, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-032", "document_id": "lifecycle-life", "position": 32, "token_count": 69, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-033", "document_id": "lifecycle-life", "content": "### Custom move constructor\n\nIn practice, structs very rarely require a custom `__moveinit__()`. A type might\nrequire a custom `__moveinit__()` if it has a pointer to itself or one of its\nfields, for example, since the struct's location in memory changes when it's\nmoved.\n\nThe `__moveinit__()` method performs a consuming move: it [transfers\nownership](/mojo/manual/values/ownership#transfer-arguments-var-and-) of a\nvalue from one variable to another when the original variable's lifetime ends\n(also called a \"destructive move\").", "position": 33, "token_count": 150, "has_code": false, "section_hierarchy": ["Custom move constructor"], "metadata": {"chunk_id": "lifecycle-life-033", "document_id": "lifecycle-life", "position": 33, "token_count": 150, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Custom move constructor"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#custom-move-constructor"}}
{"chunk_id": "lifecycle-life-034", "document_id": "lifecycle-life", "content": "A critical feature of `__moveinit__()` is that it takes the incoming value as\na `deinit` argument, meaning this method gets unique ownership of the value. Moreover,\nbecause this is a dunder method that Mojo calls only when performing a move\n(during ownership transfer), the `existing` argument is guaranteed to be a\nmutable reference to the original value, *not a copy* (unlike other methods that\nmay declare an argument as `var`, but might receive the value as a copy if the\nmethod is called without the [`^` transfer\nsigil](/mojo/manual/values/ownership#transfer-arguments-var-and-)).\nThat is, Mojo calls this move constructor *only* when the original variable's\nlifetime actually ends at the point of transfer.", "position": 34, "token_count": 174, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-034", "document_id": "lifecycle-life", "position": 34, "token_count": 174, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-035", "document_id": "lifecycle-life", "content": "## Move-only and immovable types\n\nTo ensure your type can't be implicitly copied, you can make it \"move-only\" by\nmaking it `Movable` but not `Copyable`. A move-only type can be\npassed to other variables and passed into functions with any argument convention\n(`read`, `mut`, and `var`)—the only catch is that you must use the `^`\ntransfer sigil to end the lifetime of a move-only type when assigning it to a\nnew variable or when passing it as a `var` argument. The\n[`OwnedPointer`](/mojo/stdlib/memory/owned_pointer/OwnedPointer/) is an\nexample of a move-only type: because it is designed to provide clear single\nownership of a stored value, the `OwnedPointer` can be moved, but not copied.\n\nIn some (rare) cases, you may not want a type to be copyable *or* movable. The\n[`Atomic`](/mojo/stdlib/os/atomic/Atomic/) type is an example of a type that's\nneither copyable or movable.", "position": 35, "token_count": 251, "has_code": false, "section_hierarchy": ["Move-only and immovable types"], "metadata": {"chunk_id": "lifecycle-life-035", "document_id": "lifecycle-life", "position": 35, "token_count": 251, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Move-only and immovable types"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#move-only-and-immovable-types"}}
{"chunk_id": "lifecycle-life-036", "document_id": "lifecycle-life", "content": "## Trivial types\n\nSo far, we've talked about values that live in memory, which means they have an\nidentity (an address) that can be passed around among functions (passed \"by\nreference\"). This is great for most types, and it's a safe default for large\nobjects with expensive copy operations. However, it's inefficient for tiny\nthings like a single integer or floating point number. We call these types\n\"trivial\" because they are just \"bags of bits\" that should be copied, moved,\nand destroyed without invoking any custom lifecycle methods.\n\nTrivial types are the most common types that surround us, and from a language\nperspective, Mojo doesn't need special support for these written in a struct.\nUsually, these values are so tiny that they should be passed around in CPU\nregisters, not indirectly through memory.", "position": 36, "token_count": 178, "has_code": false, "section_hierarchy": ["Trivial types"], "metadata": {"chunk_id": "lifecycle-life-036", "document_id": "lifecycle-life", "position": 36, "token_count": 178, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Trivial types"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#trivial-types"}}
{"chunk_id": "lifecycle-life-037", "document_id": "lifecycle-life", "content": "As such, Mojo provides a struct decorator to declare these types of values:\n`@register_passable(\"trivial\")`. This decorator tells Mojo that the type should\nbe copyable and movable but that it has no user-defined logic for this (no\ncustom copy constructor or move constructor). It also tells Mojo to pass the\nvalue in CPU registers whenever possible, which has clear performance benefits.\n\nYou'll see this decorator on types like `Int` in the standard library:\n\n```mojo\n@register_passable(\"trivial\")\nstruct Int:\n ...", "position": 37, "token_count": 131, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-037", "document_id": "lifecycle-life", "position": 37, "token_count": 131, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-038", "document_id": "lifecycle-life", "content": "```\n\nWe expect to use this decorator pervasively on Mojo standard library types, but\nit is safe to ignore for general application-level code.\n\nFor more information, see the [`@register_passable`\ndocumentation](/mojo/manual/decorators/register-passable).", "position": 38, "token_count": 65, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-life-038", "document_id": "lifecycle-life", "position": 38, "token_count": 65, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life"}}
{"chunk_id": "lifecycle-life-039", "document_id": "lifecycle-life", "content": "### Trivial lifecycle methods\n\nThe use of a decorator to identify trivial types will be phased out in favor\nof a more granular set of aliases, which are boolean flags set by the compiler:\n\n- The `Copyable` trait defines the alias `__copyinit__is_trivial`, which is an\n optimization hint that guarantees that the value can be copied by its bits\n from one location to another without causing any side effects.\n\n- The `Movable` trait defines the alias `__moveinit__is_trivial`, which is an\n optimization hint that guarantees that the value can be moved by its bits\n from one location to another without causing any side effects.\n\n- The `AnyType` trait defines the alias `__del__is_trivial`, which is a hint\n that the `__del__()` method is a no-op.", "position": 39, "token_count": 188, "has_code": false, "section_hierarchy": ["Trivial lifecycle methods"], "metadata": {"chunk_id": "lifecycle-life-039", "document_id": "lifecycle-life", "position": 39, "token_count": 188, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Trivial lifecycle methods"], "file_path": "lifecycle/life.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/life", "title": "Life of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/life#trivial-lifecycle-methods"}}

{"chunk_id": "values-lifetimes-000", "document_id": "values-lifetimes", "content": "The Mojo compiler includes a lifetime checker, a compiler pass that analyzes\ndataflow through your program. It identifies when variables are valid and\ninserts destructor calls when a variable's lifetime ends.\n\nThe Mojo compiler uses a special value called an *origin* to track the lifetime\nof variables and the validity of references.\n\nSpecifically, an origin answers two questions:\n\n* What variable \"owns\" this value?\n* Can the value be mutated using this reference?\n\nFor example, consider the following code:\n\n```mojo\ndef print_str(s: String):\n print(s)\n\ndef main():\n name: String = \"Joan\"\n print_str(name)\n```\n\n```output\nJoan", "position": 0, "token_count": 150, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-000", "document_id": "values-lifetimes", "position": 0, "token_count": 150, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-001", "document_id": "values-lifetimes", "content": "```\n\nThe line `name = \"Joan\"` declares a variable with an identifier (`name`)\nand logical storage space for a `String` value. When you pass `name` into the\n`print_str()` function, the function gets an immutable reference to the value.\nSo both `name` and `s` refer to the same logical storage space, and have\nassociated origin values that lets the Mojo compiler reason about them.\n\nOrigin tracking and lifetime checking is done at compile time, so origins don't\ntrack the actual storage space allocated for the `name` variable, for example.\nInstead, origins track variables symbolically, so the compiler tracks that\n`print_str()` is called with a value owned by `name` in the caller's scope. By\ntracking how owned data flows through the program, the compiler can identify\nthe lifetimes of values.\n\nMost of the time, origins are handled automatically by the compiler.\nHowever, in some cases you'll need to interact with origins directly:\n\n* When working with references—specifically `ref` arguments and `ref` return\n values.", "position": 1, "token_count": 236, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-001", "document_id": "values-lifetimes", "position": 1, "token_count": 236, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-002", "document_id": "values-lifetimes", "content": "* When working with references—specifically `ref` arguments and `ref` return\n values.\n\n* When working with types like\n [`Pointer`](/mojo/stdlib/memory/pointer/Pointer) or\n [`Span`](/mojo/stdlib/memory/span/Span) which are parameterized on the\n origin of the data they refer to.\n\nThis section also covers [`ref` arguments](#ref-arguments) and\n[`ref` return values](#ref-return-values), which let functions\ntake arguments and provide return values as references with parametric\norigins.", "position": 2, "token_count": 128, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-002", "document_id": "values-lifetimes", "position": 2, "token_count": 128, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-003", "document_id": "values-lifetimes", "content": "## Working with origins\n\nMojo's origin values are mostly created by the\ncompiler, so you can't just create your own origin value—you usually need to\nderive an origin from an existing value.\n\nAmong other things, Mojo uses origins to extend the lifetimes of referenced\nvalues, so values aren't destroyed prematurely.", "position": 3, "token_count": 67, "has_code": false, "section_hierarchy": ["Working with origins"], "metadata": {"chunk_id": "values-lifetimes-003", "document_id": "values-lifetimes", "position": 3, "token_count": 67, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Working with origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#working-with-origins"}}
{"chunk_id": "values-lifetimes-004", "document_id": "values-lifetimes", "content": "### Origin types\n\nMojo supplies a struct and a set of aliases that you can use to specify\norigin types. As the names suggest, the `ImmutOrigin` and\n`MutOrigin` aliases represent immutable and mutable origins,\nrespectively:\n\n```mojo\nstruct ImmutRef[origin: ImmutOrigin]:\n pass\n```\n\nOr you can use the [`Origin`](/mojo/stdlib/builtin/type_aliases/Origin)\nstruct to specify an origin with parametric mutability:\n\n```mojo\nstruct ParametricRef[\n is_mutable: Bool,\n //,\n origin: Origin[is_mutable]\n]:\n pass", "position": 4, "token_count": 160, "has_code": true, "section_hierarchy": ["Origin types"], "metadata": {"chunk_id": "values-lifetimes-004", "document_id": "values-lifetimes", "position": 4, "token_count": 160, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Origin types"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#origin-types"}}
{"chunk_id": "values-lifetimes-005", "document_id": "values-lifetimes", "content": "```\n\nOrigin types carry the mutability of a reference as a boolean parameter value,\nindicating whether the origin is mutable, immutable, or even with mutability\ndepending on a parameter specified by the enclosing API.\n\nThe `is_mutable` parameter here is an [infer-only\nparameter](/mojo/manual/parameters/#infer-only-parameters). The `origin` value\nis often inferred, as well. For example, the following code creates a\n[`Pointer`](/mojo/stdlib/memory/pointer/Pointer) to an existing value, but\ndoesn't need to specify an origin—the `origin` is inferred from the existing\nvalue.\n\n```mojo\nfrom memory import Pointer\n\ndef use_pointer():\n a = 10\n ptr = Pointer(to=a)\n```", "position": 5, "token_count": 186, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-005", "document_id": "values-lifetimes", "position": 5, "token_count": 186, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-006", "document_id": "values-lifetimes", "content": "### Origin sets\n\nAn `OriginSet` is not a type of origin, it represents a group of origins. Origin\nsets are used for tracking the lifetimes of values captured in closures.", "position": 6, "token_count": 42, "has_code": false, "section_hierarchy": ["Origin sets"], "metadata": {"chunk_id": "values-lifetimes-006", "document_id": "values-lifetimes", "position": 6, "token_count": 42, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Origin sets"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#origin-sets"}}
{"chunk_id": "values-lifetimes-007", "document_id": "values-lifetimes", "content": "### Origin values\n\nMost origin values are created by the compiler. As a developer, there are a\nfew ways to specify origin values:\n\n* Static origin. The `StaticConstantOrigin` alias is an origin value\n representing immutable values that last for the duration of the program.\n String literal values have a `StaticConstantOrigin`.\n* Derived origin. The `origin_of()` magic function returns the origin\n associated with the value (or values) passed in.\n* Inferred origin. You can use inferred parameters to capture the origin of a\n value passed in to a function.\n* External origins. The external origins, `MutOrigin.external` and\n `ImmutOrigin.external` represent values that are not tracked by the lifetime\n checker, such as dynamically-allocated memory.\n* Wildcard origins. The `ImmutAnyOrigin` and `MutAnyOrigin` aliases are\n special cases indicating a reference that might access any live value.", "position": 7, "token_count": 208, "has_code": false, "section_hierarchy": ["Origin values"], "metadata": {"chunk_id": "values-lifetimes-007", "document_id": "values-lifetimes", "position": 7, "token_count": 208, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Origin values"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#origin-values"}}
{"chunk_id": "values-lifetimes-008", "document_id": "values-lifetimes", "content": "#### Static origins\n\nYou can use the static origin `StaticConstantOrigin` when you have a\nvalue that exists for the entire duration of the program.\n\nFor example, the `StringLiteral` method\n[`as_string_slice()`](/mojo/stdlib/builtin/string_literal/StringLiteral#as_string_slice)\nreturns a\n[`StringSlice`](/mojo/stdlib/collections/string/string_slice/StringSlice)\npointing to the original string literal. String literals are static—they're\nallocated at compile time and never destroyed—so the slice is created with an\nimmutable, static origin.", "position": 8, "token_count": 148, "has_code": false, "section_hierarchy": ["Static origins"], "metadata": {"chunk_id": "values-lifetimes-008", "document_id": "values-lifetimes", "position": 8, "token_count": 148, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Static origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#static-origins"}}
{"chunk_id": "values-lifetimes-009", "document_id": "values-lifetimes", "content": "#### Derived origins\n\nUse the `origin_of(value)` operator to obtain a value's origin. An argument\nto `origin_of()` can take an arbitrary expression that yields one of the\nfollowing:\n\n- An origin value.\n\n- A value with a memory location.\n\nFor example:\n\n```mojo\norigin_of(self)\norigin_of(x.y)\norigin_of(foo())", "position": 9, "token_count": 91, "has_code": true, "section_hierarchy": ["Derived origins"], "metadata": {"chunk_id": "values-lifetimes-009", "document_id": "values-lifetimes", "position": 9, "token_count": 91, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Derived origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#derived-origins"}}
{"chunk_id": "values-lifetimes-010", "document_id": "values-lifetimes", "content": "```\n\nThe `origin_of()` operator is analyzed statically at compile time;\nThe expressions passed to `origin_of()` are never evaluated. (For example,\nwhen the compiler analyzes `origin_of(foo())`, it doesn't run the `foo()`\nfunction.)\n\nThe following struct stores a string value using a\n[`OwnedPointer`](/mojo/stdlib/memory/owned_pointer/OwnedPointer): a smart\npointer that holds an owned value. The `as_ptr()` method returns a `Pointer` to\nthe stored string, using the same origin as the original `OwnedPointer`.\n\n```mojo\nfrom memory import OwnedPointer, Pointer\n\nstruct BoxedString:\n var o_ptr: OwnedPointer[String]\n\n fn __init__(out self, value: String):\n self.o_ptr = OwnedPointer(value)", "position": 10, "token_count": 212, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-010", "document_id": "values-lifetimes", "position": 10, "token_count": 212, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-011", "document_id": "values-lifetimes", "content": "fn __init__(out self, value: String):\n self.o_ptr = OwnedPointer(value)\n\n fn as_ptr(mut self) -> Pointer[String, origin_of(self.o_ptr)]:\n return Pointer(to=self.o_ptr[])", "position": 11, "token_count": 76, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-011", "document_id": "values-lifetimes", "position": 11, "token_count": 76, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-012", "document_id": "values-lifetimes", "content": "```\n\nNote that the `as_ptr()` method takes its `self` argument as `mut self`. If it\nused the default `read` argument convention, it would be immutable, and the\nderived origin (`origin_of(self.o_ptr)`) would also be immutable.\n\nYou can also pass multiple expressions to `origin_of()` to express the union\nof two or more origins:\n\n`origin_of(a, b)`", "position": 12, "token_count": 108, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-012", "document_id": "values-lifetimes", "position": 12, "token_count": 108, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-013", "document_id": "values-lifetimes", "content": "#### Origin unions\n\nThe union of two or more origins creates a new origin that references all of\nthe original origins for the purposes of lifetime extension (so a union of the\norigins of `a` and `b` extends both lifetimes).\n\nAn origin union is mutable if and only if all of its constituent origins are\nmutable. For an example, see\n[Return values with union origins](#return-values-with-union-origins).\n\n#### Inferred origins\n\nSince origins are parameters, the compiler can *infer* an origin value from an\nthe argument passed to a function or method, as described in\n[Parameter inference](/mojo/manual/parameters/#parameter-inference). This allows\na function to return a value that has the same origin as the argument passed to\nit.\n\nSee the section on [`ref` arguments](#ref-arguments) for an example using an\ninferred origin.", "position": 13, "token_count": 198, "has_code": false, "section_hierarchy": ["Inferred origins"], "metadata": {"chunk_id": "values-lifetimes-013", "document_id": "values-lifetimes", "position": 13, "token_count": 198, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Inferred origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#inferred-origins"}}
{"chunk_id": "values-lifetimes-014", "document_id": "values-lifetimes", "content": "#### External origins\n\nThe external origins, `MutOrigin.external` and `ImmutOrigin.external` represent\nvalues that do not alias any existing value. That is, they point to memory that\nis not owned by any other variable, and are therefore not tracked by the\nlifetime checker. For example, the\n[`alloc()`](/mojo/stdlib/memory/unsafe_pointer/alloc/) function returns an\n`UnsafePointer` to a new dynamically-allocated block of memory, with the origin\n`MutOrigin.external`. The origin indicates that the memory is not managed by the\nMojo ownership system. When you use an unsafe API like this, you're responsible\nfor managing the lifetime yourself: for example, a struct that allocates memory\nshould generally free that memory in its destructor.", "position": 14, "token_count": 182, "has_code": false, "section_hierarchy": ["External origins"], "metadata": {"chunk_id": "values-lifetimes-014", "document_id": "values-lifetimes", "position": 14, "token_count": 182, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["External origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#external-origins"}}
{"chunk_id": "values-lifetimes-015", "document_id": "values-lifetimes", "content": "#### Wildcard origins\n\nThe wildcard origins, `ImmutAnyOrigin` and `MutAnyOrigin`, are special cases\nindicating a reference that might access any live value. These were previously\nwidely used for unsafe pointers. Using a pointer with a wildcard origin into a\nscope effectively disables Mojo's ASAP destruction for any values in that scope,\nas long as the pointer is live. Accordingly, the use of wildcard origins is\ndiscouraged, and should be used as a last resort.", "position": 15, "token_count": 109, "has_code": false, "section_hierarchy": ["Wildcard origins"], "metadata": {"chunk_id": "values-lifetimes-015", "document_id": "values-lifetimes", "position": 15, "token_count": 109, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Wildcard origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#wildcard-origins"}}
{"chunk_id": "values-lifetimes-016", "document_id": "values-lifetimes", "content": "## Working with references\n\nYou can use the `ref` keyword with arguments and return values to specify a\nreference with parametric mutability. That is, they can be either mutable or\nimmutable.\n\nFrom inside the called function, a `ref` argument looks like a `read` or\n`mut` argument.\n\nA `ref` return value looks like any other return value to the calling function,\nbut it is a *reference* to an existing value, not a copy.", "position": 16, "token_count": 103, "has_code": false, "section_hierarchy": ["Working with references"], "metadata": {"chunk_id": "values-lifetimes-016", "document_id": "values-lifetimes", "position": 16, "token_count": 103, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Working with references"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#working-with-references"}}
{"chunk_id": "values-lifetimes-017", "document_id": "values-lifetimes", "content": "### `ref` arguments\n\nThe `ref` argument convention lets you specify an argument of parametric\nmutability: that is, you don't need to know in advance whether the passed\nargument will be mutable or immutable. There are several reasons you might want\nto use a `ref` argument:\n\n* You want to accept an argument with parametric mutability.\n\n* You want to tie the lifetime of one argument to the lifetime of another\n argument.\n\n* When you want an argument that is guaranteed to be passed in memory: this can\n be important and useful for generic arguments that need an identity,\n irrespective of whether the concrete type is register passable.\n\nThe syntax for a `ref` argument is:\n\n<code><strong>ref</strong> <var>arg_name</var>: <var>arg_type</var></code>\n\nOr:", "position": 17, "token_count": 191, "has_code": false, "section_hierarchy": ["`ref` arguments"], "metadata": {"chunk_id": "values-lifetimes-017", "document_id": "values-lifetimes", "position": 17, "token_count": 191, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`ref` arguments"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#ref-arguments"}}
{"chunk_id": "values-lifetimes-018", "document_id": "values-lifetimes", "content": "<code><strong>ref</strong> <var>arg_name</var>: <var>arg_type</var></code>\n\nOr:\n\n<code><strong>ref [</strong><var>origin_specifier(s)</var><strong>]</strong>\n<var>arg_name</var>: <var>arg_type</var></code>\n\nIn the first form, the origin and mutability of the `ref` argument is inferred\nfrom the value passed in. The second form includes an origin clause, consisting\nof one or more origin specifiers inside square brackets. An origin\nspecifier can be either:\n\n* An origin value.\n\n* An arbitrary expression, which is treated as shorthand for\n `origin_of(expression)`. In other words, the following declarations are\n equivalent:\n\n ```mojo\n ref [origin_of(self)]\n ref [self]", "position": 18, "token_count": 212, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-018", "document_id": "values-lifetimes", "position": 18, "token_count": 212, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-019", "document_id": "values-lifetimes", "content": "```\n\n* An [`AddressSpace`](/nightly/mojo/stdlib/memory/pointer/AddressSpace) value.\n\n* An underscore character (`_`) to indicate that the origin is *unbound*. This\n is equivalent to omitting the origin specifier.\n\n ```mojo\n def add_ref(ref a: Int, b: Int) -> Int:\n return a+b", "position": 19, "token_count": 92, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-019", "document_id": "values-lifetimes", "position": 19, "token_count": 92, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-020", "document_id": "values-lifetimes", "content": "```\n\nYou can also name the origin explicitly. This is useful if you want to\nrestrict the argument to either a `ImmutOrigin` or `MutOrigin`, or if\nyou want to bind a function's return value to the origin of an argument.\n\nFor example, the `Span` type is a non-owning view of contiguous data (like a\nsubstring of a string, or a subset of a list). Because it points to data that it\ndoesn't own, it is parameterized on an origin value that represents the lifetime\nand ownership of the data it points to.\n\nIn the following example, the `to_byte_span()` function takes a `List[Byte]` and\nreturns a `Span[Byte]` with the same origin as the list:\n\n```mojo\nfrom collections import List\nfrom memory import Span\n\ndef to_byte_span[\n is_mutable: Bool,\n //,\n origin: Origin[is_mutable],\n](ref [origin]list: List[Byte]) -> Span[Byte, origin]:\n return Span(list)", "position": 20, "token_count": 234, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-020", "document_id": "values-lifetimes", "position": 20, "token_count": 234, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-021", "document_id": "values-lifetimes", "content": "def main():\n list: List[Byte] = [77, 111, 106, 111]\n span = to_byte_span(list)", "position": 21, "token_count": 33, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-021", "document_id": "values-lifetimes", "position": 21, "token_count": 33, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-022", "document_id": "values-lifetimes", "content": "```\n\nIn this example, the `origin` parameter is inferred from the `list` argument,\nand then used as the origin for the returned `Span`.\n\nSince the `Span` takes on the origin of the `list` argument, the Mojo compiler\ncan identify the span's data as owned by the list. The span will have the same\nlifetime as the list, and the span will be mutable if the list is mutable.", "position": 22, "token_count": 95, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-022", "document_id": "values-lifetimes", "position": 22, "token_count": 95, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-023", "document_id": "values-lifetimes", "content": "### `ref` return values\n\nLike `ref` arguments, `ref` return values allow a function to return a mutable\nor immutable reference to a value. The syntax for a `ref` return value is:\n\n<code><strong>-> ref [</strong><var>origin_specifier(s)</var><strong>]</strong>\n <var>arg_type</var></code>\n\nNote that you **must** provide an origin specifier for a `ref` return value. The\nvalues allowed for origin specifiers are the same as the ones listed for\n[`ref` arguments](#ref-arguments).\n\n`ref` return values can be an efficient way to handle updating items in a\ncollection. The standard way to do this is by implementing the `__getitem__()`\nand `__setitem__()` dunder methods. These are invoked to read from and write to\na subscripted item in a collection:\n\n```mojo\nvalue = list[a]\nlist[b] += 10", "position": 23, "token_count": 240, "has_code": true, "section_hierarchy": ["`ref` return values"], "metadata": {"chunk_id": "values-lifetimes-023", "document_id": "values-lifetimes", "position": 23, "token_count": 240, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`ref` return values"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#ref-return-values"}}
{"chunk_id": "values-lifetimes-024", "document_id": "values-lifetimes", "content": "```\n\nWith a `ref` argument, `__getitem__()` can return a mutable reference that can\nbe modified directly. This has pros and cons compared to using a `__setitem__()`\nmethod:\n\n* The mutable reference is more efficient—a single update isn't broken up across\n two methods. However, the referenced value must be in memory.\n\n* A `__getitem__()`/`__setitem__()` pair allows for arbitrary code to be run\n when values are retrieved and set. For example, `__setitem__()` can validate\n or constrain input values.\n\nFor example, in the following example, `NameList` has a `__getitem__()` method\nthat returns a reference:\n\n```mojo\nstruct NameList:\n var names: List[String]", "position": 24, "token_count": 202, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-024", "document_id": "values-lifetimes", "position": 24, "token_count": 202, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-025", "document_id": "values-lifetimes", "content": "```mojo\nstruct NameList:\n var names: List[String]\n\n def __init__(out self, *names: String):\n self.names = []\n for name in names:\n self.names.append(name)\n\n def __getitem__(ref self, index: Int) ->\n ref [self.names] String:\n if (index >=0 and index < len(self.names)):\n return self.names[index]\n else:\n raise Error(\"index out of bounds\")\n\ndef main():\n list = NameList(\"Thor\", \"Athena\", \"Dana\", \"Vrinda\")\n ref name = list[2]\n print(name)\n name += \"?\"\n print(list[2])", "position": 25, "token_count": 169, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-025", "document_id": "values-lifetimes", "position": 25, "token_count": 169, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-026", "document_id": "values-lifetimes", "content": "```\n\n```output\nDana\nDana?\n```\n\nNote the use of the `ref name` syntax to create a reference binding.\n\nIf you assign a `ref` return value to a variable, the variable receives a\n*copy* of the referenced item. Use a\n[reference binding](/mojo/manual/variables#reference-bindings) if you need to\ncapture the reference for future use:\n\n```mojo\nvar name_copy = list[2] # owned copy of list[2]\nref name_ref = list[2] # reference to list[2]\n```", "position": 26, "token_count": 126, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-026", "document_id": "values-lifetimes", "position": 26, "token_count": 126, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-027", "document_id": "values-lifetimes", "content": "#### Parametric mutability of return values\n\nAnother advantage of `ref` return arguments is the ability to support parametric\nmutability. For example, recall the signature of the `__getitem__()` method\nabove:\n\n```mojo\ndef __getitem__(ref self, index: Int) ->\n ref [self] String:\n```\n\nSince the `origin` of the return value is tied to the origin of `self`, the\nreturned reference will be mutable if the method was called using a\nmutable reference. The method still works if you have an immutable reference\nto the `NameList`, but it returns an immutable reference:\n\n```mojo\nfn pass_immutable_list(list: NameList) raises:\n print(list[2])\n # list[2] += \"?\" # Error, this list is immutable\n\ndef main():\n list = NameList(\"Sophie\", \"Jack\", \"Diana\")\n pass_immutable_list(list)\n```\n\n```output\nDiana", "position": 27, "token_count": 238, "has_code": true, "section_hierarchy": ["Parametric mutability of return values"], "metadata": {"chunk_id": "values-lifetimes-027", "document_id": "values-lifetimes", "position": 27, "token_count": 238, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parametric mutability of return values"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#parametric-mutability-of-return-values"}}
{"chunk_id": "values-lifetimes-028", "document_id": "values-lifetimes", "content": "```\n\n```output\nDiana\n```\n\nWithout parametric mutability, you'd need to write two versions of\n`__getitem__()`, one that accepts an immutable `self` and another that accepts\na mutable `self`.", "position": 28, "token_count": 62, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-028", "document_id": "values-lifetimes", "position": 28, "token_count": 62, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-029", "document_id": "values-lifetimes", "content": "#### Return values with union origins\n\nA `ref` return value can include multiple values in its origin specifier, which\nyields the union of the origins. For example, the following `pick_one()`\nfunction returns a reference to one of the two input strings, with an origin\nthat's a union of both origins.\n\n```mojo\ndef pick_one(cond: Bool, ref a: String, ref b: String) -> ref [a, b] String:\n return a if cond else b\n```\n\nBecause the compiler can't statically determine which branch will be picked,\nthis function must use the union origin `[a, b]`. This ensures that the compiler\nextends the lifetime of _both_ values as long as the returned reference is live.\n\nThe returned reference is mutable if **both** `a` and `b` are mutable.", "position": 29, "token_count": 191, "has_code": true, "section_hierarchy": ["Return values with union origins"], "metadata": {"chunk_id": "values-lifetimes-029", "document_id": "values-lifetimes", "position": 29, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Return values with union origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#return-values-with-union-origins"}}

{"chunk_id": "operators-000", "document_id": "operators", "content": "Mojo includes a variety of operators for manipulating values of different types.\nGenerally, the operators are equivalent to those found in Python, though many\noperators also work with additional Mojo types such as `SIMD` vectors.\nAdditionally, Mojo allows you to define the behavior of most of these operators\nfor your own custom types by implementing special *dunder* (double underscore)\nmethods.\n\nThis document contains the following three sections:\n\n- [Operators and expressions](#operators-and-expressions) discusses Mojo's\n built-in operators and how they work with commonly used Mojo types.\n- [Implement operators for custom types](#implement-operators-for-custom-types)\n describes the dunder methods that you can implement to support using operators\n with custom structs that you create.\n- [An example of implementing operators for a custom\n type](#an-example-of-implementing-operators-for-a-custom-type) shows a\n progressive example of writing a custom struct with support for several\n operators.", "position": 0, "token_count": 209, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-000", "document_id": "operators", "position": 0, "token_count": 209, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-001", "document_id": "operators", "content": "## Operators and expressions\n\nThis section lists the operators that Mojo supports, their order or precedence\nand associativity, and describes how these operators behave with several\ncommonly used built-in types.", "position": 1, "token_count": 42, "has_code": false, "section_hierarchy": ["Operators and expressions"], "metadata": {"chunk_id": "operators-001", "document_id": "operators", "position": 1, "token_count": 42, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Operators and expressions"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#operators-and-expressions"}}
{"chunk_id": "operators-002", "document_id": "operators", "content": "### Operator precedence and associativity\n\nThe table below lists the various Mojo operators, along with their order of\nprecedence and associativity (also referred to as grouping). This table lists\noperators from the highest precedence to the lowest precedence.", "position": 2, "token_count": 55, "has_code": false, "section_hierarchy": ["Operator precedence and associativity"], "metadata": {"chunk_id": "operators-002", "document_id": "operators", "position": 2, "token_count": 55, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Operator precedence and associativity"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#operator-precedence-and-associativity"}}
{"chunk_id": "operators-003", "document_id": "operators", "content": "| **Operators** | **Description** | **Associativity (Grouping)** |\n| ------------- | --------------- | ----------------- |\n| `()` | Parenthesized expression | Left to right |\n| `x[index]`, `x[index:index]` | Subscripting, slicing | Left to right |\n| `**` | Exponentiation | Right to left |\n| `+x`, `-x`, `~x` | Positive, negative, bitwise NOT | Right to left |\n| `*`, `@`, `/`, `//`, `%` | Multiplication, matrix multiplication, division, floor division, remainder | Left to right |\n| `+`, `–` | Addition and subtraction | Left to right |", "position": 3, "token_count": 218, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-003", "document_id": "operators", "position": 3, "token_count": 218, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-004", "document_id": "operators", "content": "| `+`, `–` | Addition and subtraction | Left to right |\n| `<<`, `>>` | Shifts | Left to right |\n| `&` | Bitwise AND | Left to right |\n| `^` | Bitwise XOR | Left to right |\n| `\\|` | Bitwise OR | Left to right |\n| `in`, `not in`, `is`, `is not`, `<`, `<=`, `>`, `>=`, `!=`, `==` | Comparisons, membership tests, identity tests | Left to Right |\n| `not x` | Boolean NOT | Right to left |\n| `x and y` | Boolean AND | Left to right |\n| `x or y` | Boolean OR | Left to right |\n| `if-else` | Conditional expression | Right to left |\n| `:=` | Assignment expression (walrus operator) | Right to left |", "position": 4, "token_count": 214, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-004", "document_id": "operators", "position": 4, "token_count": 214, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-005", "document_id": "operators", "content": "Mojo supports the same operators as Python (plus a few extensions), and they\nhave the same precedence levels. For example, the following arithmetic\nexpression evaluates to 40:\n\n```mojo\n5 + 4 * 3 ** 2 - 1", "position": 5, "token_count": 50, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-005", "document_id": "operators", "position": 5, "token_count": 50, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-006", "document_id": "operators", "content": "```\n\nIt is equivalent to the following parenthesized expression to explicitly control\nthe order of evaluation:\n\n```mojo\n(5 + (4 * (3 ** 2))) - 1\n```\n\nAssociativity defines how operators of the same precedence level are grouped\ninto expressions. The table indicates whether operators of a given level are\nleft- or right-associative. For example, multiplication and division are left\nassociative, so the following expression results in a value of 3:\n\n```mojo\n3 * 4 / 2 / 2\n```\n\nIt is equivalent to the following parenthesized expression to explicitly control\nthe order of evaluation:\n\n```mojo\n((3 * 4) / 2) / 2\n```\n\nWhereas in the following, exponentiation operators are right associative\nresulting in a value of 264,144:\n\n```mojo\n4 ** 3 ** 2\n```\n\nIt is equivalent to the following parenthesized expression to explicitly control\nthe order of evaluation:\n\n```mojo\n4 ** (3 ** 2)", "position": 6, "token_count": 227, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-006", "document_id": "operators", "position": 6, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-007", "document_id": "operators", "content": "```\n\nIt is equivalent to the following parenthesized expression to explicitly control\nthe order of evaluation:\n\n```mojo\n4 ** (3 ** 2)\n```\n\n[note]\nMojo also uses the caret (`^`) as the [*transfer\nsigil*](/mojo/manual/values/ownership#transfer-arguments-var-and-). In\nexpressions where its use might be ambiguous, Mojo treats the character as the\nbitwise XOR operator. For example, `x^+1` is treated as `(x)^(+1)`.", "position": 7, "token_count": 126, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-007", "document_id": "operators", "position": 7, "token_count": 126, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-008", "document_id": "operators", "content": "### Arithmetic and bitwise operators\n\n[Numeric types](/mojo/manual/types#numeric-types) describes the different\nnumeric types provided by the Mojo standard library. The arithmetic and bitwise\noperators have slightly different behavior depending on the types of values\nprovided.", "position": 8, "token_count": 59, "has_code": false, "section_hierarchy": ["Arithmetic and bitwise operators"], "metadata": {"chunk_id": "operators-008", "document_id": "operators", "position": 8, "token_count": 59, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Arithmetic and bitwise operators"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#arithmetic-and-bitwise-operators"}}
{"chunk_id": "operators-009", "document_id": "operators", "content": "#### `Int` and `UInt` values\n\nThe [`Int`](/mojo/stdlib/builtin/int/Int) and\n[`UInt`](/mojo/stdlib/builtin/uint/UInt) types represent signed and unsigned\nintegers of the [word\nsize](https://en.wikipedia.org/wiki/Word_(computer_architecture)) of the CPU,\ntypically 64 bits or 32 bits.\n\nThe `Int` and `UInt` types support all arithmetic operators except matrix\nmultiplication (`@`), as well as all bitwise and shift operators. If both\noperands to a binary operator are `Int` values the result is an `Int`, if both\noperands are `UInt` values the result is a `UInt`, and if one operand is `Int`\nand the other `UInt` the result is an `Int`. The one exception for these types\nis true division, `/`, which always returns a `Float64` type value.", "position": 9, "token_count": 227, "has_code": false, "section_hierarchy": ["`Int` and `UInt` values"], "metadata": {"chunk_id": "operators-009", "document_id": "operators", "position": 9, "token_count": 227, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`Int` and `UInt` values"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#int-and-uint-values"}}
{"chunk_id": "operators-010", "document_id": "operators", "content": "```mojo\nvar a_int: Int = -7\nvar b_int: Int = 4\nsum_int = a_int + b_int # Result is type Int\nprint(\"Int sum:\", sum_int)\n\nvar i_uint: UInt = 9\nvar j_uint: UInt = 8\nsum_uint = i_uint + j_uint # Result is type UInt\nprint(\"UInt sum:\", sum_uint)\n\nsum_mixed = a_int + Int(i_uint) # Result is type Int\nprint(\"Mixed sum:\", sum_mixed)\n\nquotient_int = a_int / b_int # Result is type Float64\nprint(\"Int quotient:\", quotient_int)\nquotient_uint = i_uint / j_uint # Result is type Float64\nprint(\"UInt quotient:\", quotient_uint)", "position": 10, "token_count": 212, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-010", "document_id": "operators", "position": 10, "token_count": 212, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-011", "document_id": "operators", "content": "```\n\n```output\nInt sum: -3\nUInt sum: 17\nMixed sum: 2\nInt quotient: -1.75\nUInt quotient: 1.125\n```", "position": 11, "token_count": 44, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-011", "document_id": "operators", "position": 11, "token_count": 44, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-012", "document_id": "operators", "content": "#### `SIMD` values\n\nThe Mojo standard library defines the [`SIMD`](/mojo/stdlib/builtin/simd/SIMD)\ntype to represent a fixed-size array of values that can fit into a processor's\nregister. This allows you to take advantage of [single instruction, multiple\ndata](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data)\noperations in hardware to efficiently process multiple values in parallel.\n`SIMD` values of a numeric [`DType`](/mojo/stdlib/builtin/dtype/DType) support\nall arithmetic operators except for matrix multiplication (`@`), though the left\nshift (`<<`) and right shift (`>>`) operators support only integral types.\nAdditionally, `SIMD` values of an integral or boolean type support all bitwise\noperators. `SIMD` values apply the operators in an *elementwise* fashion, as\nshown in the following example:", "position": 12, "token_count": 222, "has_code": false, "section_hierarchy": ["`SIMD` values"], "metadata": {"chunk_id": "operators-012", "document_id": "operators", "position": 12, "token_count": 222, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`SIMD` values"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#simd-values"}}
{"chunk_id": "operators-013", "document_id": "operators", "content": "```mojo\nsimd1 = SIMD[DType.int32, 4](2, 3, 4, 5)\nsimd2 = SIMD[DType.int32, 4](-1, 2, -3, 4)\nsimd3 = simd1 * simd2\nprint(simd3)", "position": 13, "token_count": 73, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-013", "document_id": "operators", "position": 13, "token_count": 73, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-014", "document_id": "operators", "content": "```\n\n```output\n[-2, 6, -12, 20]\n```\n\n[`Scalar`](/mojo/stdlib/builtin/simd/) values are simply aliases for\nsingle-element `SIMD` vectors, so `Float16` is just an alias for\n`SIMD[DType.float16, 1]`. Therefore `Scalar` values support the same set of\narithmetic and bitwise operators.\n\n```mojo\nvar f1: Float16 = 2.5\nvar f2: Float16 = -4.0\nvar f3 = f1 * f2 # Implicitly of type Float16\nprint(f3)\n```\n\n```output\n-10.0", "position": 14, "token_count": 155, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-014", "document_id": "operators", "position": 14, "token_count": 155, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-015", "document_id": "operators", "content": "```\n\n```output\n-10.0\n```\n\nWhen using these operators on `SIMD` values, Mojo requires both to have the same\nsize and `DType`, and the result is a `SIMD` of the same size and `DType`. The\noperators do *not* automatically widen lower precision `SIMD` values to higher\nprecision. This means that the `DType` of each value must be the same or else\nthe result is a compilation error.\n\n```mojo\nvar i8: Int8 = 8\nvar f64: Float64 = 64.0\nresult = i8 * f64\n```\n\n```output\nerror: invalid call to '__mul__': failed to infer parameter 'type' of parent struct 'SIMD'\n result = i8 * f64\n ~~~^~~~~", "position": 15, "token_count": 185, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-015", "document_id": "operators", "position": 15, "token_count": 185, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-016", "document_id": "operators", "content": "```\n\nIf you need to perform an arithmetic or bitwise operator on two `SIMD` values of\ndifferent types, you can explicitly convert a value to the desired type either\nby invoking its [`cast()`](/mojo/stdlib/builtin/simd/SIMD#cast) method or by\npassing it as an argument to the constructor of the target type.\n\nFor example, to fix the previous example, add an explicit conversion:\n\n```mojo\nvar i8: Int8 = 8\nvar f64: Float64 = 64.0\nresult = Float64(i8) * f64", "position": 16, "token_count": 132, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-016", "document_id": "operators", "position": 16, "token_count": 132, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-017", "document_id": "operators", "content": "```\n\nHere are some more examples of converting SIMD values using both constructors\nand the `cast()` method:\n\n```mojo\nsimd4 = SIMD[DType.float32, 4](2.2, 3.3, 4.4, 5.5)\nsimd5 = SIMD[DType.int16, 4](-1, 2, -3, 4)\nsimd6 = simd4 * simd5.cast[DType.float32]() # Convert with cast() method\nprint(\"simd6:\", simd6)\nsimd7 = simd5 + SIMD[DType.int16, 4](simd4) # Convert with SIMD constructor\nprint(\"simd7:\", simd7)\n```\n\n```output\nsimd6: [-2.2, 6.6, -13.200001, 22.0]\nsimd7: [1, 5, 1, 9]", "position": 17, "token_count": 220, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-017", "document_id": "operators", "position": 17, "token_count": 220, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-018", "document_id": "operators", "content": "```\n\n```output\nsimd6: [-2.2, 6.6, -13.200001, 22.0]\nsimd7: [1, 5, 1, 9]\n```\n\nOne exception is that the exponentiation operator, `**`, is overloaded so that\nyou can specify an `Int` type exponent. All values in the `SIMD` are\nexponentiated to the same power.\n\n```mojo\nbase_simd = SIMD[DType.float64, 4](1.1, 2.2, 3.3, 4.4)\nvar power: Int = 2\npow_simd = base_simd ** power # Result is SIMD[DType.float64, 4]\nprint(pow_simd)\n```\n\n```output\n[1.2100000000000002, 4.8400000000000007, 10.889999999999999, 19.360000000000003]", "position": 18, "token_count": 231, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-018", "document_id": "operators", "position": 18, "token_count": 231, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-019", "document_id": "operators", "content": "```\n\nThere are three operators related to division:\n\n- `/`, the \"true division\" operator, performs floating point division for `SIMD`\n values with a floating point `DType`. For `SIMD` values with an integral\n `DType`, true division *truncates* the quotient to an integral result.\n\n ```mojo\n num_float16 = SIMD[DType.float16, 4](3.5, -3.5, 3.5, -3.5)\n denom_float16 = SIMD[DType.float16, 4](2.5, 2.5, -2.5, -2.5)\n\n num_int32 = SIMD[DType.int32, 4](5, -6, 7, -8)\n denom_int32 = SIMD[DType.int32, 4](2, 3, -4, -5)", "position": 19, "token_count": 207, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-019", "document_id": "operators", "position": 19, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-020", "document_id": "operators", "content": "# Result is SIMD[DType.float16, 4]\n true_quotient_float16 = num_float16 / denom_float16\n print(\"True float16 division:\", true_quotient_float16)\n\n # Result is SIMD[DType.int32, 4]\n true_quotient_int32 = num_int32 / denom_int32\n print(\"True int32 division:\", true_quotient_int32)", "position": 20, "token_count": 108, "has_code": false, "section_hierarchy": ["Result is SIMD[DType.float16, 4]"], "metadata": {"chunk_id": "operators-020", "document_id": "operators", "position": 20, "token_count": 108, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Result is SIMD[DType.float16, 4]"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#result-is-simddtypefloat16-4"}}
{"chunk_id": "operators-021", "document_id": "operators", "content": "```\n\n ```output\n True float16 division: [1.4003906, -1.4003906, -1.4003906, 1.4003906]\n True int32 division: [2, -2, -1, 1]\n ```\n\n- `//`, the \"floor division\" operator, performs division and *rounds down* the\n result to the nearest integer. The resulting `SIMD` is still the same type as\n the original operands. For example:\n\n ```mojo\n # Result is SIMD[DType.float16, 4]\n var floor_quotient_float16 = num_float16 // denom_float16\n print(\"Floor float16 division:\", floor_quotient_float16)\n\n # Result is SIMD[DType.int32, 4]\n var floor_quotient_int32 = num_int32 // denom_int32\n print(\"Floor int32 division:\", floor_quotient_int32)", "position": 21, "token_count": 225, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-021", "document_id": "operators", "position": 21, "token_count": 225, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-022", "document_id": "operators", "content": "```\n\n ```output\n Floor float16 division: [1.0, -2.0, -2.0, 1.0]\n Floor int32 division: [2, -2, -2, 1]", "position": 22, "token_count": 49, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-022", "document_id": "operators", "position": 22, "token_count": 49, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-023", "document_id": "operators", "content": "```\n\n- `%`, the modulo operator, returns the remainder after dividing the numerator\n by the denominator an integral number of times. The relationship between the\n `//` and `%` operators can be defined as `num == denom * (num // denom) + (num\n % denom)`. For example:\n\n ```mojo\n # Result is SIMD[DType.float16, 4]\n var remainder_float16 = num_float16 % denom_float16\n print(\"Modulo float16:\", remainder_float16)\n\n # Result is SIMD[DType.int32, 4]\n var remainder_int32 = num_int32 % denom_int32\n print(\"Modulo int32:\", remainder_int32)\n\n print()\n\n # Result is SIMD[DType.float16, 4]\n var result_float16 = denom_float16 * floor_quotient_float16 + remainder_float16\n print(\"Result float16:\", result_float16)", "position": 23, "token_count": 233, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-023", "document_id": "operators", "position": 23, "token_count": 233, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-024", "document_id": "operators", "content": "# Result is SIMD[DType.int32, 4]\n var result_int32 = denom_int32 * floor_quotient_int32 + remainder_int32\n print(\"Result int32:\", result_int32)", "position": 24, "token_count": 55, "has_code": false, "section_hierarchy": ["Result is SIMD[DType.int32, 4]"], "metadata": {"chunk_id": "operators-024", "document_id": "operators", "position": 24, "token_count": 55, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Result is SIMD[DType.int32, 4]"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#result-is-simddtypeint32-4"}}
{"chunk_id": "operators-025", "document_id": "operators", "content": "```\n\n ```output\n Modulo float16: [1.0, 1.5, -1.5, -1.0]\n Modulo int32: [1, 0, -1, -3]\n\n Result float16: [3.5, -3.5, 3.5, -3.5]\n Result int32: [5, -6, 7, -8]\n ```", "position": 25, "token_count": 90, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-025", "document_id": "operators", "position": 25, "token_count": 90, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-026", "document_id": "operators", "content": "#### `IntLiteral` and `FloatLiteral` values\n\n[`IntLiteral`](/mojo/stdlib/builtin/int_literal/IntLiteral) and\n[`FloatLiteral`](/mojo/stdlib/builtin/float_literal/FloatLiteral) are\ncompile-time, numeric values. When they are used in a compile-time context, they\nare arbitrary-precision values. When they are used in a run-time context, they\nare materialized as `Int` and `Float64` type values, respectively.\n\nAs an example, the following code causes a compile-time error because the\ncalculated `IntLiteral` value is too large to store in an `Int` variable:\n\n```mojo\nalias big_int = (1 << 65) + 123456789 # IntLiteral\nvar too_big_int: Int = big_int\nprint(\"Result:\", too_big_int)", "position": 26, "token_count": 214, "has_code": true, "section_hierarchy": ["`IntLiteral` and `FloatLiteral` values"], "metadata": {"chunk_id": "operators-026", "document_id": "operators", "position": 26, "token_count": 214, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`IntLiteral` and `FloatLiteral` values"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#intliteral-and-floatliteral-values"}}
{"chunk_id": "operators-027", "document_id": "operators", "content": "```\n\n```output\nnote: integer value 36893488147542560021 requires 67 bits to store, but the destination bit width is only 64 bits wide\n```\n\nHowever in the following example, taking that same `IntLiteral` value, dividing\nby the `IntLiteral` 10 and then assigning the result to an `Int` variable\ncompiles and runs successfully, because the final `IntLiteral` quotient can fit\nin a 64-bit `Int`.\n\n```mojo\nalias big_int = (1 << 65) + 123456789 # IntLiteral\nvar not_too_big_int: Int = big_int // 10\nprint(\"Result:\", not_too_big_int)\n```\n\n```output\nResult: 3689348814754256002", "position": 27, "token_count": 189, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-027", "document_id": "operators", "position": 27, "token_count": 189, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-028", "document_id": "operators", "content": "```\n\n```output\nResult: 3689348814754256002\n```\n\nIn a compile-time context, `IntLiteral` and `FloatLiteral` values support all\narithmetic operators *except* exponentiation (`**`), and `IntLiteral` values\nsupport all bitwise and shift operators. In a run-time context, materialized\n`IntLiteral` values are `Int` values and therefore support the same operators as\n`Int`, and materialized `FloatLiteral` values are `Float64` values and therefore\nsupport the same operators as `Float64`.", "position": 28, "token_count": 134, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-028", "document_id": "operators", "position": 28, "token_count": 134, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-029", "document_id": "operators", "content": "### Comparison operators\n\nMojo supports a standard set of comparison operators: `==`, `!=`, `<`, `<=`,\n`>`, and `>=`. However their behavior depends on the type of values being\ncompared.\n\nThe remainder of this section describes numerical comparison operators. String\ncomparisons are discussed in the [String operators](#string-operators). Several\nother types in the Mojo standard library support various comparison operators,\nin particular the \"equal\" and \"not equal\" comparisons. Consult the\n[API documentation](/mojo/lib) for a type to determine whether any comparison\noperators are supported.", "position": 29, "token_count": 135, "has_code": false, "section_hierarchy": ["Comparison operators"], "metadata": {"chunk_id": "operators-029", "document_id": "operators", "position": 29, "token_count": 135, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Comparison operators"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#comparison-operators"}}
{"chunk_id": "operators-030", "document_id": "operators", "content": "#### `Bool`-returning comparisons\n\nThese comparisons return a single `Bool` value:\n\n- `Int`, `UInt`, `IntLiteral`, and any type that can be implicitly converted to\n `Int` or `UInt` do standard numerical comparison with a `Bool` result.\n- Equality operators (`==` and `!=`) with multi-element `SIMD` values return a\n `Bool` result using reduction semantics. The comparison is `True` only if it's\n true for all corresponding elements. For example:\n\n ```mojo\n simd8 = SIMD[DType.int32, 4](1, 2, 3, 2)\n simd9 = SIMD[DType.int32, 4](1, 2, 4, 2)\n print(\"simd8 == simd9:\", simd8 == simd9) # False (element 2 differs)\n print(\"simd8 != simd9:\", simd8 != simd9) # True (not all elements equal)", "position": 30, "token_count": 237, "has_code": true, "section_hierarchy": ["`Bool`-returning comparisons"], "metadata": {"chunk_id": "operators-030", "document_id": "operators", "position": 30, "token_count": 237, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`Bool`-returning comparisons"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#bool-returning-comparisons"}}
{"chunk_id": "operators-031", "document_id": "operators", "content": "```\n\n ```output\n simd8 == simd9: False\n simd8 != simd9: True\n ```\n\n- Inequality operators (`<`, `<=`, `>`, `>=`) with multi-element `SIMD` values\n are not supported. These operators only work with scalar (single-element)\n `SIMD` values.\n- `Scalar` values are simply aliases for single-element `SIMD` vectors and\n support all comparison operators with `Bool` results:\n\n ```mojo\n var float1: Float16 = 12.345 # SIMD[DType.float16, 1]\n var float2: Float32 = 0.5 # SIMD[DType.float32, 1]\n result = Float32(float1) > float2 # Result is Bool\n print(result)\n ```\n\n ```output\n True\n ```", "position": 31, "token_count": 195, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-031", "document_id": "operators", "position": 31, "token_count": 195, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-032", "document_id": "operators", "content": "#### Elementwise comparisons\n\nFor elementwise comparisons that return a `SIMD[DType.bool]` result, use the\ncomparison methods: `eq()`, `ne()`, `lt()`, `le()`, `gt()`, and `ge()`. These\nmethods work with both `SIMD`-to-`SIMD` and `SIMD`-to-scalar comparisons. Here\nare examples showing all six elementwise comparison methods:\n\n ```mojo\n simd8 = SIMD[DType.int32, 4](1, 2, 3, 2)\n simd9 = SIMD[DType.int32, 4](1, 2, 4, 2)", "position": 32, "token_count": 163, "has_code": true, "section_hierarchy": ["Elementwise comparisons"], "metadata": {"chunk_id": "operators-032", "document_id": "operators", "position": 32, "token_count": 163, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Elementwise comparisons"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#elementwise-comparisons"}}
{"chunk_id": "operators-033", "document_id": "operators", "content": "print(\"simd8.eq(simd9):\", simd8.eq(simd9)) # Equal\n print(\"simd8.ne(simd9):\", simd8.ne(simd9)) # Not equal\n print(\"simd8.lt(simd9):\", simd8.lt(simd9)) # Less than\n print(\"simd8.le(simd9):\", simd8.le(simd9)) # Less than or equal\n print(\"simd8.gt(simd9):\", simd8.gt(simd9)) # Greater than\n print(\"simd8.ge(simd9):\", simd8.ge(simd9)) # Greater than or equal", "position": 33, "token_count": 187, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-033", "document_id": "operators", "position": 33, "token_count": 187, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-034", "document_id": "operators", "content": "```\n\n ```output\n simd8.eq(simd9): [True, True, False, True]\n simd8.ne(simd9): [False, False, True, False]\n simd8.lt(simd9): [False, False, True, False]\n simd8.le(simd9): [True, True, True, True]\n simd8.gt(simd9): [False, False, False, False]\n simd8.ge(simd9): [True, True, False, True]", "position": 34, "token_count": 130, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-034", "document_id": "operators", "position": 34, "token_count": 130, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-035", "document_id": "operators", "content": "```\n\n You can also use these methods for `SIMD`-to-scalar comparisons:\n\n ```mojo\n simd4 = SIMD[DType.int16, 4](-1, 2, -3, 4)\n simd5 = simd4.gt(2) # SIMD[DType.bool, 4]\n print(\"simd4.gt(2):\", simd5)\n\n simd6 = SIMD[DType.float32, 4](1.1, -2.2, 3.3, -4.4)\n simd7 = simd6.gt(0.5) # SIMD[DType.bool, 4]\n print(\"simd6.gt(0.5):\", simd7)\n ```\n\n ```output\n simd4.gt(2): [False, False, False, True]\n simd6.gt(0.5): [True, False, True, False]\n ```\n\nUse elementwise comparison methods when you need to compare each element\nindividually and work with the resulting boolean mask for further processing.", "position": 35, "token_count": 248, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-035", "document_id": "operators", "position": 35, "token_count": 248, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-036", "document_id": "operators", "content": "### String operators\n\nAs discussed in [Strings](/mojo/manual/types#strings), the\n[`String`](/mojo/stdlib/collections/string/string/String) type represents a\nmutable string value. In contrast, the\n[`StringLiteral`](/mojo/stdlib/builtin/string_literal/StringLiteral) type\nrepresents a literal string that is embedded into your compiled program, but\nat run-time it materializes to a `String`, allowing you to mutate it:\n\n```mojo\nmessage = \"Hello\" # type = String\nalias name = \" Pat\" # type = StringLiteral\ngreeting = \" good Day!\" # type = String", "position": 36, "token_count": 154, "has_code": true, "section_hierarchy": ["String operators"], "metadata": {"chunk_id": "operators-036", "document_id": "operators", "position": 36, "token_count": 154, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["String operators"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#string-operators"}}
{"chunk_id": "operators-037", "document_id": "operators", "content": "# Mutate the original `message` String\nmessage += name\nmessage += greeting\nprint(message)\n```\n\n```output\nHello Pat good day!\n```\n\nThis means that `StringLiteral` values can be intermixed with `String` values in\nany runtime expression without having to convert between types.\n\n#### String concatenation\n\nThe `+` operator performs string concatenation. The `StringLiteral` type\nsupports compile-time string concatenation.\n\n```mojo\nalias last_name = \"Curie\"\n\n# Compile-time StringLiteral alias\nalias marie = \"Marie \" + last_name\nprint(marie)", "position": 37, "token_count": 141, "has_code": true, "section_hierarchy": ["Compile-time StringLiteral alias"], "metadata": {"chunk_id": "operators-037", "document_id": "operators", "position": 37, "token_count": 141, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Compile-time StringLiteral alias"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#compile-time-stringliteral-alias"}}
{"chunk_id": "operators-038", "document_id": "operators", "content": "# Compile-time concatenation before materializing to a run-time `String`\npierre = \"Pierre \" + last_name\nprint(pierre)\n```\n\n[tip] When concatenating multiple values together to form a `String`, using the\nmulti-argument `String()` constructor is more performant than using multiple\n`+` concatenation operators and can improve code readability. For example,\ninstead of writing this:\n\n```mojo\nresult = \"The point at (\" + String(x) + \", \" + String(y) + \")\"\n```\n\nyou can write:\n\n```mojo\nresult = String(\"The point at (\", x, \", \", y, \")\")\n```\n\nThis will write the underlying data using a stack buffer, and will only allocate\nand memcpy to the heap once.", "position": 38, "token_count": 189, "has_code": true, "section_hierarchy": ["Compile-time concatenation before materializing to a run-time `String`"], "metadata": {"chunk_id": "operators-038", "document_id": "operators", "position": 38, "token_count": 189, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Compile-time concatenation before materializing to a run-time `String`"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#compile-time-concatenation-before-materializing-to-a-run-time-string"}}
{"chunk_id": "operators-039", "document_id": "operators", "content": "#### String replication\n\nThe `*` operator replicates a `String` a specified number of times. For example:\n\n```mojo\nvar str1: String = \"la\"\nstr2 = str1 * 5\nprint(str2)\n```\n\n```output\nlalalalala\n```\n\n`StringLiteral` supports the `*` operator for both compile-time and run-time\nstring replication. The following examples perform compile-time string\nreplication resulting in `StringLiteral` values:\n\n```mojo\nalias divider1 = \"=\" * 40\nalias symbol = \"#\"\nalias divider2 = symbol * 40", "position": 39, "token_count": 142, "has_code": true, "section_hierarchy": ["String replication"], "metadata": {"chunk_id": "operators-039", "document_id": "operators", "position": 39, "token_count": 142, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["String replication"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#string-replication"}}
{"chunk_id": "operators-040", "document_id": "operators", "content": "# You must define the following function using `fn` because an alias", "position": 40, "token_count": 17, "has_code": false, "section_hierarchy": ["You must define the following function using `fn` because an alias"], "metadata": {"chunk_id": "operators-040", "document_id": "operators", "position": 40, "token_count": 17, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["You must define the following function using `fn` because an alias"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#you-must-define-the-following-function-using-fn-because-an-alias"}}
{"chunk_id": "operators-041", "document_id": "operators", "content": "# initializer cannot call a function that can potentially raise an error.\nfn generate_divider(char: String, repeat: Int) -> String:\n return char * repeat\n\nalias divider3 = generate_divider(\"~\", 40) # Evaluated at compile-time\n\nprint(divider1)\nprint(divider2)\nprint(divider3)\n```\n\n```output\n========================================\n########################################\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "position": 41, "token_count": 207, "has_code": true, "section_hierarchy": ["initializer cannot call a function that can potentially raise an error."], "metadata": {"chunk_id": "operators-041", "document_id": "operators", "position": 41, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["initializer cannot call a function that can potentially raise an error."], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#initializer-cannot-call-a-function-that-can-potentially-raise-an-error"}}
{"chunk_id": "operators-042", "document_id": "operators", "content": "```\n\nIn contrast, the following examples perform run-time string replication\nresulting in `String` values:\n\n```mojo\nrepeat = 40\ndiv1 = \"^\" * repeat\nprint(div1)\nprint(\"_\" * repeat)\n```\n\n```output\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n________________________________________\n```", "position": 42, "token_count": 144, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-042", "document_id": "operators", "position": 42, "token_count": 144, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-043", "document_id": "operators", "content": "#### String comparison\n\n`String` and `StringLiteral` values can be compared using standard\nlexicographical ordering, producing a `Bool`. For example, \"Zebra\" is treated as\nless than \"ant\" because upper case letters occur before lower case letters in\nthe character encoding.\n\n```mojo\nvar animal: String = \"bird\"\n\nis_cat_eq = \"cat\" == animal\nprint('Is \"cat\" equal to \"{}\"?'.format(animal), is_cat_eq)\n\nis_cat_ne = \"cat\" != animal\nprint('Is \"cat\" not equal to \"{}\"?'.format(animal), is_cat_ne)\n\nis_bird_eq = \"bird\" == animal\nprint('Is \"bird\" equal to \"{}\"?'.format(animal), is_bird_eq)", "position": 43, "token_count": 198, "has_code": true, "section_hierarchy": ["String comparison"], "metadata": {"chunk_id": "operators-043", "document_id": "operators", "position": 43, "token_count": 198, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["String comparison"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#string-comparison"}}
{"chunk_id": "operators-044", "document_id": "operators", "content": "is_bird_eq = \"bird\" == animal\nprint('Is \"bird\" equal to \"{}\"?'.format(animal), is_bird_eq)\n\nis_cat_gt = \"CAT\" > animal\nprint('Is \"CAT\" greater than \"{}\"?'.format(animal), is_cat_gt)\n\nis_ge_cat = animal >= \"CAT\"\nprint('Is \"{}\" greater than or equal to \"CAT\"?'.format(animal), is_ge_cat)", "position": 44, "token_count": 123, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-044", "document_id": "operators", "position": 44, "token_count": 123, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-045", "document_id": "operators", "content": "```\n\n```output\nIs \"cat\" equal to \"bird\"? False\nIs \"cat\" not equal to \"bird\"? True\nIs \"bird\" equal to \"bird\"? True\nIs \"CAT\" greater than \"bird\"? False\nIs \"bird\" greater than or equal to \"CAT\"? True\n```", "position": 45, "token_count": 71, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-045", "document_id": "operators", "position": 45, "token_count": 71, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-046", "document_id": "operators", "content": "#### Substring testing\n\n`String`, `StringLiteral`, and `StringSlice` support using the `in` operator to\nproduce a `Bool` result indicating whether a given substring appears within\nanother string. The operator is overloaded so that you can use any combination\nof `String` and `StringLiteral` for both the substring and the string to test.\n\n```mojo\nvar food: String = \"peanut butter\"\n\nif \"nut\" in food:\n print(\"It contains a nut\")\nelse:\n print(\"It doesn't contain a nut\")\n```\n\n```output\nIt contains a nut\n```", "position": 46, "token_count": 143, "has_code": true, "section_hierarchy": ["Substring testing"], "metadata": {"chunk_id": "operators-046", "document_id": "operators", "position": 46, "token_count": 143, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Substring testing"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#substring-testing"}}
{"chunk_id": "operators-047", "document_id": "operators", "content": "#### String indexing and slicing\n\n`String`, `StringLiteral`, and `StringSlice` allow you to use indexing to return\na single character. Character positions are identified with a zero-based index\nstarting from the first character. You can also specify a negative index to\ncount backwards from the end of the string, with the last character identified\nby index -1. Specifying an index beyond the bounds of the string results in a\nrun-time error.\n\n```mojo\nvar alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" # String type value\nprint(alphabet[0], alphabet[-1])", "position": 47, "token_count": 140, "has_code": true, "section_hierarchy": ["String indexing and slicing"], "metadata": {"chunk_id": "operators-047", "document_id": "operators", "position": 47, "token_count": 140, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["String indexing and slicing"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#string-indexing-and-slicing"}}
{"chunk_id": "operators-048", "document_id": "operators", "content": "# The following would produce a run-time error", "position": 48, "token_count": 12, "has_code": false, "section_hierarchy": ["The following would produce a run-time error"], "metadata": {"chunk_id": "operators-048", "document_id": "operators", "position": 48, "token_count": 12, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["The following would produce a run-time error"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#the-following-would-produce-a-run-time-error"}}
{"chunk_id": "operators-049", "document_id": "operators", "content": "# print(alphabet[45])\n```\n\n```output\nA Z\n```\n\nThe `String` and `StringSlice` types—but *not* the `StringLiteral` type—also\nsupport slices to return a substring from the original `String`. Providing a\nslice in the form `[start:end]` returns a substring starting with the character\nindex specified by `start` and continuing up to but not including the character\nat index `end`. You can use positive or negative indexing for both the start and\nend values. Omitting `start` is the same as specifying `0`, and omitting `end`\nis the same as specifying the length of the string.\n\n```mojo\nvar alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" # String type value\nprint(alphabet[1:4]) # The 2nd through 4th characters\nprint(alphabet[:6]) # The first 6 characters\nprint(alphabet[-6:]) # The last 6 characters\n```\n\n```output\nBCD\nABCDEF\nUVWXYZ", "position": 49, "token_count": 241, "has_code": true, "section_hierarchy": ["print(alphabet[45])"], "metadata": {"chunk_id": "operators-049", "document_id": "operators", "position": 49, "token_count": 241, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["print(alphabet[45])"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#printalphabet45"}}
{"chunk_id": "operators-050", "document_id": "operators", "content": "```\n\n```output\nBCD\nABCDEF\nUVWXYZ\n```\n\nYou can also specify a slice with a `step` value, as in `[start:end:step]`\nindicating the increment between subsequent indices of the slide. (This is also\nsometimes referred to as a \"stride.\") If you provide a negative value for\n`step`, characters are selected in reverse order starting with `start` but then\nwith *decreasing* index values up to but not including `end`.\n\n```mojo\nprint(alphabet[1:6:2]) # The 2nd, 4th, and 6th characters\nprint(alphabet[-1:-4:-1]) # The last 3 characters in reverse order\nprint(alphabet[::-1]) # The entire string reversed\n```\n\n```output\nBDF\nZYX\nZYXWVUTSRQPONMLKJIHGFEDCBA\n```", "position": 50, "token_count": 200, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-050", "document_id": "operators", "position": 50, "token_count": 200, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-051", "document_id": "operators", "content": "### In-place assignment operators\n\nMutable types that support binary arithmetic, bitwise, and shift operators\ntypically support equivalent in-place assignment operators. That means that for\na type that supports the `+` operator, the following two statements are\nessentially equivalent:\n\n```mojo\na = a + b\na += b\n```\n\nHowever there is a subtle difference between the two. In the first example, the\nexpression `a + b` produces a new value, which is then assigned to `a`. In\ncontrast, the second example does an in-place modification of the value\ncurrently assigned to `a`. For register-passable types, the compiled results\nmight be equivalent at run-time. But for a memory-only type, the first example\nallocates storage for the result of `a + b` and then assigns the value to the\nvariable, whereas the second example can do an in-place modification of the\nexisting value.\n\n[note]\nA type must explicitly implement in-place assignment methods, so you might\nencounter some types where in-place equivalents are not supported.", "position": 51, "token_count": 226, "has_code": true, "section_hierarchy": ["In-place assignment operators"], "metadata": {"chunk_id": "operators-051", "document_id": "operators", "position": 51, "token_count": 226, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["In-place assignment operators"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#in-place-assignment-operators"}}
{"chunk_id": "operators-052", "document_id": "operators", "content": "### Assignment expressions\n\nThe \"walrus\" operator, `:=`, allows you to assign a value to a variable within\nan expression. The value provided is both assigned to the variable and becomes\nthe result of the expression. This often can simplify conditional or looping\nlogic. For example, consider the following prompting loop:\n\n```mojo\nwhile True:\n name = input(\"Enter a name or 'quit' to exit: \")\n if name == \"quit\":\n break\n print(\"Hello,\", name)\n```\n\n```output\nEnter a name or 'quit' to exit: Coco\nHello, Coco\nEnter a name or 'quit' to exit: Vivienne\nHello, Vivienne\nEnter a name or 'quit' to exit: quit\n```\n\nUsing the walrus operator, you can implement the same behavior like this:\n\n```mojo\nwhile (name := input(\"Enter a name or 'quit' to exit: \")) != \"quit\":\n print(\"Hello,\", name)", "position": 52, "token_count": 219, "has_code": true, "section_hierarchy": ["Assignment expressions"], "metadata": {"chunk_id": "operators-052", "document_id": "operators", "position": 52, "token_count": 219, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Assignment expressions"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#assignment-expressions"}}
{"chunk_id": "operators-053", "document_id": "operators", "content": "```\n\n```output\nEnter a name or 'quit' to exit: Donna\nHello, Donna\nEnter a name or 'quit' to exit: Vera\nHello, Vera\nEnter a name or 'quit' to exit: quit\n```", "position": 53, "token_count": 51, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-053", "document_id": "operators", "position": 53, "token_count": 51, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-054", "document_id": "operators", "content": "### Type merging\n\nWhen an expression involves values of different types,\nMojo needs to statically determine the return type of the expression. This\nprocess is called *type merging*. By default, Mojo determines type merging\nbased on implicit conversions. Individual structs can also define custom type\nmerging behavior.\n\nThe following code demonstrates type merging based on implicit conversions:\n\n```mojo\nlist = [0.5, 1, 2]\nfor value in list:\n print(value)\n```\n\n```output\n0.5\n1.0\n2.0\n```\n\nHere, the list literal includes both float and integer literals, which\nmaterialize as `Float64` and `Int`, respectively. Since `Int` can be\nimplicitly converted to `Float64`, the result is a `List[Float64]`.\n\nHere's an example of where type merging fails:\n\n```mojo\na: Int = 0\nb: String = \"Hello\"\nc = a if a > 0 else b # Error: value of type 'Int' is not compatible with\n # value of type 'String'mojo", "position": 54, "token_count": 228, "has_code": true, "section_hierarchy": ["Type merging"], "metadata": {"chunk_id": "operators-054", "document_id": "operators", "position": 54, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Type merging"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#type-merging"}}
{"chunk_id": "operators-055", "document_id": "operators", "content": "```\n\nIn this case, `Int` can't be implicitly converted to a `String`, and\n`String` can't be implicitly converted to an `Int`, so type merging fails. This\nis the correct result: there's no way for Mojo to know what type you want `c` to\ntake. You can fix this by adding an explicit conversion:\n\n```mojo\nc = String(a) if a > 0 else b\n```\n\nIndividual structs can define custom type merging logic by defining a\n`__merge_with__()` dunder method. For example:\n\n```mojo\n@fieldwise_init\nstruct MyType(Movable, Copyable):\n var val: Int\n\n def __bool__(self) -> Bool:\n return self.val > 0\n\n def __merge_with__[other_type: type_of(Int)](self) -> Int:\n return Int(self.val)\n\ndef main():\n i = 0\n m = MyType(9)\n print(i if i > 0 else m) # prints \"9\"", "position": 55, "token_count": 244, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-055", "document_id": "operators", "position": 55, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-056", "document_id": "operators", "content": "```\n\nIf either type in the expression defines a custom `__merge_with__()` dunder\nfor merging with the other type, this type takes precedence over any implicit\nconversions. (Note that the result type doesn't have to be either of the input\ntypes, it could be a third type.)\n\nA type can declare multiple `__merge_with__()` overrides for different types.\n\nAt a high level, the logic for merging two types goes like this:", "position": 56, "token_count": 107, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-056", "document_id": "operators", "position": 56, "token_count": 107, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-057", "document_id": "operators", "content": "A type can declare multiple `__merge_with__()` overrides for different types.\n\nAt a high level, the logic for merging two types goes like this:\n\n- Does either type define a `__merge_with__()` method for the other type? If so,\n the returned value determines the target type.\n - If **both** types define a `__merge_with__()` method for the other type,\n the two methods must both return the same type, or the conversion fails.\n - Both types must be implicitly convertible to the target type (a type is\n always implicitly convertible to itself).\n- Is either type implicitly convertible to the other type?\n - If only one type is implicitly convertible to the other type, convert it.\n - If both types are convertible to the other type, the conversion is\n ambiguous, and it fails.", "position": 57, "token_count": 189, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-057", "document_id": "operators", "position": 57, "token_count": 189, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-058", "document_id": "operators", "content": "For more background on type merging and the `__merge_with__()` dunder, see the\nproposal,\n[Customizable Type Merging in Mojo](https://github.com/modular/modular/blob/main/mojo/proposals/custom-type-merging.md).", "position": 58, "token_count": 71, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-058", "document_id": "operators", "position": 58, "token_count": 71, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-059", "document_id": "operators", "content": "## Implement operators for custom types\n\nWhen you create a custom struct, Mojo allows you to define the behavior of many\nof the built-in operators for that type by implementing special *dunder* (double\nunderscore) methods. This section lists the dunder methods associated with the\noperators and briefly describes the requirements for implementing them.\n\n[note]\nCurrently, Mojo doesn't support defining arbitrary custom operators (for\nexample, `-^-`). You can define behaviors for only the operators listed in the\nfollowing subsections.", "position": 59, "token_count": 112, "has_code": false, "section_hierarchy": ["Implement operators for custom types"], "metadata": {"chunk_id": "operators-059", "document_id": "operators", "position": 59, "token_count": 112, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Implement operators for custom types"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-operators-for-custom-types"}}
{"chunk_id": "operators-060", "document_id": "operators", "content": "### Unary operator dunder methods\n\nA unary operator invokes an associated dunder method on the value to which it\napplies. The supported unary operators and their corresponding methods are shown\nin the table below.\n\n| **Operator** | **Dunder method** |\n| --------------- | ----------------- |\n| `+` positive | `__pos__()` |\n| `-` negative | `__neg__()` |\n| `~` bitwise NOT | `__invert__()` |\n\nFor each of these methods that you decide to implement, you should return either\nthe original value if unchanged, or a new value representing the result of the\noperator. For example, you could implement the `-` negative operator for a\n`MyInt` struct like this:\n\n```mojo\n@fieldwise_init\nstruct MyInt:\n var value: Int\n\n def __neg__(self) -> Self:\n return Self(-self.value)\n```", "position": 60, "token_count": 251, "has_code": true, "section_hierarchy": ["Unary operator dunder methods"], "metadata": {"chunk_id": "operators-060", "document_id": "operators", "position": 60, "token_count": 251, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Unary operator dunder methods"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#unary-operator-dunder-methods"}}
{"chunk_id": "operators-061", "document_id": "operators", "content": "### Binary arithmetic, shift, and bitwise operator dunder methods\n\nWhen you have a binary expression like `a + b`, there are two possible dunder\nmethods that could be invoked.\n\nMojo first determines whether the left-hand side value (`a` in this example) has\na \"normal\" version of the `+` operator's dunder method defined that accepts a\nvalue of the right-hand side's type. If so, it then invokes that method on the\nleft-hand side value and passes the right-hand side value as an argument.\n\nIf Mojo doesn't find a matching \"normal\" dunder method on the left-hand side\nvalue, it then checks whether the right-hand side value has a \"reflected\"\n(sometimes referred to as \"reversed\") version of the `+` operator's dunder\nmethod defined that accepts a value of the left-hand side's type. If so, it then\ninvokes that method on the right-hand side value and passes the left-hand side\nvalue as an argument.", "position": 61, "token_count": 223, "has_code": false, "section_hierarchy": ["Binary arithmetic, shift, and bitwise operator dunder methods"], "metadata": {"chunk_id": "operators-061", "document_id": "operators", "position": 61, "token_count": 223, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Binary arithmetic, shift, and bitwise operator dunder methods"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#binary-arithmetic-shift-and-bitwise-operator-dunder-methods"}}
{"chunk_id": "operators-062", "document_id": "operators", "content": "For both the normal and the reflected versions, the dunder method should return\na new value representing the result of the operator.\n\nAdditionally, there are dunder methods corresponding to the in-place assignment\nversions of the operators. These methods receive the right-hand side value as an\nargument and the methods should modify the existing left-hand side value to\nreflect the result of the operator.\n\nThe table below lists the various binary arithmetic, shift, and bitwise\noperators and their corresponding normal, reflected, and in-place dunder\nmethods.", "position": 62, "token_count": 108, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-062", "document_id": "operators", "position": 62, "token_count": 108, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-063", "document_id": "operators", "content": "| **Operator** | **Normal** | **Reflected** | **In-place** |\n| ------------ | ---------- | ------------- | ------------ |\n| `+` addition | `__add__()` | `__radd__()` | `__iadd__()` |\n| `-` subtraction | `__sub__()` | `__rsub__()` | `__isub__()` |\n| `*` multiplication | `__mul__()` | `__rmul__()` | `__imul__()` |", "position": 63, "token_count": 198, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-063", "document_id": "operators", "position": 63, "token_count": 198, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-064", "document_id": "operators", "content": "| `*` multiplication | `__mul__()` | `__rmul__()` | `__imul__()` |\n| `/` division | `__truediv__()` | `__rtruediv__()` | `__itruediv__()` |\n| `//` floor division | `__floordiv__()` | `__rfloordiv__()` | `__ifloordiv__()` |\n| `%` modulus/remainder | `__mod__()` | `__rmod__()` | `__imod__()` |\n| `**` exponentiation | `__pow__()` | `__rpow__()` | `__ipow__()` |", "position": 64, "token_count": 212, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-064", "document_id": "operators", "position": 64, "token_count": 212, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-065", "document_id": "operators", "content": "| `**` exponentiation | `__pow__()` | `__rpow__()` | `__ipow__()` |\n| `@` matrix multiplication | `__matmul__()` | `__rmatmul__()` | `__imatmul__()` |\n| `<<` left shift | `__lshift__()` | `__rlshift__()` | `__ilshift__()` |\n| `>>` right shift | `__rshift__()` | `__rrshift__()` | `__irshift__()` |\n| `&` bitwise AND | `__and__()` | `__rand__()` | `__iand__()` |", "position": 65, "token_count": 217, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-065", "document_id": "operators", "position": 65, "token_count": 217, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-066", "document_id": "operators", "content": "| `&` bitwise AND | `__and__()` | `__rand__()` | `__iand__()` |\n| `\\|` bitwise OR | `__or__()` | `__ror__()` | `__ior__()` |\n| `^` bitwise XOR | `__xor__()` | `__rxor__()` | `__ixor__()` |", "position": 66, "token_count": 125, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-066", "document_id": "operators", "position": 66, "token_count": 125, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-067", "document_id": "operators", "content": "As an example, consider implementing support for all of the `+` operator dunder\nmethods for a custom `MyInt` struct. This shows supporting adding two `MyInt`\ninstances as well as adding a `MyInt` and an `Int`. We can support the case of\nhaving the `Int` as the right-hand side argument by overloaded the definition of\n`__add__()`. But to support the case of having the `Int` as the left-hand side\nargument, we need to implement an `__radd__()` method, because the built-in\n`Int` type doesn't have an `__add__()` method that supports our custom `MyInt`\ntype.\n\n```mojo\n@fieldwise_init\nstruct MyInt:\n var value: Int\n\n def __add__(self, rhs: MyInt) -> Self:\n return MyInt(self.value + rhs.value)\n\n def __add__(self, rhs: Int) -> Self:\n return MyInt(self.value + rhs)", "position": 67, "token_count": 241, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-067", "document_id": "operators", "position": 67, "token_count": 241, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-068", "document_id": "operators", "content": "def __add__(self, rhs: Int) -> Self:\n return MyInt(self.value + rhs)\n\n def __radd__(self, lhs: Int) -> Self:\n return MyInt(self.value + lhs)\n\n def __iadd__(mut self, rhs: MyInt) -> None:\n self.value += rhs.value\n\n def __iadd__(mut self, rhs: Int) -> None:\n self.value += rhs", "position": 68, "token_count": 120, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-068", "document_id": "operators", "position": 68, "token_count": 120, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-069", "document_id": "operators", "content": "```", "position": 69, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-069", "document_id": "operators", "position": 69, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-070", "document_id": "operators", "content": "### Comparison operator dunder methods\n\nWhen you have a comparison expression like `a < b`, Mojo invokes as associated\ndunder method on the left-hand side value and passes the right-hand side value\nas an argument. Mojo doesn't support \"reflected\" versions of these dunder\nmethods because you should only compare values of the same type. The comparison\ndunder methods must return a `Bool` result representing the result of the\ncomparison.", "position": 70, "token_count": 96, "has_code": false, "section_hierarchy": ["Comparison operator dunder methods"], "metadata": {"chunk_id": "operators-070", "document_id": "operators", "position": 70, "token_count": 96, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Comparison operator dunder methods"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#comparison-operator-dunder-methods"}}
{"chunk_id": "operators-071", "document_id": "operators", "content": "There are two traits associated with the comparison dunder methods. A type that\nimplements the [`Comparable`](/mojo/stdlib/builtin/comparable/Comparable) trait\ndefines all of the comparison methods, and authors are required to implement at\nleast the \"less-than\" and \"equal\" methods, since the trait provides defaults\nfor the rest. However, some types don't have a natural ordering (for example,\ncomplex numbers). For those types you can decide to implement the\n[`Equatable`](/mojo/stdlib/builtin/equality_comparable/Equatable)\ntrait, which defines only the \"equal\" and \"not equal\" comparison methods, with\n\"equal\" being required to implement by conforming structs.\n\nThe supported comparison operators and their corresponding methods are shown in\nthe table below.", "position": 71, "token_count": 178, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-071", "document_id": "operators", "position": 71, "token_count": 178, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-072", "document_id": "operators", "content": "The supported comparison operators and their corresponding methods are shown in\nthe table below.\n\n| **Operator** | **Dunder method** |\n| ------------ | ----------------- |\n| `==` equal | `__eq__()` |\n| `!=` not equal | `__ne__()` |\n| `<` less than | `__lt__()` |\n| `<=` less than or equal | `__le__()` |\n| `>` greater than | `__gt__()` |\n| `>=` greater than or equal | `__ge__()` |", "position": 72, "token_count": 174, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-072", "document_id": "operators", "position": 72, "token_count": 174, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-073", "document_id": "operators", "content": "[note]\nThe `Comparable` and `Equatable` traits don't allow the comparison\ndunder methods to raise errors. Because using `def` to define a method implies\nthat it can raise an error, you must use `fn` to implement the comparison\nmethods declared by these traits. See [Functions](/mojo/manual/functions) for\nmore information on the differences between defining functions with `def` and\n`fn`.\n\nAs an example, consider implementing support for all of the comparison operator\ndunder methods for a custom `MyInt` struct by relying on the default\nimplementations provided by the `Comparable` (and transitively the\n`Equatable`) traits.\n\n```mojo\n@fieldwise_init\nstruct MyInt(Comparable):\n var value: Int\n\n fn __eq__(self, rhs: MyInt) -> Bool:\n return self.value == rhs.value\n\n fn __lt__(self, rhs: MyInt) -> Bool:\n return self.value < rhs.value", "position": 73, "token_count": 230, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-073", "document_id": "operators", "position": 73, "token_count": 230, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-074", "document_id": "operators", "content": "fn __lt__(self, rhs: MyInt) -> Bool:\n return self.value < rhs.value\n\n # `__ne__`, `__le__`, `__gt__`, and `__ge__` have default implementations.", "position": 74, "token_count": 69, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-074", "document_id": "operators", "position": 74, "token_count": 69, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-075", "document_id": "operators", "content": "```", "position": 75, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-075", "document_id": "operators", "position": 75, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-076", "document_id": "operators", "content": "### Membership operator dunder methods\n\nThe `in` and `not in` operators depend on a type implementing the\n`__contains__()` dunder method. Typically only collection types (such as `List`,\n`Dict`, and `Set`) implement this method. It should accept the right-hand side\nvalue as an argument and return a `Bool` indicating whether the value is present\nin the collection or not.", "position": 76, "token_count": 95, "has_code": false, "section_hierarchy": ["Membership operator dunder methods"], "metadata": {"chunk_id": "operators-076", "document_id": "operators", "position": 76, "token_count": 95, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Membership operator dunder methods"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#membership-operator-dunder-methods"}}
{"chunk_id": "operators-077", "document_id": "operators", "content": "### Subscript and slicing dunder methods\n\nSubscripting and slicing typically apply only to sequential collection types,\nlike `List` and `String`. Subscripting references a single element of a\ncollection or a dimension of a multi-dimensional container, whereas slicing\nrefers to a range of values. A type supports both subscripting and slicing by\nimplementing the `__getitem__()` method for retrieving values and the\n`__setitem__()` method for setting values.", "position": 77, "token_count": 110, "has_code": false, "section_hierarchy": ["Subscript and slicing dunder methods"], "metadata": {"chunk_id": "operators-077", "document_id": "operators", "position": 77, "token_count": 110, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Subscript and slicing dunder methods"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#subscript-and-slicing-dunder-methods"}}
{"chunk_id": "operators-078", "document_id": "operators", "content": "#### Subscripting\n\nIn the simple case of a one-dimensional sequence, the `__getitem__()` and\n`__setitem__()` methods should have signatures similar to this:\n\n```mojo\nstruct MySeq[type: Copyable & Movable]:\n fn __getitem__(self, idx: Int) -> type:\n # Return element at the given index\n ...\n fn __setitem__(mut self, idx: Int, value: type):\n # Assign the element at the given index the provided value", "position": 78, "token_count": 138, "has_code": true, "section_hierarchy": ["Subscripting"], "metadata": {"chunk_id": "operators-078", "document_id": "operators", "position": 78, "token_count": 138, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Subscripting"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#subscripting"}}
{"chunk_id": "operators-079", "document_id": "operators", "content": "```\n\nIt's also possible to support multi-dimensional collections, in which case you\ncan implement both `__getitem__()` and `__setitem__()` methods to accept\nmultiple index arguments—or even variadic index arguments for\narbitrary—dimension collections.\n\n```mojo\nstruct MySeq[type: Copyable & Movable]:\n # 2-dimension support\n fn __getitem__(self, x_idx: Int, y_idx: Int) -> type:\n ...\n # Arbitrary-dimension support\n fn __getitem__(self, *indices: Int) -> type:\n ...\n```", "position": 79, "token_count": 157, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-079", "document_id": "operators", "position": 79, "token_count": 157, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-080", "document_id": "operators", "content": "#### Slicing\n\nYou provide slicing support for a collection type also by implementing\n`__getitem__()` and `__setitem__()` methods. But for slicing, instead of\naccepting an `Int` index (or indices, in the case of a multi-dimensional\ncollection) you implement to methods to accept a\n[`Slice`](/mojo/stdlib/builtin/builtin_slice/Slice) (or multiple `Slice`s in\nthe case of a multi-dimensional collection).\n\n```mojo\nstruct MySeq[type: Copyable & Movable]:\n # Return a new MySeq with a subset of elements\n fn __getitem__(self, span: Slice) -> Self:\n ...", "position": 80, "token_count": 172, "has_code": true, "section_hierarchy": ["Slicing"], "metadata": {"chunk_id": "operators-080", "document_id": "operators", "position": 80, "token_count": 172, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Slicing"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#slicing"}}
{"chunk_id": "operators-081", "document_id": "operators", "content": "```\n\nA `Slice` contains three fields:\n\n- `start` (`Optional[Int]`): The starting index of the slice\n- `end` (`Optional[Int]`): The ending index of the slice\n- `step` (`Optional[Int]`): The step increment value of the slice.\n\nBecause the start, end, and step values are all optional when using slice\nsyntax, they are represented as `Optional[Int]` values in the `Slice`. And if\npresent, the index values might be negative representing a relative position\nfrom the end of the sequence. As a convenience, `Slice` provides an `indices()`\nmethod that accepts a `length` value and returns a 3-tuple of \"normalized\"\nstart, end, and step values for the given length, all represented as\nnon-negative values. You can then use these normalized values to determine the\ncorresponding elements of your collection being referenced.\n\n```mojo\nstruct MySeq[type: Copyable & Movable]:\n var size: Int", "position": 81, "token_count": 226, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-081", "document_id": "operators", "position": 81, "token_count": 226, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-082", "document_id": "operators", "content": "```mojo\nstruct MySeq[type: Copyable & Movable]:\n var size: Int\n\n # Return a new MySeq with a subset of elements\n fn __getitem__(self, span: Slice) -> Self:\n var start: Int\n var end: Int\n var step: Int\n start, end, step = span.indices(self.size)\n ...", "position": 82, "token_count": 87, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-082", "document_id": "operators", "position": 82, "token_count": 87, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-083", "document_id": "operators", "content": "```", "position": 83, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-083", "document_id": "operators", "position": 83, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-084", "document_id": "operators", "content": "## An example of implementing operators for a custom type\n\nAs an example of implementing operators for a custom Mojo type, let's create a\n`Complex` struct to represent a single complex number, with both the real and\nimaginary components stored as `Float64` values. We'll implement most of the\narithmetic operators, the associated in-place assignment operators, the equality\ncomparison operators, and a few additional convenience methods to support\noperations like printing complex values. We'll also allow mixing `Complex` and\n`Float64` values in arithmetic expressions to produce a `Complex` result.\n\nThis example builds our `Complex` struct incrementally. You can also find the\n[complete example in the public GitHub\nrepo](https://github.com/modular/modular/tree/main/examples/mojo/operators).", "position": 84, "token_count": 179, "has_code": false, "section_hierarchy": ["An example of implementing operators for a custom type"], "metadata": {"chunk_id": "operators-084", "document_id": "operators", "position": 84, "token_count": 179, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["An example of implementing operators for a custom type"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#an-example-of-implementing-operators-for-a-custom-type"}}
{"chunk_id": "operators-085", "document_id": "operators", "content": "[note]\nNote that the Mojo standard library implements a parameterized\n[`ComplexSIMD`](/mojo/stdlib/complex/complex/ComplexSIMD) struct that provides\nsupport for a basic set of arithmetic operators. However, our `Complex` type\nwill not be based on the `ComplexSIMD` struct or be compatible with it.", "position": 85, "token_count": 79, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-085", "document_id": "operators", "position": 85, "token_count": 79, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-086", "document_id": "operators", "content": "### Implement lifecycle methods\n\nOur `Complex` struct is an example of a simple value type consisting of trivial\nnumeric fields and requiring no special constructor or destructor behaviors.\nThis means we can use the\n[`@register_passable(\"trivial\")`](/mojo/manual/decorators/register-passable/#register_passabletrivial)\ndecorator, which declares that the type can be trivially copied, moved, and\ndestroyed—and doesn't need a copy constructor, move constructor, or destructor.\n\nFor the time being, we'll also use the\n[`@fieldwise_init`](/mojo/manual/decorators/fieldwise-init) decorator to\nautomatically implement a field-wise initializer (a constructor with arguments\nfor each field).\n\n```mojo\n@fieldwise_init\n@register_passable(\"trivial\")\nstruct Complex:\n var re: Float64\n var im: Float64", "position": 86, "token_count": 215, "has_code": true, "section_hierarchy": ["Implement lifecycle methods"], "metadata": {"chunk_id": "operators-086", "document_id": "operators", "position": 86, "token_count": 215, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implement lifecycle methods"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-lifecycle-methods"}}
{"chunk_id": "operators-087", "document_id": "operators", "content": "```\n\nThis definition is enough for us to create `Complex` instances and access their\nreal and imaginary fields.\n\n```mojo\nc1 = Complex(-1.2, 6.5)\nprint(\"c1: Real: {}; Imaginary: {}\".format(c1.re, c1.im))\n```\n\n```output\nc1: Real: -1.2; Imaginary: 6.5\n```\n\nAs a convenience, let's add an explicit constructor to handle the case of\ncreating a `Complex` instance with an imaginary component of 0.\n\n```mojo\n@register_passable(\"trivial\")\nstruct Complex():\n var re: Float64\n var im: Float64\n\n fn __init__(out self, re: Float64, im: Float64 = 0.0):\n self.re = re\n self.im = im", "position": 87, "token_count": 191, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-087", "document_id": "operators", "position": 87, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-088", "document_id": "operators", "content": "```\n\nSince this constructor also handles creating a `Complex` instance with both real\nand imaginary components, we don't need the `@fieldwise_init` decorator anymore.\n\nNow we can create a `Complex` instance and provide just a real component.\n\n```mojo\nc2 = Complex(3.14159)\nprint(\"c2: Real: {}; Imaginary: {}\".format(c2.re, c2.im))\n```\n\n```output\nc2: Real: 3.1415899999999999; Imaginary: 0.0\n```", "position": 88, "token_count": 133, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-088", "document_id": "operators", "position": 88, "token_count": 133, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-089", "document_id": "operators", "content": "### Implement the `Writable` and `Stringable` traits\n\nTo make it simpler to print `Complex` values, let's implement the\n[Writable](/mojo/stdlib/utils/write/Writable) trait. While we're at it, let's\nalso implement the [`Stringable`](/mojo/stdlib/builtin/str/Stringable) trait so\nthat we can use the `String()` constructor to generate a `String` representation of a\n`Complex` value. You can find out more about these traits and their associated\nmethods in [The `Stringable`, `Representable`, and `Writable`\ntraits](/mojo/manual/traits#the-stringable-representable-and-writable-traits).\n\n```mojo\n@register_passable(\"trivial\")\nstruct Complex(\n Writable,\n Stringable,\n):\n # ...\n\n fn __str__(self) -> String:\n return String.write(self)", "position": 89, "token_count": 228, "has_code": true, "section_hierarchy": ["Implement the `Writable` and `Stringable` traits"], "metadata": {"chunk_id": "operators-089", "document_id": "operators", "position": 89, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implement the `Writable` and `Stringable` traits"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-the-writable-and-stringable-traits"}}
{"chunk_id": "operators-090", "document_id": "operators", "content": "fn __str__(self) -> String:\n return String.write(self)\n\n fn write_to(self, mut writer: Some[Writer]):\n writer.write(\"(\", self.re)\n if self.im < 0:\n writer.write(\" - \", -self.im)\n else:\n writer.write(\" + \", self.im)\n writer.write(\"i)\")", "position": 90, "token_count": 97, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-090", "document_id": "operators", "position": 90, "token_count": 97, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-091", "document_id": "operators", "content": "```\n\n[note]\nThe `Writable` trait doesn't allow the `write_to()` method to raise an error and\nthe `Stringable` trait doesn't allow the `__str__()` method to raise an error.\nBecause defining a method with `def` implies that it can raise an error, we\ninstead have to define these methods with `fn`. See\n[Functions](/mojo/manual/functions) for more information on the differences\nbetween defining functions with `def` and `fn`.\n\nNow we can print a `Complex` value directly, and we can explicitly generate a\n`String` representation by passing a `Complex` value to `String()` which\nconstructs a new `String` from all the arguments passed to it.\n\n```mojo\nc3 = Complex(3.14159, -2.71828)\nprint(\"c3 =\", c3)\n\nvar msg = String(\"The value is: \", c3)\nprint(msg)", "position": 91, "token_count": 222, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-091", "document_id": "operators", "position": 91, "token_count": 222, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-092", "document_id": "operators", "content": "```\n\n```output\nc3 = (3.1415899999999999 - 2.71828i)\nThe value is: (3.1415899999999999 - 2.71828i)\n```", "position": 92, "token_count": 67, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-092", "document_id": "operators", "position": 92, "token_count": 67, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-093", "document_id": "operators", "content": "### Implement basic indexing\n\nIndexing usually is supported only by collection types. But as an example, let's\nimplement support for accessing the real component as index 0 and the imaginary\ncomponent as index 1. We'll not implement slicing or variadic assignment for\nthis example.\n\n```mojo\n # ...\n def __getitem__(self, idx: Int) -> Float64:\n if idx == 0:\n return self.re\n elif idx == 1:\n return self.im\n else:\n raise \"index out of bounds\"\n\n def __setitem__(mut self, idx: Int, value: Float64) -> None:\n if idx == 0:\n self.re = value\n elif idx == 1:\n self.im = value\n else:\n raise \"index out of bounds\"", "position": 93, "token_count": 183, "has_code": true, "section_hierarchy": ["Implement basic indexing"], "metadata": {"chunk_id": "operators-093", "document_id": "operators", "position": 93, "token_count": 183, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implement basic indexing"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-basic-indexing"}}
{"chunk_id": "operators-094", "document_id": "operators", "content": "```\n\nNow let's try getting and setting the real and imaginary components of a\n`Complex` value using indexing.\n\n```mojo\nc2 = Complex(3.14159)\nprint(\"c2[0]: {}; c2[1]: {}\".format(c2[0], c2[1]))\nc2[0] = 2.71828\nc2[1] = 42\nprint(\"c2[0] = 2.71828; c2[1] = 42; c2:\", c2)\n```\n\n```output\nc2[0]: 3.1415899999999999; c2[1]: 0.0\nc2[0] = 2.71828; c2[1] = 42; c2: (2.71828 + 42.0i)\n```", "position": 94, "token_count": 188, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-094", "document_id": "operators", "position": 94, "token_count": 188, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-095", "document_id": "operators", "content": "### Implement arithmetic operators\n\nNow let's implement the dunder methods that allow us to perform arithmetic\noperations on `Complex` values. (Refer to the [Wikipedia\npage](https://en.wikipedia.org/wiki/Complex_number) on complex numbers for a\nmore in-depth explanation of the formulas for these operators.)", "position": 95, "token_count": 74, "has_code": false, "section_hierarchy": ["Implement arithmetic operators"], "metadata": {"chunk_id": "operators-095", "document_id": "operators", "position": 95, "token_count": 74, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Implement arithmetic operators"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-arithmetic-operators"}}
{"chunk_id": "operators-096", "document_id": "operators", "content": "#### Implement basic operators for `Complex` values\n\nThe unary `+` operator simply returns the original value, whereas the unary `-`\noperator returns a new `Complex` value with the real and imaginary components\nnegated.\n\n```mojo\n # ...\n def __pos__(self) -> Self:\n return self\n\n def __neg__(self) -> Self:\n return Self(-self.re, -self.im)\n```\n\nLet's test these out by printing the result of applying each operator.\n\n```mojo\nc1 = Complex(-1.2, 6.5)\nprint(\"+c1:\", +c1)\nprint(\"-c1:\", -c1)\n```\n\n```output\n+c1: (-1.2 + 6.5i)\n-c1: (1.2 - 6.5i)", "position": 96, "token_count": 193, "has_code": true, "section_hierarchy": ["Implement basic operators for `Complex` values"], "metadata": {"chunk_id": "operators-096", "document_id": "operators", "position": 96, "token_count": 193, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implement basic operators for `Complex` values"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-basic-operators-for-complex-values"}}
{"chunk_id": "operators-097", "document_id": "operators", "content": "```\n\n```output\n+c1: (-1.2 + 6.5i)\n-c1: (1.2 - 6.5i)\n```\n\nNext we'll implement the basic binary operators: `+`, `-`, `*`, and `/`.\nDividing complex numbers is a bit tricky, so we'll also define a helper method\ncalled `norm()` to calculate the [Euclidean\nnorm](https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm_of_complex_numbers)\nof a `Complex` instance, which can also be useful for other types of analysis\nwith complex numbers.\n\nFor all of these dunder methods, the left-hand side operand is `self` and the\nright-hand side operand is passed as an argument. We return a new `Complex`\nvalue representing the result.\n\n```mojo\nfrom math import sqrt", "position": 97, "token_count": 202, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-097", "document_id": "operators", "position": 97, "token_count": 202, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-098", "document_id": "operators", "content": "# ...\n\n def __add__(self, rhs: Self) -> Self:\n return Self(self.re + rhs.re, self.im + rhs.im)\n\n def __sub__(self, rhs: Self) -> Self:\n return Self(self.re - rhs.re, self.im - rhs.im)\n\n def __mul__(self, rhs: Self) -> Self:\n return Self(\n self.re * rhs.re - self.im * rhs.im,\n self.re * rhs.im + self.im * rhs.re\n )\n\n def __truediv__(self, rhs: Self) -> Self:\n denom = rhs.squared_norm()\n return Self(\n (self.re * rhs.re + self.im * rhs.im) / denom,\n (self.im * rhs.re - self.re * rhs.im) / denom\n )", "position": 98, "token_count": 222, "has_code": false, "section_hierarchy": ["..."], "metadata": {"chunk_id": "operators-098", "document_id": "operators", "position": 98, "token_count": 222, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["..."], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#"}}
{"chunk_id": "operators-099", "document_id": "operators", "content": "def squared_norm(self) -> Float64:\n return self.re * self.re + self.im * self.im\n\n def norm(self) -> Float64:\n return sqrt(self.squared_norm())", "position": 99, "token_count": 52, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-099", "document_id": "operators", "position": 99, "token_count": 52, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-100", "document_id": "operators", "content": "```\n\nNow we can try them out.\n\n```mojo\nc1 = Complex(-1.2, 6.5)\nc3 = Complex(3.14159, -2.71828)\nprint(\"c1 + c3 =\", c1 + c3)\nprint(\"c1 - c3 =\", c1 - c3)\nprint(\"c1 * c3 =\", c1 * c3)\nprint(\"c1 / c3 =\", c1 / c3)\n```\n\n```output\nc1 + c3 = (1.9415899999999999 + 3.78172i)\nc1 - c3 = (-4.3415900000000001 + 9.21828i)\nc1 * c3 = (13.898912000000001 + 23.682270999999997i)\nc1 / c3 = (-1.2422030701265261 + 0.99419218883955773i)\n```", "position": 100, "token_count": 238, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-100", "document_id": "operators", "position": 100, "token_count": 238, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-101", "document_id": "operators", "content": "#### Implement overloaded arithmetic operators for `Float64` values\n\nOur initial set of binary arithmetic operators work fine if both operands are\n`Complex` instances. But if we have a `Float64` value representing just a real\nvalue, we'd first need to use it to create a `Complex` value before we could\nadd, subtract, multiply, or divide it with another `Complex` value. If we think\nthat this will be a common use case, it makes sense to overload our arithmetic\nmethods to accept a `Float64` as the second operand.", "position": 101, "token_count": 123, "has_code": false, "section_hierarchy": ["Implement overloaded arithmetic operators for `Float64` values"], "metadata": {"chunk_id": "operators-101", "document_id": "operators", "position": 101, "token_count": 123, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Implement overloaded arithmetic operators for `Float64` values"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-overloaded-arithmetic-operators-for-float64-values"}}
{"chunk_id": "operators-102", "document_id": "operators", "content": "For the case where we have `complex1 + float1`, we can just create an overloaded\ndefinition of `__add__()`. But what about the case of `float1 + complex1`? By\ndefault, when Mojo encounters a `+` operator it tries to invoke the `__add__()`\nmethod of the left-hand operand, but the built-in `Float64` type doesn't\nimplement support for addition with a `Complex` value. This is an example where\nwe need to implement the `__radd__()` method on the `Complex` type. When Mojo\ncan't find an `__add__(self, rhs: Complex) -> Complex` method defined on\n`Float64`, it uses the `__radd__(self, lhs: Float64) -> Complex` method defined\non `Complex`.\n\nSo we can support arithmetic operations on `Complex` and `Float64` values by\nimplementing the following eight methods.", "position": 102, "token_count": 223, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-102", "document_id": "operators", "position": 102, "token_count": 223, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-103", "document_id": "operators", "content": "So we can support arithmetic operations on `Complex` and `Float64` values by\nimplementing the following eight methods.\n\n```mojo\n # ...\n def __add__(self, rhs: Float64) -> Self:\n return Self(self.re + rhs, self.im)\n\n def __radd__(self, lhs: Float64) -> Self:\n return Self(self.re + lhs, self.im)\n\n def __sub__(self, rhs: Float64) -> Self:\n return Self(self.re - rhs, self.im)\n\n def __rsub__(self, lhs: Float64) -> Self:\n return Self(lhs - self.re, -self.im)\n\n def __mul__(self, rhs: Float64) -> Self:\n return Self(self.re * rhs, self.im * rhs)", "position": 103, "token_count": 205, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-103", "document_id": "operators", "position": 103, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-104", "document_id": "operators", "content": "def __mul__(self, rhs: Float64) -> Self:\n return Self(self.re * rhs, self.im * rhs)\n\n def __rmul__(self, lhs: Float64) -> Self:\n return Self(lhs * self.re, lhs * self.im)\n\n def __truediv__(self, rhs: Float64) -> Self:\n return Self(self.re / rhs, self.im / rhs)\n\n def __rtruediv__(self, lhs: Float64) -> Self:\n denom = self.squared_norm()\n return Self(\n (lhs * self.re) / denom,\n (-lhs * self.im) / denom\n )", "position": 104, "token_count": 173, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-104", "document_id": "operators", "position": 104, "token_count": 173, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-105", "document_id": "operators", "content": "```\n\nLet's see them in action.\n\n```mojo\nc1 = Complex(-1.2, 6.5)\nf1 = 2.5\nprint(\"c1 + f1 =\", c1 + f1)\nprint(\"f1 + c1 =\", f1 + c1)\nprint(\"c1 - f1 =\", c1 - f1)\nprint(\"f1 - c1 =\", f1 - c1)\nprint(\"c1 * f1 =\", c1 * f1)\nprint(\"f1 * c1 =\", f1 * c1)\nprint(\"c1 / f1 =\", c1 / f1)\nprint(\"f1 / c1 =\", f1 / c1)", "position": 105, "token_count": 139, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-105", "document_id": "operators", "position": 105, "token_count": 139, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-106", "document_id": "operators", "content": "```\n\n```output\nc1 + f1 = (1.3 + 6.5i)\nf1 + c1 = (1.3 + 6.5i)\nc1 - f1 = (-3.7000000000000002 + 6.5i)\nf1 - c1 = (3.7000000000000002 - 6.5i)\nc1 * f1 = (-3.0 + 16.25i)\nf1 * c1 = (-3.0 + 16.25i)\nc1 / f1 = (-0.47999999999999998 + 2.6000000000000001i)\nf1 / c1 = (-0.068665598535133904 - 0.37193865873197529i)\n```", "position": 106, "token_count": 182, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-106", "document_id": "operators", "position": 106, "token_count": 182, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-107", "document_id": "operators", "content": "#### Implement in-place assignment operators\n\nNow let's implement support for the in-place assignment operators: `+=`, `-=`,\n`*=`, and `/=`. These modify the original value, so we need to mark `self` as\nbeing an `mut` argument and update the `re` and `im` fields instead of\nreturning a new `Complex` instance. And once again, we'll overload the\ndefinitions to support both a `Complex` and a `Float64` operand.\n\n```mojo\n # ...\n def __iadd__(mut self, rhs: Self) -> None:\n self.re += rhs.re\n self.im += rhs.im\n\n def __iadd__(mut self, rhs: Float64) -> None:\n self.re += rhs\n\n def __isub__(mut self, rhs: Self) -> None:\n self.re -= rhs.re\n self.im -= rhs.im", "position": 107, "token_count": 232, "has_code": true, "section_hierarchy": ["Implement in-place assignment operators"], "metadata": {"chunk_id": "operators-107", "document_id": "operators", "position": 107, "token_count": 232, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implement in-place assignment operators"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-in-place-assignment-operators"}}
{"chunk_id": "operators-108", "document_id": "operators", "content": "def __isub__(mut self, rhs: Self) -> None:\n self.re -= rhs.re\n self.im -= rhs.im\n\n def __isub__(mut self, rhs: Float64) -> None:\n self.re -= rhs\n\n def __imul__(mut self, rhs: Self) -> None:\n new_re = self.re * rhs.re - self.im * rhs.im\n new_im = self.re * rhs.im + self.im * rhs.re\n self.re = new_re\n self.im = new_im\n\n def __imul__(mut self, rhs: Float64) -> None:\n self.re *= rhs\n self.im *= rhs", "position": 108, "token_count": 183, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-108", "document_id": "operators", "position": 108, "token_count": 183, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-109", "document_id": "operators", "content": "def __imul__(mut self, rhs: Float64) -> None:\n self.re *= rhs\n self.im *= rhs\n\n def __itruediv__(mut self, rhs: Self) -> None:\n denom = rhs.squared_norm()\n new_re = (self.re * rhs.re + self.im * rhs.im) / denom\n new_im = (self.im * rhs.re - self.re * rhs.im) / denom\n self.re = new_re\n self.im = new_im\n\n def __itruediv__(mut self, rhs: Float64) -> None:\n self.re /= rhs\n self.im /= rhs", "position": 109, "token_count": 174, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-109", "document_id": "operators", "position": 109, "token_count": 174, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-110", "document_id": "operators", "content": "```\n\nAnd now to try them out.", "position": 110, "token_count": 12, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-110", "document_id": "operators", "position": 110, "token_count": 12, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-111", "document_id": "operators", "content": "```mojo\nc4 = Complex(-1, -1)\nprint(\"c4 =\", c4)\nc4 += Complex(0.5, -0.5)\nprint(\"c4 += Complex(0.5, -0.5) =>\", c4)\nc4 += 2.75\nprint(\"c4 += 2.75 =>\", c4)\nc4 -= Complex(0.25, 1.5)\nprint(\"c4 -= Complex(0.25, 1.5) =>\", c4)\nc4 -= 3\nprint(\"c4 -= 3 =>\", c4)\nc4 *= Complex(-3.0, 2.0)\nprint(\"c4 *= Complex(-3.0, 2.0) =>\", c4)\nc4 *= 0.75", "position": 111, "token_count": 197, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-111", "document_id": "operators", "position": 111, "token_count": 197, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-112", "document_id": "operators", "content": "print(\"c4 *= Complex(-3.0, 2.0) =>\", c4)\nc4 *= 0.75\nprint(\"c4 *= 0.75 =>\", c4)\nc4 /= Complex(1.25, 2.0)\nprint(\"c4 /= Complex(1.25, 2.0) =>\", c4)\nc4 /= 2.0\nprint(\"c4 /= 2.0 =>\", c4)", "position": 112, "token_count": 113, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "operators-112", "document_id": "operators", "position": 112, "token_count": 113, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-113", "document_id": "operators", "content": "```\n\n```output\nc4 = (-1.0 - 1.0i)\nc4 += Complex(0.5, -0.5) => (-0.5 - 1.5i)\nc4 += 2.75 => (2.25 - 1.5i)\nc4 -= Complex(0.25, 1.5) => (2.0 - 3.0i)\nc4 -= 3 => (-1.0 - 3.0i)\nc4 *= Complex(-3.0, 2.0) => (9.0 + 7.0i)\nc4 *= 0.75 => (6.75 + 5.25i)\nc4 /= Complex(1.25, 2.0) => (3.404494382022472 - 1.247191011235955i)\nc4 /= 2.0 => (1.702247191011236 - 0.6235955056179775i)\n```", "position": 113, "token_count": 237, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-113", "document_id": "operators", "position": 113, "token_count": 237, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}
{"chunk_id": "operators-114", "document_id": "operators", "content": "### Implement equality operators\n\nThe field of complex numbers is not an ordered field, so it doesn't make sense\nfor us to implement the `Comparable` trait and the `>`, `>=`, `<`, and `<=`\noperators. However, we can implement the `Equatable` trait and the `==`\nand `!=` operators. (Of course, this suffers the same limitation of comparing\nfloating point numbers for equality because of the limited precision of\nrepresenting floating point numbers when performing arithmetic operations. But\nwe'll go ahead and implement the operators for completeness.)\n\n```mojo\nstruct Complex(\n Equatable,\n Formattable,\n Stringable,\n):\n # ...\n fn __eq__(self, other: Self) -> Bool:\n return self.re == other.re and self.im == other.im\n\n fn __ne__(self, other: Self) -> Bool:\n return self.re != other.re or self.im != other.im", "position": 114, "token_count": 228, "has_code": true, "section_hierarchy": ["Implement equality operators"], "metadata": {"chunk_id": "operators-114", "document_id": "operators", "position": 114, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implement equality operators"], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators#implement-equality-operators"}}
{"chunk_id": "operators-115", "document_id": "operators", "content": "```\n\n[note]\nThe `Equatable` trait doesn't allow the `__eq__()` and `__ne__()`\nmethods to raise errors. Because defining a method with `def` implies that it\ncan raise an error, we instead have to define these methods with `fn`. See\n[Functions](/mojo/manual/functions) for more information on the differences\nbetween defining functions with `def` and `fn`.\n\nAnd now to try them out.\n\n```mojo\nc1 = Complex(-1.2, 6.5)\nc3 = Complex(3.14159, -2.71828)\nc5 = Complex(-1.2, 6.5)\n\nif c1 == c5:\n print(\"c1 is equal to c5\")\nelse:\n print(\"c1 is not equal to c5\")\n\nif c1 != c3:\n print(\"c1 is not equal to c3\")\nelse:\n print(\"c1 is equal to c3\")\n```\n\n```output\nc1 is equal to c5\nc1 is not equal to c3\n```", "position": 115, "token_count": 247, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "operators-115", "document_id": "operators", "position": 115, "token_count": 247, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "operators.mdx", "url": "https://docs.modular.com/mojo/manual/operators", "title": "Operators, expressions, and dunder methods", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/operators"}}

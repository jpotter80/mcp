{"chunk_id": "structs-000", "document_id": "structs", "content": "A Mojo struct is a data structure that allows you to encapsulate fields and\nmethods that operate on an abstraction, such as a data type or an object.\n**Fields** are variables that hold data relevant to the struct, and **methods**\nare functions inside a struct that generally act upon the field data.\n\nFor example, if you're building a graphics program, you can use a struct to\ndefine an `Image` that has fields to store information about each image\n(such as the pixels) and methods that perform actions on it (such as rotate\nit).\n\nFor the most part, Mojo's struct format is designed to provide a static,\nmemory-safe data structure for high-level data types used in programs. For\nexample, all the data types in Mojo's standard library (such as `Int`,\n`Bool`, `String`, and `Tuple`) are defined as structs.", "position": 0, "token_count": 205, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "structs-000", "document_id": "structs", "position": 0, "token_count": 205, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-001", "document_id": "structs", "content": "If you understand how [functions](/mojo/manual/functions) and\n[variables](/mojo/manual/variables) work in Mojo, you probably\nnoticed that Mojo is designed to provide dynamic programming features in a\n`def` function while enforcing stronger code safety in `fn` functions. When it\ncomes to structs, Mojo leans toward the safe side: You can still choose whether\nto use either `def` or `fn` declarations for methods, but all fields must be\ndeclared with `var`.", "position": 1, "token_count": 110, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "structs-001", "document_id": "structs", "position": 1, "token_count": 110, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-002", "document_id": "structs", "content": "## Struct definition\n\nYou can define a simple struct called `MyPair` with two fields like this:\n\n```mojo\nstruct MyPair:\n var first: Int\n var second: Int\n```\n\nHowever, you can't instantiate this struct because it has no constructor\nmethod. So here it is with a constructor to initialize the two fields:\n\n```mojo\nstruct MyPair:\n var first: Int\n var second: Int\n\n fn __init__(out self, first: Int, second: Int):\n self.first = first\n self.second = second", "position": 2, "token_count": 135, "has_code": true, "section_hierarchy": ["Struct definition"], "metadata": {"chunk_id": "structs-002", "document_id": "structs", "position": 2, "token_count": 135, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Struct definition"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#struct-definition"}}
{"chunk_id": "structs-003", "document_id": "structs", "content": "```\n\nNotice that the first argument in the `__init__()` method is `out self`. You'll\nhave a `self` argument as the first argument on all struct methods. It\nreferences the current struct instance (it allows code in the method to refer to\n\"itself\"). *When you call the constructor, you never pass a value for\n`self`—Mojo passes it in automatically.*\n\nThe `out` portion of `out self` is an [argument\nconvention](/mojo/manual/values/ownership#argument-conventions) that declares\n`self` as a mutable reference that starts out as uninitialized and must be\ninitialized before the function returns.", "position": 3, "token_count": 155, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "structs-003", "document_id": "structs", "position": 3, "token_count": 155, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-004", "document_id": "structs", "content": "Many types use a field-wise constructor like the one shown for `MyPair` above:\nit takes an argument for each field, and initializes the fields directly from\nthe arguments. To save typing, Mojo provides a\n[`@fieldwise_init`](/mojo/manual/decorators/fieldwise-init) decorator, which\ngenerates a field-wise constructor for the struct. So you can rewrite the\n`MyPair` example above like this:\n\n```mojo\n@fieldwise_init\nstruct MyPair:\n var first: Int\n var second: Int", "position": 4, "token_count": 131, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "structs-004", "document_id": "structs", "position": 4, "token_count": 131, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-005", "document_id": "structs", "content": "```\n\nThe `__init__()` method is one of many [special methods](#special-methods)\n(also known as \"dunder methods\" because they have *d*ouble *under*scores) with\npre-determined names.\n\n[note]\nYou can't assign values when you declare fields. You must initialize\nall of the struct's fields in the constructor. (If you try to leave a field\nuninitialized, the code won't compile.)\n\nOnce you have a constructor, you can create an instance of `MyPair` and set the\nfields:\n\n```mojo\nvar mine = MyPair(2, 4)\nprint(mine.first)\n```\n\n```output\n2\n```", "position": 5, "token_count": 168, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "structs-005", "document_id": "structs", "position": 5, "token_count": 168, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-006", "document_id": "structs", "content": "## Making a struct copyable and movable\n\nMojo structs are not copyable or movable by default.\n\nFor example, the following code produces errors:\n\n```mojo\nvar a = MyPair(1, 2)", "position": 6, "token_count": 52, "has_code": true, "section_hierarchy": ["Making a struct copyable and movable"], "metadata": {"chunk_id": "structs-006", "document_id": "structs", "position": 6, "token_count": 52, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Making a struct copyable and movable"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#making-a-struct-copyable-and-movable"}}
{"chunk_id": "structs-007", "document_id": "structs", "content": "# Implicit copy\nvar b = a # value of type 'MyPair' is not implicitly copyable, it does not\n # conform to 'ImplicitlyCopyable'\n\n# Explicit copy\nvar c = a.copy() # 'MyPair' value has no attribute 'copy'", "position": 7, "token_count": 62, "has_code": false, "section_hierarchy": ["Explicit copy"], "metadata": {"chunk_id": "structs-007", "document_id": "structs", "position": 7, "token_count": 62, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Explicit copy"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#explicit-copy"}}
{"chunk_id": "structs-008", "document_id": "structs", "content": "# Move\nvar d = a^ # value of type 'MyPair' cannot be copied or moved; consider\n # conforming it to 'Movable'\n\n```\n\nIn most cases, you can make a struct copyable and movable just by adding the\nappropriate [traits](/mojo/manual/traits).\n\n### Copyability\n\nTo make a struct copyable, add the `Copyable` trait:\n\n ```mojo\n struct MyPair(Copyable):\n ...\n ```\n\nIn most cases, that's all you need to do. Mojo will generate a copy constructor\n( `__copyinit__()` method) for you. You don't need to write your own unless you\nneed custom logic in the copy constructor—for example, if your struct\ndynamically allocates memory. For more information, see the section on\n[copy constructors](/mojo/manual/lifecycle/life#copy-constructor).\n\nThe `Copyable` trait also supplies the `copy()` method, which\nprovides a more user-friendly way to copy a value than invoking the\ncopy constructor directly.", "position": 8, "token_count": 252, "has_code": true, "section_hierarchy": ["Copyability"], "metadata": {"chunk_id": "structs-008", "document_id": "structs", "position": 8, "token_count": 252, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Copyability"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#copyability"}}
{"chunk_id": "structs-009", "document_id": "structs", "content": "### Implicit copyability\n\nTo make a struct implicitly copyable, add the `ImplicitlyCopyable` trait:\n\n```mojo\nstruct MyPair(ImplicitlyCopyable):\n ...\n```\n\n`ImplicitlyCopyable` automatically implies `Copyable`, so all\nthe notes related to copyability apply here. A type should only be implicitly\ncopyable if copying the type is inexpensive and has no side effects. Unnecessary\ncopies can be a big drain on memory and performance, so use this trait with\ncaution.\n\n### Movability\n\nTo make a struct movable, add the `Movable` trait:\n\n ```mojo\n struct MyPair(Copyable, Movable):\n ...\n ```\n\nMojo will generate a move constructor for you. You have rarely need to\nwrite your own custom move constructor. For more information,\nsee the section on\n[move constructors](/mojo/manual/lifecycle/life#move-constructor).", "position": 9, "token_count": 219, "has_code": true, "section_hierarchy": ["Movability"], "metadata": {"chunk_id": "structs-009", "document_id": "structs", "position": 9, "token_count": 219, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Movability"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#movability"}}
{"chunk_id": "structs-010", "document_id": "structs", "content": "### A movable, copyable `MyPair`\n\nHere's a movable and implicitly copyable version of `MyPair`:\n\n```mojo\n@fieldwise_init\nstruct MyPair(ImplicitlyCopyable, Movable):\n var first: Int\n var second: Int\n```\n\nSince the `MyPair` struct is a simple data structure that holds two `Int`\nvalues, there's no harm in making it implicitly copyable.\n\nAnd here's how to exercise the copy and move constructors:\n\n```mojo\nvar original_pair = MyPair(2, 6)\nvar copied_pair = original_pair # implicit copy\nvar another_pair = original_pair.copy() # explicit copy\nvar moved_pair = original_pair^ # move\n```", "position": 10, "token_count": 180, "has_code": true, "section_hierarchy": ["A movable, copyable `MyPair`"], "metadata": {"chunk_id": "structs-010", "document_id": "structs", "position": 10, "token_count": 180, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["A movable, copyable `MyPair`"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#a-movable-copyable-mypair"}}
{"chunk_id": "structs-011", "document_id": "structs", "content": "## Methods\n\nIn addition to special methods like `__init__()`, you can add any other method\nyou want to your struct. For example:\n\n```mojo\n@fieldwise_init\nstruct MyPair:\n var first: Int\n var second: Int\n\n fn get_sum(self) -> Int:\n return self.first + self.second\n```\n\n```mojo\nvar mine = MyPair(6, 8)\nprint(mine.get_sum())\n```\n\n```output\n14", "position": 11, "token_count": 120, "has_code": true, "section_hierarchy": ["Methods"], "metadata": {"chunk_id": "structs-011", "document_id": "structs", "position": 11, "token_count": 120, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Methods"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#methods"}}
{"chunk_id": "structs-012", "document_id": "structs", "content": "```\n\n```mojo\nvar mine = MyPair(6, 8)\nprint(mine.get_sum())\n```\n\n```output\n14\n```\n\nNotice that `get_sum()` also uses the `self` argument, because this is\nthe only way you can access the struct's fields in a method. The name `self` is\njust a convention, and you can use any name you want to refer to the struct\ninstance that is always passed as the first argument.\n\nMethods that take the implicit `self` argument are called *instance methods*\nbecause they act on an instance of the struct.\n\n[note]\nThe `self` argument in a struct method is the only argument in an\n`fn` function that does not require a type. You can include it if you want, but\nyou can elide it because Mojo already knows its type (`MyPair` in this case).", "position": 12, "token_count": 203, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "structs-012", "document_id": "structs", "position": 12, "token_count": 203, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-013", "document_id": "structs", "content": "### `fn` versus `def` in struct methods\n\nStruct methods can be declared with either the `def` or `fn` keywords. One\nimportant difference is that an `fn` function without the `raises` keyword can't\nraise an error. When you call a function that *can* raise an error from inside a\nmethod that *can't* raise an error, Mojo requires you to handle any errors, as\ndescribed in\n[Errors, error handling, and context managers](/mojo/manual/errors).\n\nIf you're writing code that you expect to use widely or distribute as a package,\nyou may want to use `fn` functions for APIs that can't raise an error to limit\nthe number of places users need to add error handling code.\n\nA struct's `__del__()` method, or destructor, **must** be a non-raising method,\nso it's always declared with `fn` (and without the `raises` keyword).", "position": 13, "token_count": 228, "has_code": false, "section_hierarchy": ["`fn` versus `def` in struct methods"], "metadata": {"chunk_id": "structs-013", "document_id": "structs", "position": 13, "token_count": 228, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`fn` versus `def` in struct methods"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#fn-versus-def-in-struct-methods"}}
{"chunk_id": "structs-014", "document_id": "structs", "content": "### Static methods\n\nA struct can also have *static methods*. A static method can be called without\ncreating an instance of the struct. Unlike instance methods, a static method\ndoesn't receive the implicit `self` argument, so it can't access any fields on\nthe struct.\n\nTo declare a static method, use the `@staticmethod` decorator and don't include\na `self` argument:\n\n```mojo\nstruct Logger:\n\n fn __init__(out self):\n pass\n\n @staticmethod\n fn log_info(message: String):\n print(\"Info: \", message)\n```\n\nYou can invoke a static method by calling it on the type (in this case,\n`Logger`). You can also call it on an instance of the type. Both forms are\nshown below:\n\n```mojo\nLogger.log_info(\"Static method called.\")\nvar l = Logger()\nl.log_info(\"Static method called from instance.\")\n```\n\n```output\nInfo: Static method called.\nInfo: Static method called from instance.\n```", "position": 14, "token_count": 254, "has_code": true, "section_hierarchy": ["Static methods"], "metadata": {"chunk_id": "structs-014", "document_id": "structs", "position": 14, "token_count": 254, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Static methods"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#static-methods"}}
{"chunk_id": "structs-015", "document_id": "structs", "content": "## Structs compared to classes\n\nIf you're familiar with other object-oriented languages, then structs might\nsound a lot like classes, and there are some similarities, but also some\nimportant differences. Eventually, Mojo will also support classes to match the\nbehavior of Python classes.\n\nSo, let's compare Mojo structs to Python classes. They both support methods,\nfields, operator overloading, decorators for metaprogramming, and more, but\ntheir key differences are as follows:\n\n* Python classes are dynamic: they allow for dynamic dispatch, monkey-patching\n (or “swizzling”), and dynamically binding instance fields at runtime.\n\n* Mojo structs are static: they are bound at compile-time (you cannot add\n methods at runtime). Structs allow you to trade flexibility for performance\n while being safe and easy to use.\n\n* Mojo structs do not support inheritance (\"sub-classing\"), but a struct can\n implement [traits](/mojo/manual/traits).", "position": 15, "token_count": 221, "has_code": false, "section_hierarchy": ["Structs compared to classes"], "metadata": {"chunk_id": "structs-015", "document_id": "structs", "position": 15, "token_count": 221, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Structs compared to classes"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#structs-compared-to-classes"}}
{"chunk_id": "structs-016", "document_id": "structs", "content": "* Mojo structs do not support inheritance (\"sub-classing\"), but a struct can\n implement [traits](/mojo/manual/traits).\n\n* Python classes support class attributes—values that are shared by all\n instances of the class, equivalent to class variables or static data members\n in other languages.\n\n* Mojo structs don't support static data members.\n\nSyntactically, the biggest difference compared to a Python class is that all\nfields in a struct must be explicitly declared with `var`.\n\nIn Mojo, the structure and contents of a struct are set at compile time and\ncan't be changed while the program is running. Unlike in Python, where you can\nadd, remove, or change attributes of an object on the fly, Mojo doesn't allow\nthat for structs.\n\nHowever, the static nature of structs helps Mojo run your code faster. The\nprogram knows exactly where to find the struct's information and how to use it\nwithout any extra steps or delays at runtime.", "position": 16, "token_count": 220, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "structs-016", "document_id": "structs", "position": 16, "token_count": 220, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-017", "document_id": "structs", "content": "However, the static nature of structs helps Mojo run your code faster. The\nprogram knows exactly where to find the struct's information and how to use it\nwithout any extra steps or delays at runtime.\n\nMojo's structs also work really well with features you might already know from\nPython, like operator overloading (which lets you change how math symbols like\n`+` and `-` work with your own data, using [special\nmethods](#special-methods)).\n\nAs mentioned above, all Mojo's standard types\n(`Int`, `String`, etc.) are made using structs, rather than being hardwired\ninto the language itself. This gives you more flexibility and control when\nwriting your code, and it means you can define your own types with all the same\ncapabilities (there's no special treatment for the standard library types).", "position": 17, "token_count": 185, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "structs-017", "document_id": "structs", "position": 17, "token_count": 185, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-018", "document_id": "structs", "content": "## Special methods\n\nSpecial methods (or \"dunder methods\") such as `__init__()` are pre-determined\nmethod names that you can define in a struct to perform a special task.\n\nAlthough it's possible to call special methods with their method names, the\npoint is that you never should, because Mojo automatically invokes them in\ncircumstances where they're needed (which is why they're also called \"magic\nmethods\"). For example, Mojo calls the `__init__()` method when you create\nan instance of the struct; and when Mojo destroys the instance, it calls the\n`__del__()` method (if it exists).\n\nEven operator behaviors that appear built-in (`+`, `<`, `==`, `|`, and so on)\nare implemented as special methods that Mojo implicitly calls upon to perform\noperations or comparisons on the type that the operator is applied to.", "position": 18, "token_count": 210, "has_code": false, "section_hierarchy": ["Special methods"], "metadata": {"chunk_id": "structs-018", "document_id": "structs", "position": 18, "token_count": 210, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Special methods"], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs#special-methods"}}
{"chunk_id": "structs-019", "document_id": "structs", "content": "Mojo supports a long list of special methods; far too many to discuss here, but\nthey generally match all of [Python's special\nmethods](https://docs.python.org/3/reference/datamodel#special-method-names)\nand they usually accomplish one of two types of tasks:\n\n* Operator overloading: A lot of special methods are designed to overload\n operators such as `<` (less-than), `+` (add), and `|` (or) so they work\n appropriately with each type. For more information, see\n [Implement operators for custom types](/mojo/manual/operators#implement-operators-for-custom-types).\n\n* Lifecycle event handling: These special methods deal with the lifecycle and\n value ownership of an instance. For example, `__init__()` and `__del__()`\n demarcate the beginning and end of an instance lifetime, and other special\n methods define the behavior for other lifecycle events such as how to copy or\n move a value.", "position": 19, "token_count": 226, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "structs-019", "document_id": "structs", "position": 19, "token_count": 226, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}
{"chunk_id": "structs-020", "document_id": "structs", "content": "You can learn all about the lifecycle special methods in the [Value\nlifecycle](/mojo/manual/lifecycle/) section. However, most structs are simple\naggregations of other types, so unless your type requires custom behaviors when\nan instance is created, copied, moved, or destroyed, you can synthesize the\nessential lifecycle methods you need (and save yourself some time) using the\n`@fieldwise_init` decorator (described in\n[Struct definition](#struct-definition)), and the `Copyable` and `Movable`\ntraits (described in\n[Making a struct copyable and movable](#making-a-struct-copyable-and-movable)).", "position": 20, "token_count": 162, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "structs-020", "document_id": "structs", "position": 20, "token_count": 162, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "structs.mdx", "url": "https://docs.modular.com/mojo/manual/structs", "title": "Structs", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/structs"}}

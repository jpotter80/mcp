{"chunk_id": "lifecycle-index-000", "document_id": "lifecycle-index", "content": "So far, we've explained how Mojo allows you to build high-performance code that\nis memory safe *without* manually managing memory, using Mojo's [ownership\nmodel](/mojo/manual/values/ownership). However, Mojo is designed for\n[systems programming](https://en.wikipedia.org/wiki/Systems_programming), which\noften requires manual memory management for custom data types. So, Mojo lets\nyou do that as you see fit. To be clear, Mojo has no reference counter and no\ngarbage collector.\n\nMojo also has no built-in data types with special privileges. All data types\nin the standard library (such as [`Bool`](/mojo/stdlib/builtin/bool/Bool),\n[`Int`](/mojo/stdlib/builtin/int/Int), and\n[`String`](/mojo/stdlib/collections/string/string/String)) are implemented as\n[structs](/mojo/manual/structs).", "position": 0, "token_count": 225, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-index-000", "document_id": "lifecycle-index", "position": 0, "token_count": 225, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "lifecycle/index.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle", "title": "Intro to value lifecycle", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle"}}
{"chunk_id": "lifecycle-index-001", "document_id": "lifecycle-index", "content": "What's great about the Mojo language is that it provides you these low-level\ntools for systems programming, but within a framework that helps you build\nthings that are safe and easy to use from higher-level programs. That is, you\ncan get under the hood and write all the \"unsafe\" code you want, but as long as\nyou do so in accordance with Mojo's [value\nsemantics](/mojo/manual/values/value-semantics), the programmer instantiating\nyour type/object doesn't need to think about memory management at all, and the\nbehavior will be safe and predictable, thanks to [value\nownership](/mojo/manual/values/ownership).\n\nIn summary, it's the responsibility of the type author to manage the memory and\nresources for each value type, by implementing specific lifecycle methods, such\nas the constructor, copy constructor, move constructor, and destructor, as\nnecessary. Mojo doesn't create any constructors by default, although it does\nadd a trivial, no-op destructor for types that don't define their own.", "position": 1, "token_count": 228, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-index-001", "document_id": "lifecycle-index", "position": 1, "token_count": 228, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/index.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle", "title": "Intro to value lifecycle", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle"}}
{"chunk_id": "lifecycle-index-002", "document_id": "lifecycle-index", "content": "In the following pages, we'll explain exactly how to define these lifecycle\nmethods in accordance with value semantics so your types play nicely with value\nownership.", "position": 2, "token_count": 33, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-index-002", "document_id": "lifecycle-index", "position": 2, "token_count": 33, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/index.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle", "title": "Intro to value lifecycle", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle"}}
{"chunk_id": "lifecycle-index-003", "document_id": "lifecycle-index", "content": "## Lifecycles and lifetimes\n\nFirst, let's clarify some terminology:\n\n* The \"lifecycle\" of a value is defined by various [dunder\n methods](/mojo/manual/structs#special-methods) in a struct.\n Each lifecycle event is handled by a different method,\n such as the constructor (`__init__()`), the destructor (`__del__()`), the copy\n constructor (`__copyinit__()`), and the move constructor (`__moveinit__()`).\n All values that are declared with the same type have the same lifecycle.", "position": 3, "token_count": 154, "has_code": false, "section_hierarchy": ["Lifecycles and lifetimes"], "metadata": {"chunk_id": "lifecycle-index-003", "document_id": "lifecycle-index", "position": 3, "token_count": 154, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Lifecycles and lifetimes"], "file_path": "lifecycle/index.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle", "title": "Intro to value lifecycle", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle#lifecycles-and-lifetimes"}}
{"chunk_id": "lifecycle-index-004", "document_id": "lifecycle-index", "content": "* The \"lifetime\" of a variable is defined by the span of time during\n program execution in which the variable is considered valid. The life of a\n variable begins when its value is initialized (via `__init__()`,\n `__copyinit__()` or `__moveinit__()`) and ends when the value is destroyed\n (`__del__()`), or consumed in some other way (for example, as part of a\n `__moveinit__()` call).\n\nNo two values have the exact same lifetime, because every value is created and\ndestroyed at a different point in time (even if the difference is imperceptible).\n\nnote Origin type\n\nThe concept of lifetimes is related to the `origin` type, a Mojo primitive\nused to track ownership. For most Mojo programming, you won't need to work with\n`origin` values directly. For information, see [Lifetimes, origins and\nreferences](/mojo/manual/values/lifetimes).", "position": 4, "token_count": 227, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-index-004", "document_id": "lifecycle-index", "position": 4, "token_count": 227, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/index.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle", "title": "Intro to value lifecycle", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle"}}
{"chunk_id": "lifecycle-index-005", "document_id": "lifecycle-index", "content": "The life of a value in Mojo begins when a variable is initialized and continues\nup until the value is last used, at which point Mojo destroys it. Mojo destroys\nevery value/object as soon as it's no longer used, using an “as soon as\npossible” (ASAP) destruction policy that runs after every sub-expression. The\nMojo compiler takes care of releasing resources after last use when needed.\n\nAs you might imagine, keeping track of a value's life can be difficult if a\nvalue is shared across functions many times during the life of a program.\nHowever, Mojo makes this predictable partly through its [value\nsemantics](/mojo/manual/values/value-semantics) and [value\nownership](/mojo/manual/values/ownership) (both prerequisite readings for\nthe following sections). The final piece of the puzzle for lifetime management\nis the value lifecycle: every value (defined in a struct) needs to implement\nkey lifecycle methods that define how a value is created and destroyed.", "position": 5, "token_count": 211, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-index-005", "document_id": "lifecycle-index", "position": 5, "token_count": 211, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "lifecycle/index.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle", "title": "Intro to value lifecycle", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle"}}

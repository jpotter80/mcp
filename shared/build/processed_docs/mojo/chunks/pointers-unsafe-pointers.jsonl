{"chunk_id": "pointers-unsafe-pointers-000", "document_id": "pointers-unsafe-pointers", "content": "The [`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer) type\nis one of several pointer types available in the standard library to indirectly\nreference locations in memory.\n\nYou can use an `UnsafePointer` to dynamically allocate and free memory, or to\npoint to memory allocated by some other piece of code. You can use these\npointers to write code that interacts with low-level interfaces, to interface\nwith other programming languages, or to build array-like data structures.\nBut as the name suggests, they're inherently *unsafe*. For example, when using\nunsafe pointers, you're responsible for ensuring that memory gets allocated and\nfreed correctly.\n\nIn general, you should prefer safe pointer types when possible, reserving\n`UnsafePointer` for those use cases where no other pointer type works.\nFor a comparison of standard library pointer types, see [Intro to\npointers](/mojo/manual/pointers/).\n\nnote LegacyUnsafePointer", "position": 0, "token_count": 214, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-000", "document_id": "pointers-unsafe-pointers", "position": 0, "token_count": 214, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-001", "document_id": "pointers-unsafe-pointers", "content": "note LegacyUnsafePointer\n\nThe implementation of `UnsafePointer` documented here replaces an earlier\nversion with a slightly different API. The old version has been renamed to\n[`LegacyUnsafePointer`](/mojo/stdlib/memory/legacy_unsafe_pointer/LegacyUnsafePointer/)\nand will be deprecated.\n\nThe [`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer)\nreference page briefly describes the differences between the new and old\nversions.\n\nTo ease this transition, the library currently supports implicit conversion\nbetween `LegacyUnsafePointer` and `UnsafePointer`, so you can pass a legacy\npointer to an `UnsafePointer` function, and vice versa.", "position": 1, "token_count": 163, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-001", "document_id": "pointers-unsafe-pointers", "position": 1, "token_count": 163, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-002", "document_id": "pointers-unsafe-pointers", "content": "To ease this transition, the library currently supports implicit conversion\nbetween `LegacyUnsafePointer` and `UnsafePointer`, so you can pass a legacy\npointer to an `UnsafePointer` function, and vice versa.\n\nFor more details on migrating to the new `UnsafePointer`, see the migration\nguide provided in the\n[UnsafePointer v2 proposal](https://github.com/modular/modular/blob/main/mojo/proposals/unsafe-pointer-v2.md#migration-guide-from-legacyunsafepointer-to-the-new-unsafepointer).", "position": 2, "token_count": 136, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-002", "document_id": "pointers-unsafe-pointers", "position": 2, "token_count": 136, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-003", "document_id": "pointers-unsafe-pointers", "content": "## Unsafe pointer basics\n\nAn `UnsafePointer` is a type that holds an address to memory. You can store\nand retrieve values in that memory. The `UnsafePointer` type is *generic*—it can\npoint to any type of value, and the value type is specified as a parameter. The\nvalue pointed to by a pointer is sometimes called a *pointee*.\n\n```mojo", "position": 3, "token_count": 84, "has_code": true, "section_hierarchy": ["Unsafe pointer basics"], "metadata": {"chunk_id": "pointers-unsafe-pointers-003", "document_id": "pointers-unsafe-pointers", "position": 3, "token_count": 84, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Unsafe pointer basics"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#unsafe-pointer-basics"}}
{"chunk_id": "pointers-unsafe-pointers-004", "document_id": "pointers-unsafe-pointers", "content": "# Allocate memory to hold a value\nvar ptr = alloc[Int](1)\n# Initialize the allocated memory\nptr.init_pointee_copy(100)\n```\n\n<figure>\n\n![](../images/pointer-diagram.png#light)\n![](../images/pointer-diagram-dark.png#dark)\n\n<figcaption><b>Figure 1.</b> Pointer and pointee</figcaption>\n</figure>\n\nAccessing the memory—to retrieve or update a value—is called\n*dereferencing* the pointer. You can dereference a pointer by following the\nvariable name with an empty pair of square brackets:\n\n```mojo\n# Update an initialized value\nptr[] += 10", "position": 4, "token_count": 175, "has_code": true, "section_hierarchy": ["Update an initialized value"], "metadata": {"chunk_id": "pointers-unsafe-pointers-004", "document_id": "pointers-unsafe-pointers", "position": 4, "token_count": 175, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Update an initialized value"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#update-an-initialized-value"}}
{"chunk_id": "pointers-unsafe-pointers-005", "document_id": "pointers-unsafe-pointers", "content": "# Access an initialized value\nprint(ptr[])\n```\n\n```output\n110\n```\n\nYou can also allocate memory to hold multiple values to build array-like\nstructures. For details, see\n[Storing multiple values](#storing-multiple-values).", "position": 5, "token_count": 62, "has_code": true, "section_hierarchy": ["Access an initialized value"], "metadata": {"chunk_id": "pointers-unsafe-pointers-005", "document_id": "pointers-unsafe-pointers", "position": 5, "token_count": 62, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Access an initialized value"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#access-an-initialized-value"}}
{"chunk_id": "pointers-unsafe-pointers-006", "document_id": "pointers-unsafe-pointers", "content": "## Lifecycle of a pointer\n\nAt any given time, a pointer can be in one of several states:\n\n- Uninitialized. Just like any variable, a variable of type `UnsafePointer` can\n be declared but uninitialized.\n\n ```mojo\n var ptr: UnsafePointer[Int, MutOrigin.external]\n ```\n\n- Null. A null pointer has an address of 0, indicating an invalid pointer.\n\n ```mojo\n ptr = {}\n ```\n\n- Pointing to allocated, uninitialized memory. The `alloc()` function\n returns a pointer to a newly-allocated block of memory with space for the\n specified number of elements of the pointee's type.\n\n ```mojo\n ptr = alloc[Int](1)", "position": 6, "token_count": 166, "has_code": true, "section_hierarchy": ["Lifecycle of a pointer"], "metadata": {"chunk_id": "pointers-unsafe-pointers-006", "document_id": "pointers-unsafe-pointers", "position": 6, "token_count": 166, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Lifecycle of a pointer"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#lifecycle-of-a-pointer"}}
{"chunk_id": "pointers-unsafe-pointers-007", "document_id": "pointers-unsafe-pointers", "content": "```\n\n Trying to dereference a pointer to uninitialized memory results in undefined\n behavior.\n\n- Pointing to initialized memory. You can initialize an allocated, uninitialized\n pointer by moving or copying an existing value into the memory. Or you can get\n a pointer to an existing value by calling the constructor with the `to`\n keyword argument.\n\n ```mojo\n ptr.init_pointee_copy(value)\n # or\n ptr.init_pointee_move(value^)\n # or\n ptr = UnsafePointer(to=value)\n ```\n\n Once the value is initialized, you can read or mutate it using the dereference\n syntax:\n\n ```mojo\n var oldValue = ptr[]\n ptr[] = newValue", "position": 7, "token_count": 169, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-007", "document_id": "pointers-unsafe-pointers", "position": 7, "token_count": 169, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-008", "document_id": "pointers-unsafe-pointers", "content": "```\n\n Once the value is initialized, you can read or mutate it using the dereference\n syntax:\n\n ```mojo\n var oldValue = ptr[]\n ptr[] = newValue\n ```\n\n- Dangling. When you free the pointer's allocated memory, you're left with a\n *dangling pointer*. The address still points to its previous location, but the\n memory is no longer allocated to this pointer. Trying to dereference the\n pointer, or calling any method that would access the memory location results\n in undefined behavior.\n\n ```mojo\n ptr.free()\n ```\n\nThe following diagram shows the lifecycle of an `UnsafePointer`:\n\n<figure>\n\n![](../images/pointer-lifecycle.png#light)\n![](../images/pointer-lifecycle-dark.png#dark)\n\n<figcaption><b>Figure 2.</b> Lifecycle of an <code>UnsafePointer</code></figcaption>\n</figure>", "position": 8, "token_count": 228, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-008", "document_id": "pointers-unsafe-pointers", "position": 8, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-009", "document_id": "pointers-unsafe-pointers", "content": "### Allocating memory\n\nUse the `alloc()` function to allocate memory. This function returns a new\npointer pointing to the requested memory. You can allocate space for one or\nmore values of the pointee's type.\n\n```mojo\nvar ptr = alloc[Int](10) # Allocate space for 10 Int values\n```\n\nThe allocated space is *uninitialized*—like a variable that's been declared but\nnot initialized.", "position": 9, "token_count": 106, "has_code": true, "section_hierarchy": ["Allocating memory"], "metadata": {"chunk_id": "pointers-unsafe-pointers-009", "document_id": "pointers-unsafe-pointers", "position": 9, "token_count": 106, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Allocating memory"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#allocating-memory"}}
{"chunk_id": "pointers-unsafe-pointers-010", "document_id": "pointers-unsafe-pointers", "content": "### Initializing the pointee\n\nTo initialize allocated memory, `UnsafePointer` provides the\n[`init_pointee_copy()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#init_pointee_copy)\nand [`init_pointee_move()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#init_pointee_move)\nmethods. For example:\n\n```mojo\nptr.init_pointee_copy(my_value)\n```\n\nTo move a value into the pointer's memory location, use\n`init_pointee_move()`:\n\n```mojo\nstr_ptr.init_pointee_move(my_string^)", "position": 10, "token_count": 177, "has_code": true, "section_hierarchy": ["Initializing the pointee"], "metadata": {"chunk_id": "pointers-unsafe-pointers-010", "document_id": "pointers-unsafe-pointers", "position": 10, "token_count": 177, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Initializing the pointee"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#initializing-the-pointee"}}
{"chunk_id": "pointers-unsafe-pointers-011", "document_id": "pointers-unsafe-pointers", "content": "```\n\nNote that to move the value, you usually need to add the transfer sigil\n(`^`), unless the value is a [trivial\ntype](/mojo/manual/types#register-passable-memory-only-and-trivial-types) (like\n`Int`) or a newly-constructed, \"owned\" value:\n\n```mojo\nstr_ptr.init_pointee_move(\"Owned string\")\n```\n\nAlternately, you can get a pointer to an existing value by calling the\n`UnsafePointer` constructor with the keyword `to` argument. This is useful for\ngetting a pointer to a value on the stack, for example.\n\n```mojo\nvar counter: Int = 5\nvar ptr = UnsafePointer(to=counter)\n```\n\nNote that when calling `UnsafePointer(to=value)`, you don't need to allocate\nmemory, since you're pointing to an existing value.", "position": 11, "token_count": 210, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-011", "document_id": "pointers-unsafe-pointers", "position": 11, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-012", "document_id": "pointers-unsafe-pointers", "content": "### Dereferencing pointers\n\nUse the `[]` dereference operator to access the value stored at a pointer (the\n\"pointee\").\n\n```mojo", "position": 12, "token_count": 41, "has_code": true, "section_hierarchy": ["Dereferencing pointers"], "metadata": {"chunk_id": "pointers-unsafe-pointers-012", "document_id": "pointers-unsafe-pointers", "position": 12, "token_count": 41, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Dereferencing pointers"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#dereferencing-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-013", "document_id": "pointers-unsafe-pointers", "content": "# Read from pointee\nprint(ptr[])\n# mutate pointee\nptr[] = 0\n```\n\n```output\n5\n```\n\nIf you've allocated space for multiple values, you can use subscript syntax to\naccess the values, as if they were an array, like `ptr[3]`. The empty subscript\n`[]` has the same meaning as `[0]`.\n\n[caution]\nThe dereference operator assumes that the memory being dereferenced is\ninitialized. Dereferencing uninitialized memory results in undefined behavior.\n\nYou cannot safely use the dereference operator on uninitialized memory, even to\n*initialize* a pointee. This is because assigning to a dereferenced pointer\ncalls lifecycle methods on the existing pointee (such as the destructor, move\nconstructor or copy constructor).\n\n```mojo\nvar str_ptr = alloc[String](1)", "position": 13, "token_count": 211, "has_code": true, "section_hierarchy": ["mutate pointee"], "metadata": {"chunk_id": "pointers-unsafe-pointers-013", "document_id": "pointers-unsafe-pointers", "position": 13, "token_count": 211, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mutate pointee"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#mutate-pointee"}}
{"chunk_id": "pointers-unsafe-pointers-014", "document_id": "pointers-unsafe-pointers", "content": "# str_ptr[] = \"Testing\" # Undefined behavior!\nstr_ptr.init_pointee_move(\"Testing\")\nstr_ptr[] += \" pointers\" # Works now\n```", "position": 14, "token_count": 56, "has_code": true, "section_hierarchy": ["str_ptr[] = \"Testing\" # Undefined behavior!"], "metadata": {"chunk_id": "pointers-unsafe-pointers-014", "document_id": "pointers-unsafe-pointers", "position": 14, "token_count": 56, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["str_ptr[] = \"Testing\" # Undefined behavior!"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#strptr--testing--undefined-behavior"}}
{"chunk_id": "pointers-unsafe-pointers-015", "document_id": "pointers-unsafe-pointers", "content": "### Destroying or removing values\n\nThe\n[`take_pointee()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#take_pointee)\nmethod moves the pointee from the memory location pointed to by `ptr`. This is\na consuming move—it invokes `__moveinit__()` on the destination value. It leaves\nthe memory location uninitialized.\n\nThe [`destroy_pointee()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#destroy_pointee)\nmethod calls the destructor on the pointee, and leaves the memory location\npointed to by `ptr` uninitialized.\n\nBoth `take_pointee()` and `destroy_pointee()` require that the pointer is\nnon-null, and the memory location contains a valid, initialized value of the\npointee's type; otherwise the function results in undefined behavior.", "position": 15, "token_count": 213, "has_code": false, "section_hierarchy": ["Destroying or removing values"], "metadata": {"chunk_id": "pointers-unsafe-pointers-015", "document_id": "pointers-unsafe-pointers", "position": 15, "token_count": 213, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Destroying or removing values"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#destroying-or-removing-values"}}
{"chunk_id": "pointers-unsafe-pointers-016", "document_id": "pointers-unsafe-pointers", "content": "The [`move_pointee_into(self, dst)`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#move_pointee_into)\nmethod moves the pointee from one pointer location to another. Both pointers\nmust be non-null. The source location must contain a valid, initialized value of\nthe pointee's type, and is left uninitialized after the call. The destination\nlocation is assumed to be uninitialized—if it contains a valid value, that\nvalue's destructor is not run. The value from the source location is moved to\nthe destination location as a consuming move. This function also has undefined\nbehavior if any of its prerequisites is not met.", "position": 16, "token_count": 161, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-016", "document_id": "pointers-unsafe-pointers", "position": 16, "token_count": 161, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-017", "document_id": "pointers-unsafe-pointers", "content": "### Freeing memory\n\nCalling [`free()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#free) on a\npointer frees the memory allocated by the pointer. It doesn't call the\ndestructors on any values stored in the memory—you need to do that explicitly\n(for example, using\n[`destroy_pointee()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#destroy_pointee) or\none of the other functions described in\n[Destroying or removing values](#destroying-or-removing-values)).\n\nDisposing of a pointer without freeing the associated memory can result in a\nmemory leak—where your program keeps taking more and more memory, because not\nall allocated memory is being freed.\n\nOn the other hand, if you have multiple copies of a pointer accessing the same\nmemory, you need to make sure you only call `free()` on one of them. Freeing the\nsame memory twice is also an error.", "position": 17, "token_count": 218, "has_code": false, "section_hierarchy": ["Freeing memory"], "metadata": {"chunk_id": "pointers-unsafe-pointers-017", "document_id": "pointers-unsafe-pointers", "position": 17, "token_count": 218, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Freeing memory"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#freeing-memory"}}
{"chunk_id": "pointers-unsafe-pointers-018", "document_id": "pointers-unsafe-pointers", "content": "On the other hand, if you have multiple copies of a pointer accessing the same\nmemory, you need to make sure you only call `free()` on one of them. Freeing the\nsame memory twice is also an error.\n\nAfter freeing a pointer's memory, you're left with a dangling pointer—its\naddress still points to the freed memory. Any attempt to access the memory,\nlike dereferencing the pointer results in undefined behavior.", "position": 18, "token_count": 95, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-018", "document_id": "pointers-unsafe-pointers", "position": 18, "token_count": 95, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-019", "document_id": "pointers-unsafe-pointers", "content": "## Storing multiple values\n\nAs mentioned in [Allocating memory](#allocating-memory), you can use an\n`UnsafePointer` to allocate memory for multiple values. The memory is allocated\nas a single, contiguous block. Pointers support arithmetic: adding an integer\nto a pointer returns a new pointer offset by the specified number of values from\nthe original pointer:\n\n```mojo\nvar third_ptr = first_ptr + 2\n```\n\nPointers also support subtraction, as well as in-place addition and subtraction:\n\n```mojo", "position": 19, "token_count": 122, "has_code": true, "section_hierarchy": ["Storing multiple values"], "metadata": {"chunk_id": "pointers-unsafe-pointers-019", "document_id": "pointers-unsafe-pointers", "position": 19, "token_count": 122, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Storing multiple values"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#storing-multiple-values"}}
{"chunk_id": "pointers-unsafe-pointers-020", "document_id": "pointers-unsafe-pointers", "content": "# Advance the pointer one element:\nptr += 1\n```\n\n<figure>\n\n![](../images/pointer-offset.png#light)\n![](../images/pointer-offset-dark.png#dark)\n\n<figcaption><b>Figure 3.</b> Pointer arithmetic</figcaption>\n</figure>\n\nFor example, the following example allocates memory to store 6 `Float64`\nvalues, and initializes them all to zero.\n\n```mojo\nvar float_ptr = alloc[Float64](6)\nfor offset in range(6):\n (float_ptr+offset).init_pointee_copy(0.0)\n```\n\nOnce the values are initialized, you can access them using subscript syntax:\n\n```mojo\nfloat_ptr[2] = 3.0\nfor offset in range(6):\n print(float_ptr[offset], end=\", \")\n```\n\n```output\n0.0, 0.0, 3.0, 0.0, 0.0, 0.0,\n```", "position": 20, "token_count": 252, "has_code": true, "section_hierarchy": ["Advance the pointer one element:"], "metadata": {"chunk_id": "pointers-unsafe-pointers-020", "document_id": "pointers-unsafe-pointers", "position": 20, "token_count": 252, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Advance the pointer one element:"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#advance-the-pointer-one-element"}}
{"chunk_id": "pointers-unsafe-pointers-021", "document_id": "pointers-unsafe-pointers", "content": "## `UnsafePointer` and origins\n\nThe `UnsafePointer` struct has an `origin` parameter to track the\norigin of the memory it points to.\n\nFor pointers initialized with the `to` keyword argument, the origin is set to\nthe origin of the pointee. For example, in the following code, `s_ptr.origin` is\nthe same as the origin of `s`:\n\n```mojo\ns = \"Testing\"\ns_ptr = UnsafePointer(to=s)", "position": 21, "token_count": 112, "has_code": true, "section_hierarchy": ["`UnsafePointer` and origins"], "metadata": {"chunk_id": "pointers-unsafe-pointers-021", "document_id": "pointers-unsafe-pointers", "position": 21, "token_count": 112, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`UnsafePointer` and origins"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#unsafepointer-and-origins"}}
{"chunk_id": "pointers-unsafe-pointers-022", "document_id": "pointers-unsafe-pointers", "content": "```\n\nWhen allocating memory with the `alloc()` function, the returned pointer has\nan `origin` value of `MutOrigin.external`. This value represents an origin that\nis mutable and does not _alias_ any existing value. (For example, it does not\npoint to the memory allocated for any other variable.) This memory isn't tracked\nby Mojo's lifetime checker, so you're responsible for freeing it.\n\nIf you're using a pointer in the implementation of a struct, you usually don't\nhave to worry about the origin, as long as the pointer isn't exposed outside of\nof the struct. For example, if you implement a static array type that allocates\nmemory in its constructor, deallocates it in its destructor, and doesn't expose\nthe pointer outside of the struct, the default origin is fine.", "position": 22, "token_count": 193, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-022", "document_id": "pointers-unsafe-pointers", "position": 22, "token_count": 193, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-023", "document_id": "pointers-unsafe-pointers", "content": "But if the struct exposes a pointer to that memory, you need to set the origin\nappropriately. For example, the `List` type has an `unsafe_ptr()` method that\nreturns an `UnsafePointer` to the underlying storage. In this case, the returned\npointer should share the origin of the list, since the list is the logical owner\nof the storage.\n\nThat method looks something like this:\n\n```mojo\nfn unsafe_ptr(\n ref self,\n) -> UnsafePointer[T, origin_of(self)]:\n\n return self.data.unsafe_origin_cast[origin_of(self)]()", "position": 23, "token_count": 140, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-023", "document_id": "pointers-unsafe-pointers", "position": 23, "token_count": 140, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-024", "document_id": "pointers-unsafe-pointers", "content": "```\n\nThis returns a copy of the original pointer, with the origin set to match the\norigin and mutability of the `self` value.\n\nA method like this is unsafe, but setting the correct origin makes it safer,\nsince the compiler knows that the pointer is referring to data owned by the\nlist.", "position": 24, "token_count": 65, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-024", "document_id": "pointers-unsafe-pointers", "position": 24, "token_count": 65, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-025", "document_id": "pointers-unsafe-pointers", "content": "## Working with foreign pointers\n\nWhen exchanging data with other programming languages, you may need to construct\nan `UnsafePointer` from a foreign pointer. Mojo restricts creating\n`UnsafePointer` instances from arbitrary addresses, to avoid users accidentally\ncreating pointers that *alias* each other (that is, two pointers that refer to\nthe same location). However, there are specific methods you can use to get an\n`UnsafePointer` from a Python or C/C++ pointer.\n\nWhen dealing with memory allocated elsewhere, you need to be aware of who's\nresponsible for freeing the memory. Freeing memory allocated elsewhere\ncan result in undefined behavior.\n\nWhen working with some foreign functions, you may need to supply a pointer with\nno specific type (a type-erased pointer, or \"void pointer\" in C/C++). This is\nequivalent to a Mojo `OpaquePointer`.\n\nYou also need to be aware of the format of the data stored in memory, including\ndata types and byte order. For more information, see\n[Converting data: bitcasting and byte order](#converting-data-bitcasting-and-byte-order).", "position": 25, "token_count": 242, "has_code": false, "section_hierarchy": ["Working with foreign pointers"], "metadata": {"chunk_id": "pointers-unsafe-pointers-025", "document_id": "pointers-unsafe-pointers", "position": 25, "token_count": 242, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Working with foreign pointers"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#working-with-foreign-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-026", "document_id": "pointers-unsafe-pointers", "content": "### Creating a Mojo pointer from a raw memory address\n\nYou can create a `UnsafePointer` from a raw memory address using the\n`unsafe_from_address` initializer.\n\n```mojo\nfn write_to_address(mmio_address: Int, value: Int32):\n var ptr = UnsafePointer[Int32, MutOrigin.external](\n unsafe_from_address=mmio_address\n )\n\n # Writing to a raw memory address may require a volatile load/store as the\n # operation may have side effects not visible to the compiler.\n # You can specify this using the `volatile` parameter.\n ptr.store[volatile = True](value)\n```\n\nThis is unsafe, as the caller must ensure the address is valid before writing to\nit, and that the memory is initialized before reading from it. The caller must\nalso ensure the pointer's origin and mutability is valid for the address,\nfailure to to do may result in undefined behavior.", "position": 26, "token_count": 210, "has_code": true, "section_hierarchy": ["Creating a Mojo pointer from a raw memory address"], "metadata": {"chunk_id": "pointers-unsafe-pointers-026", "document_id": "pointers-unsafe-pointers", "position": 26, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Creating a Mojo pointer from a raw memory address"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#creating-a-mojo-pointer-from-a-raw-memory-address"}}
{"chunk_id": "pointers-unsafe-pointers-027", "document_id": "pointers-unsafe-pointers", "content": "### Creating a Mojo pointer from a Python pointer\n\nThe `PythonObject` type defines an\n[`unsafe_get_as_pointer()`](/mojo/stdlib/python/python_object/PythonObject/#unsafe_get_as_pointer)\nmethod to construct an `UnsafePointer` from a Python address.\n\nFor example, the following code creates a NumPy array and then accesses the\ndata using a Mojo pointer:\n\n```mojo\nfrom python import Python\n\ndef share_array():\n np = Python.import_module(\"numpy\")\n arr = np.array(Python.list(1, 2, 3, 4, 5, 6, 7, 8, 9))\n ptr = arr.ctypes.data.unsafe_get_as_pointer[DType.int64]()\n for i in range(9):\n print(ptr[i], end=\", \")\n print()\n\ndef main():\n share_array()\n```\n\n```output\n1, 2, 3, 4, 5, 6, 7, 8, 9,", "position": 27, "token_count": 246, "has_code": true, "section_hierarchy": ["Creating a Mojo pointer from a Python pointer"], "metadata": {"chunk_id": "pointers-unsafe-pointers-027", "document_id": "pointers-unsafe-pointers", "position": 27, "token_count": 246, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Creating a Mojo pointer from a Python pointer"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#creating-a-mojo-pointer-from-a-python-pointer"}}
{"chunk_id": "pointers-unsafe-pointers-028", "document_id": "pointers-unsafe-pointers", "content": "```\n\n```output\n1, 2, 3, 4, 5, 6, 7, 8, 9,\n```\n\nThis example uses the NumPy\n[`ndarray.ctype`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.ctypes.html#numpy.ndarray.ctypes)\nattribute to access the raw pointer to the underlying storage\n(`ndarray.ctype.data`). The `unsafe_get_as_pointer()` method constructs an\n`UnsafePointer` to this address.", "position": 28, "token_count": 140, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-028", "document_id": "pointers-unsafe-pointers", "position": 28, "token_count": 140, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-029", "document_id": "pointers-unsafe-pointers", "content": "### Working with C/C++ pointers\n\nIf you call a C/C++ function that returns a pointer using the\n[`external_call`](/mojo/stdlib/sys/ffi/external_call) function, you can specify\nthe return type as an `UnsafePointer`, and Mojo will handle the type conversion\nfor you.\n\nNotably, the `origin` parameter when working across FFI boundaries should often\nbe set to `(MutOrigin/ImmutOrigin).external`, since the pointer points to memory\nexternal to the mojo program.\n\n```mojo\nfrom sys.ffi import external_call\n\ndef get_foreign_pointer() -> UnsafePointer[Int, MutOrigin.external]:\n var ptr = external_call[\n \"my_c_function\", # external function name\n UnsafePointer[Int, MutOrigin.external] # return type\n ]()\n return ptr\n```", "position": 29, "token_count": 207, "has_code": true, "section_hierarchy": ["Working with C/C++ pointers"], "metadata": {"chunk_id": "pointers-unsafe-pointers-029", "document_id": "pointers-unsafe-pointers", "position": 29, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Working with C/C++ pointers"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#working-with-cc-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-030", "document_id": "pointers-unsafe-pointers", "content": "### Opaque pointers\n\nThe `OpaquePointer` type is a pointer that does not have a specific type. In\nother languages, this is usually called a type-erased pointer or a void pointer.\nOpaque pointers are usually used when interfacing with non-Mojo code, such as a\nC library function that takes a void pointer.\n\n`OpaquePointer` is actually a type alias for `UnsafePointer[NoneType]`, so it\nhas the same API as any other `UnsafePointer`.\n\nYou can't dereference an opaque pointer, but you can cast it to a specific type\nusing the `bitcast()` method. Similarly, you can create an opaque pointer from\nan existing pointer by bitcasting to `NoneType`. For example:\n\n```mojo\nvar str = \"Hello, world!\"\nvar str_ptr = UnsafePointer(to=str)\nvar opaque_ptr = str_ptr.bitcast[NoneType]()", "position": 30, "token_count": 213, "has_code": true, "section_hierarchy": ["Opaque pointers"], "metadata": {"chunk_id": "pointers-unsafe-pointers-030", "document_id": "pointers-unsafe-pointers", "position": 30, "token_count": 213, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Opaque pointers"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#opaque-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-031", "document_id": "pointers-unsafe-pointers", "content": "# ... call some foreign function that takes a void pointer\n```", "position": 31, "token_count": 18, "has_code": true, "section_hierarchy": ["... call some foreign function that takes a void pointer"], "metadata": {"chunk_id": "pointers-unsafe-pointers-031", "document_id": "pointers-unsafe-pointers", "position": 31, "token_count": 18, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["... call some foreign function that takes a void pointer"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#-call-some-foreign-function-that-takes-a-void-pointer"}}
{"chunk_id": "pointers-unsafe-pointers-032", "document_id": "pointers-unsafe-pointers", "content": "## Converting data: bitcasting and byte order\n\nBitcasting a pointer returns a new pointer that has the same memory location,\nbut a new data type. This can be useful if you need to access different types of\ndata from a single area of memory. This can happen when you're reading binary\nfiles, like image files, or receiving data over the network.\n\nThe following sample processes a format that consists of chunks of data,\nwhere each chunk contains a variable number of 32-bit integers.\nEach chunk begins with an 8-bit integer that identifies the number of values\nin the chunk.", "position": 32, "token_count": 122, "has_code": false, "section_hierarchy": ["Converting data: bitcasting and byte order"], "metadata": {"chunk_id": "pointers-unsafe-pointers-032", "document_id": "pointers-unsafe-pointers", "position": 32, "token_count": 122, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Converting data: bitcasting and byte order"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#converting-data-bitcasting-and-byte-order"}}
{"chunk_id": "pointers-unsafe-pointers-033", "document_id": "pointers-unsafe-pointers", "content": "```mojo\ndef read_chunks(\n var ptr: UnsafePointer[mut=False, UInt8],\n) -> List[List[UInt32]]:\n chunks = List[List[UInt32]]()\n # A chunk size of 0 indicates the end of the data\n chunk_size = Int(ptr[])\n while (chunk_size > 0):\n # Skip the 1 byte chunk_size and get a pointer to the first\n # UInt32 in the chunk\n ui32_ptr = (ptr + 1).bitcast[UInt32]()\n chunk = List[UInt32](capacity=chunk_size)\n for i in range(chunk_size):\n chunk.append(ui32_ptr[i])\n chunks.append(chunk)\n # Move our pointer to the next byte after the current chunk\n ptr += (1 + 4 * chunk_size)\n # Read the size of the next chunk\n chunk_size = Int(ptr[])\n return chunks", "position": 33, "token_count": 223, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-033", "document_id": "pointers-unsafe-pointers", "position": 33, "token_count": 223, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-034", "document_id": "pointers-unsafe-pointers", "content": "```\n\nWhen dealing with data read in from a file or from the network, you may also\nneed to deal with byte order. Most systems use little-endian byte order (also\ncalled least-signficicant byte, or LSB) where the least-significant byte in a\nmultibyte value comes first. For example, the number 1001 can be represented in\nhexadecimal as 0x03E9, where E9 is the least-significant byte. Represented as a\n16-bit little-endian integer, the two bytes are ordered E9 03. As a 32-bit\ninteger, it would be represented as E9 03 00 00.", "position": 34, "token_count": 141, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-034", "document_id": "pointers-unsafe-pointers", "position": 34, "token_count": 141, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-035", "document_id": "pointers-unsafe-pointers", "content": "Big-endian or most-significant byte (MSB) ordering is the opposite: in the\n32-bit case, 00 00 03 E9. MSB ordering is frequently used in file formats and\nwhen transmitting data over the network. You can use the\n[`byte_swap()`](/mojo/stdlib/bit/bit/byte_swap) function to swap the byte\norder of a SIMD value from big-endian to little-endian or the reverse. For\nexample, if the method above was reading big-endian data, you'd just need to\nchange a single line:\n\n```mojo\nchunk.append(byte_swap(ui32_ptr[i]))", "position": 35, "token_count": 153, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-035", "document_id": "pointers-unsafe-pointers", "position": 35, "token_count": 153, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-036", "document_id": "pointers-unsafe-pointers", "content": "```", "position": 36, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-036", "document_id": "pointers-unsafe-pointers", "position": 36, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-037", "document_id": "pointers-unsafe-pointers", "content": "## Working with SIMD vectors\n\nThe `UnsafePointer` type includes\n[`load()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#load) and\n[`store()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#store) methods for\nperforming aligned loads and stores of scalar values. It also has methods\nsupporting strided load/store and gather/scatter.\n\nStrided load loads values from memory into a SIMD vector using an offset (the\n\"stride\") between successive memory addresses. This can be useful for\nextracting rows or columns from tabular data, or for extracting individual\nvalues from structured data. For example, consider the data for an RGB image,\nwhere each pixel is made up of three 8-bit values, for red, green, and blue. If\nyou want to access just the red values, you can use a strided load or store.\n\n<figure>", "position": 37, "token_count": 207, "has_code": false, "section_hierarchy": ["Working with SIMD vectors"], "metadata": {"chunk_id": "pointers-unsafe-pointers-037", "document_id": "pointers-unsafe-pointers", "position": 37, "token_count": 207, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Working with SIMD vectors"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#working-with-simd-vectors"}}
{"chunk_id": "pointers-unsafe-pointers-038", "document_id": "pointers-unsafe-pointers", "content": "<figure>\n\n![](../images/strided-load-storage.png#light)\n![](../images/strided-load-storage-dark.png#dark)\n\n<figcaption><b>Figure 4.</b> Strided load</figcaption>\n</figure>\n\nThe following function uses the\n[`strided_load()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#strided_load)\nand\n[`strided_store()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#strided_store)\nmethods to invert the red pixel values in an image, 8 values at a time. (Note\nthat this function only handles images where the number of pixels is evenly\ndivisible by eight.)", "position": 38, "token_count": 189, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-038", "document_id": "pointers-unsafe-pointers", "position": 38, "token_count": 189, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-039", "document_id": "pointers-unsafe-pointers", "content": "```mojo\ndef invert_red_channel(ptr: UnsafePointer[mut=True, UInt8], pixel_count: Int):\n # number of values loaded or stored at a time\n alias simd_width = 8\n # bytes per pixel, which is also the stride size\n bpp = 3\n for i in range(0, pixel_count * bpp, simd_width * bpp):\n red_values = ptr.offset(i).strided_load[width=simd_width](bpp)\n # Invert values and store them in their original locations\n ptr.offset(i).strided_store[width=simd_width](~red_values, bpp)", "position": 39, "token_count": 161, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-039", "document_id": "pointers-unsafe-pointers", "position": 39, "token_count": 161, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-040", "document_id": "pointers-unsafe-pointers", "content": "```\n\nThe [`gather()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#gather) and\n[`scatter()`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer#scatter) methods\nlet you load or store a set of values that are stored in arbitrary locations.\nYou do this by passing in a SIMD vector of *offsets* to the current pointer. For\nexample, when using `gather()`, the <var>n</var>th value in the vector is loaded\nfrom (pointer address) + <var>offset[n]</var>.", "position": 40, "token_count": 145, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-unsafe-pointers-040", "document_id": "pointers-unsafe-pointers", "position": 40, "token_count": 145, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers"}}
{"chunk_id": "pointers-unsafe-pointers-041", "document_id": "pointers-unsafe-pointers", "content": "## Safety\n\nUnsafe pointers are unsafe for several reasons:\n\n- Memory management is up to the user. You need to manually allocate\n and free memory, and/or be aware of when other APIs are allocating or freeing\n memory for you.\n\n- `UnsafePointer` values are *nullable*—that is, the pointer\n is not guaranteed to point to anything. And even when a pointer points to\n allocated memory, that memory may not be *initialized*.\n\n- `UnsafePointer` does have an `origin` parameter so Mojo can track the origin\n of the data it points to, but it also provides unsafe APIs. For example, when\n you do pointer arithmetic, the compiler doesn't do any bounds checking.", "position": 41, "token_count": 152, "has_code": false, "section_hierarchy": ["Safety"], "metadata": {"chunk_id": "pointers-unsafe-pointers-041", "document_id": "pointers-unsafe-pointers", "position": 41, "token_count": 152, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Safety"], "file_path": "pointers/unsafe-pointers.mdx", "url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers", "title": "Unsafe pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#safety"}}

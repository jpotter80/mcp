{"chunk_id": "variables-000", "document_id": "variables", "content": "A variable is a name that holds a value or object. All variables in Mojo are\nmutable—their value can be changed. (If you want to define a constant value that\ncan't change at runtime, see the\n[`alias` keyword](/mojo/manual/parameters/#alias-named-parameter-expressions).)\n\nWhen you declare a variable in Mojo, you allocate a logical storage location,\nand bind a name to that storage location.\n\n```mojo\nvar greeting: String = \"Hello World\"\n```\n\nThe `var` statement above does three things:\n\n- It declares a logical storage location (in this case, a storage location sized\n to hold a `String` struct).\n- It binds the name `greeting` to this logical storage location.\n- It *initializes* the storage space with a newly-created `String` value,\n with the text, “Hello World”. The new value is *owned by* the variable.\n No other variable can own this value unless we intentionally transfer it.", "position": 0, "token_count": 219, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-000", "document_id": "variables", "position": 0, "token_count": 219, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-001", "document_id": "variables", "content": "## Variable declarations\n\nMojo has two ways to declare a variable:\n\n* Explicitly-declared variables are created with the `var` keyword.\n\n ```mojo {doctest=\"foo\"}\n var a = 5\n var b: Float64 = 3.14\n var c: String\n ```\n\n* Implicitly-declared variables are created the first time the variable is used,\n either with an assignment statement, or with a type annotation:\n\n ```mojo\n a = 5\n b: Float64 = 3.14\n c: String\n ```\n\nBoth types of variables are strongly typed—the type is either set explicitly\nwith a [type annotation](#type-annotations) or implicitly when the variable is\nfirst initialized with a value.\n\nEither way, the variable receives a type when it's created, and the type never\nchanges. So you can't assign a variable a value of a different type:\n\n```mojo\ncount = 8 # count is type Int\ncount = \"Nine?\" # Error: can't implicitly convert 'StringLiteral' to 'Int'", "position": 1, "token_count": 229, "has_code": true, "section_hierarchy": ["Variable declarations"], "metadata": {"chunk_id": "variables-001", "document_id": "variables", "position": 1, "token_count": 229, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Variable declarations"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#variable-declarations"}}
{"chunk_id": "variables-002", "document_id": "variables", "content": "```\n\nSome types support [*implicit conversions*](#implicit-type-conversion) from\nother types. For example, an integer value can implicitly convert to a\nfloating-point value:\n\n```mojo\nvar temperature: Float64 = 99\nprint(temperature)\n```\n\n```output\n99.0\n```\n\nIn this example, the `temperature` variable is explicitly typed as `Float64`,\nbut assigned an integer value, so the value is implicitly converted to a\n`Float64`.", "position": 2, "token_count": 109, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-002", "document_id": "variables", "position": 2, "token_count": 109, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-003", "document_id": "variables", "content": "## Implicitly-declared variables\n\nYou can create a variable with just a name and a value. For example:\n\n```mojo\nname = \"Sam\"\nuser_id = 0\n```\n\nImplicitly-declared variables are strongly typed: they take the type from the\nfirst value assigned to them. For example, the `user_id` variable above is type\n`Int`, while the `name` variable is type `String`. You can't assign a string to\n`user_id` or an integer to `name`.\n\nYou can also use a type annotation with an implicitly-declared variable, either\nas part of an assignment statement, or on its own:\n\n```mojo\nname: String = \"Sam\"\nuser_id: Int", "position": 3, "token_count": 159, "has_code": true, "section_hierarchy": ["Implicitly-declared variables"], "metadata": {"chunk_id": "variables-003", "document_id": "variables", "position": 3, "token_count": 159, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implicitly-declared variables"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#implicitly-declared-variables"}}
{"chunk_id": "variables-004", "document_id": "variables", "content": "```\n\nHere the `user_id` variable has a type, but is uninitialized.\n\nImplicitly-declared variables are scoped at the function level. You create an\nimplicitly-declared variable the first time you assign a value to a given name\ninside a function. Any subsequent references to that name inside the function\nrefer to the same variable. For more information, see [Variable\nscopes](#variable-scopes), which describes how variable scoping differs between\nexplicitly- and implicitly-declared variables.", "position": 4, "token_count": 110, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-004", "document_id": "variables", "position": 4, "token_count": 110, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-005", "document_id": "variables", "content": "## Explicitly-declared variables\n\nYou can declare a variable with the `var` keyword. For example:\n\n```mojo\nvar name = \"Sam\"\nvar user_id: Int\n```\n\nThe `name` variable is initialized to the string \"Sam\". The `user_id` variable\nis uninitialized, but it has a declared type, `Int` for an integer value.\n\nSince variables are strongly typed, you can't assign a variable a\nvalue of a different type, unless those types can be\n[implicitly converted](#implicit-type-conversion). For example, this code will\nnot compile:\n\n```mojo\nvar user_id: Int = \"Sam\"\n```\n\nExplicitly-declared variables follow [lexical scoping](#variable-scopes), unlike\nimplicitly-declared variables.", "position": 5, "token_count": 178, "has_code": true, "section_hierarchy": ["Explicitly-declared variables"], "metadata": {"chunk_id": "variables-005", "document_id": "variables", "position": 5, "token_count": 178, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Explicitly-declared variables"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#explicitly-declared-variables"}}
{"chunk_id": "variables-006", "document_id": "variables", "content": "## Type annotations\n\nAlthough Mojo can infer a variable type from the first value assigned to a\nvariable, it also supports static type annotations on variables. Type\nannotations provide a more explicit way of specifying the variable's type.\n\nTo specify the type for a variable, add a colon followed by the type name:\n\n```mojo\nvar name: String = get_name()", "position": 6, "token_count": 85, "has_code": true, "section_hierarchy": ["Type annotations"], "metadata": {"chunk_id": "variables-006", "document_id": "variables", "position": 6, "token_count": 85, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Type annotations"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#type-annotations"}}
{"chunk_id": "variables-007", "document_id": "variables", "content": "# Or\nname: String = get_name()\n```\n\nThis makes it clear that `name` is type `String`, without knowing what the\n`get_name()` function returns. The `get_name()` function may return a `String`,\nor a value that's implicitly convertible to a `String`.\n\nIf a type has a constructor with just one argument, you can initialize it in\ntwo ways:\n\n```mojo\nvar name1: String = \"Sam\"\nvar name2 = String(\"Sam\")\nvar name3 = \"Sam\"\n```\n\nAll of these lines invoke the same constructor to create a `String` from a\n`StringLiteral`.", "position": 7, "token_count": 154, "has_code": true, "section_hierarchy": ["Or"], "metadata": {"chunk_id": "variables-007", "document_id": "variables", "position": 7, "token_count": 154, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Or"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#or"}}
{"chunk_id": "variables-008", "document_id": "variables", "content": "### Late initialization\n\nUsing type annotations allows for late initialization. For example, notice here\nthat the `z` variable is first declared with just a type, and the value is\nassigned later:\n\n```mojo\nfn my_function(x: Int):\n var z: Float32\n if x != 0:\n z = 1.0\n else:\n z = foo()\n print(z)\n\nfn foo() -> Float32:\n return 3.14\n```\n\nIf you try to pass an uninitialized variable to a function or use\nit on the right-hand side of an assignment statement, compilation fails.\n\n```mojo\nvar z: Float32\nvar y = z # Error: use of uninitialized value 'z'\n```\n\n[note]\nLate initialization works only if the variable is declared with a\ntype.", "position": 8, "token_count": 181, "has_code": true, "section_hierarchy": ["Late initialization"], "metadata": {"chunk_id": "variables-008", "document_id": "variables", "position": 8, "token_count": 181, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Late initialization"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#late-initialization"}}
{"chunk_id": "variables-009", "document_id": "variables", "content": "### Implicit type conversion\n\nSome types include built-in type conversion (type casting) from one type into\nits own type. For example, if you assign an integer to a variable that has a\nfloating-point type, it converts the value instead of giving a compiler error:\n\n```mojo\nvar number: Float64 = Int(1)\nprint(number)\n```\n\n```output\n1.0", "position": 9, "token_count": 86, "has_code": true, "section_hierarchy": ["Implicit type conversion"], "metadata": {"chunk_id": "variables-009", "document_id": "variables", "position": 9, "token_count": 86, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implicit type conversion"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#implicit-type-conversion"}}
{"chunk_id": "variables-010", "document_id": "variables", "content": "```\n\n```output\n1.0\n```\n\nAs shown above, value assignment can be converted into a constructor call if the\ntarget type has a constructor that meets the following criteria:\n\n- It's decorated with the `@implicit` decorator.\n\n- It takes a single required argument that matches the value being assigned.\n\nSo, this code uses the `Float64` constructor that takes an\ninteger: `__init__(out self, value: Int)`.\n\nIn general, implicit conversions should only be supported where the conversion\nis lossless.\n\nImplicit conversion follows the logic of [overloaded\nfunctions](/mojo/manual/functions#overloaded-functions). If the destination\ntype has a viable implicit conversion constructor for the source\ntype, it can be invoked for implicit conversion.\n\nSo assigning an integer to a `Float64` variable is exactly the same as this:\n\n```mojo\nvar number = Float64(1)", "position": 10, "token_count": 201, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-010", "document_id": "variables", "position": 10, "token_count": 201, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-011", "document_id": "variables", "content": "```\n\nSimilarly, if you call a function that requires an argument of a certain type\n(such as `Float64`), you can pass in any value as long as that value type can\nimplicitly convert to the required type (using one of the type's overloaded\nconstructors).\n\nFor example, you can pass an `Int` to a function that expects a `Float64`,\nbecause `Float64` includes an implicit conversion constructor that takes an\n`Int`:\n\n```mojo\nfn take_float(value: Float64):\n print(value)\n\nfn pass_integer():\n var value: Int = 1\n take_float(value)\n```\n\nFor more details on implicit conversion, see\n[Constructors and implicit\nconversion](/mojo/manual/lifecycle/life/#constructors-and-implicit-conversion).", "position": 11, "token_count": 182, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-011", "document_id": "variables", "position": 11, "token_count": 182, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-012", "document_id": "variables", "content": "## Variable scopes\n\nVariables declared with `var` are bound by *lexical scoping*. This\nmeans that nested code blocks can read and modify variables defined in an\nouter scope. But an outer scope **cannot** read variables defined in an\ninner scope at all.\n\nFor example, the `if` code block shown here creates an inner scope where outer\nvariables are accessible to read/write, but any new variables do not live\nbeyond the scope of the `if` block:\n\n```mojo\ndef lexical_scopes():\n var num = 1\n var dig = 1\n if num == 1:\n print(\"num:\", num) # Reads the outer-scope \"num\"\n var num = 2 # Creates new inner-scope \"num\"\n print(\"num:\", num) # Reads the inner-scope \"num\"\n dig = 2 # Updates the outer-scope \"dig\"\n print(\"num:\", num) # Reads the outer-scope \"num\"\n print(\"dig:\", dig) # Reads the outer-scope \"dig\"", "position": 12, "token_count": 239, "has_code": true, "section_hierarchy": ["Variable scopes"], "metadata": {"chunk_id": "variables-012", "document_id": "variables", "position": 12, "token_count": 239, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Variable scopes"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#variable-scopes"}}
{"chunk_id": "variables-013", "document_id": "variables", "content": "```\n\n```output\nnum: 1\nnum: 2\nnum: 1\ndig: 2", "position": 13, "token_count": 24, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-013", "document_id": "variables", "position": 13, "token_count": 24, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-014", "document_id": "variables", "content": "```\n\nNote that the `var` statement inside the `if` creates a **new** variable with\nthe same name as the outer variable. This prevents the inner loop from accessing\nthe outer `num` variable. (This is called \"variable shadowing,\" where the inner\nscope variable hides or \"shadows\" a variable from an outer scope.)\n\nThe lifetime of the inner `num` ends exactly where the `if` code block ends,\nbecause that's the scope in which the variable was defined.\n\nThis is in contrast to implicitly-declared variables (those without the `var`\nkeyword), which use **function-level scoping** (consistent with Python variable\nbehavior). That means, when you change the value of an implicitly-declared\nvariable inside the `if` block, it actually changes the value for the entire\nfunction.\n\nFor example, here's the same code but *without* the `var` declarations:", "position": 14, "token_count": 203, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-014", "document_id": "variables", "position": 14, "token_count": 203, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-015", "document_id": "variables", "content": "For example, here's the same code but *without* the `var` declarations:\n\n```mojo\ndef function_scopes():\n num = 1\n if num == 1:\n print(num) # Reads the function-scope \"num\"\n num = 2 # Updates the function-scope variable\n print(num) # Reads the function-scope \"num\"\n print(num) # Reads the function-scope \"num\"", "position": 15, "token_count": 101, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-015", "document_id": "variables", "position": 15, "token_count": 101, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-016", "document_id": "variables", "content": "```\n\n```output\n1\n2\n2\n```\n\nNow, the last `print()` function sees the updated `num` value from the inner\nscope, because implicitly-declared variables (Python-style variables) use function-level\nscope (instead of lexical scope).", "position": 16, "token_count": 63, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-016", "document_id": "variables", "position": 16, "token_count": 63, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-017", "document_id": "variables", "content": "## Copying and moving values\n\nRemember that a variable owns its value, and only one variable can own a given\nvalue at a time. To take this one step further, you can think of an assignment\nstatement as assigning *ownership* of a value to a variable:\n\n```mojo\nowning_variable = \"Owned value\"\n```\n\nThis means the value on the right-hand side of the assignment statement must be\ntransferrable to the new variable. Here's an example where that doesn't work:\n\n```mojo\nfirst = [1, 2, 3]\nsecond = first # error: 'List[Int]' is not implicitly copyable because it does\n # not conform to 'ImplicitlyCopyable'", "position": 17, "token_count": 151, "has_code": true, "section_hierarchy": ["Copying and moving values"], "metadata": {"chunk_id": "variables-017", "document_id": "variables", "position": 17, "token_count": 151, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Copying and moving values"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#copying-and-moving-values"}}
{"chunk_id": "variables-018", "document_id": "variables", "content": "```\n\nThe first assignment is no problem: the expression `[1, 2, 3]` creates a new\n`List` value that doesn't belong to any variable, so its ownership can be\ntransferred directly to the `first` variable.\n\nBut the second assignment causes an error. Since the `List` is owned by the\n`first` variable, it can't simply be transferred to the `second` variable\nwithout an explicit signal from the user. Does the user want to transfer the\nvalue from `first` to `second`? Or create a copy of the original value?\n\nThese choices depend on some features of the type of the values involved:\nspecifically, if the values are movable, copyable, or implicitly copyable.\n\n- A *copyable* type can be copied explicitly, by calling its `copy()` method.\n\n ```mojo\n second = first.copy()\n ```\n\n This leaves `first` unchanged and assigns `second` its own, uniquely owned copy\n of the list.\n\n- An *implicitly copyable* type can be copied without an explicit signal from\n the user.\n\n ```mojo\n one_value = 15\n another_value = one_value # implicit copy", "position": 18, "token_count": 250, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-018", "document_id": "variables", "position": 18, "token_count": 250, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-019", "document_id": "variables", "content": "```\n\n Here `one_value` is unchanged, and `another_value` gets a copy of the value.\n\n Implicitly copyable types are generally simple value types like `Int`,\n `Float64`, and `Bool` which can be copied trivially.\n\n- The ownership of a value can be be explicitly transferred from one variable\n to another by appending the *transfer sigil* (`^`) after the value to\n transfer:\n\n ```mojo\n second = first^\n ```\n\n This moves the value to `second`, and leaves `first` uninitialized.\n\n In many cases, this ownership transfer also involves moving the value from\n one memory location to another, which requires the value to be either movable\n or copyable.\n\nYou don't have to digest all of these details now: copyability and movabiltiy\nare discussed in more detail in the section on\n[making structs copyable and movable](/mojo/manual/structs#making-a-struct-copyable-and-movable)\nand in the section on the [value lifecycle](/mojo/manual/lifecycle/life).", "position": 19, "token_count": 247, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-019", "document_id": "variables", "position": 19, "token_count": 247, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}
{"chunk_id": "variables-020", "document_id": "variables", "content": "## Reference bindings\n\nSome APIs return\n[references](/mojo/manual/values/lifetimes#working-with-references) to values\nowned elsewhere. References can be useful to avoid copying values. For example,\nwhen you retrieve a value from a collection, the collection returns a reference,\ninstead of a copy.\n\n```mojo\nanimals: List[String] = [\"Cats\", \"Dogs, \"Zebras\"]\nprint(animals[2]) # Prints \"Zebras\", does not copy the value.\n```\n\nBut if you assign a reference to a *variable*, it creates a copy (if the value\nis implicitly copyable) or produces an error (if it isn't).\n\n```mojo\nitems = [99, 77, 33, 12]\nitem = items[1] # item is a copy of items[1]\nitem += 1 # increments item\nprint(items[1]) # prints 77", "position": 20, "token_count": 203, "has_code": true, "section_hierarchy": ["Reference bindings"], "metadata": {"chunk_id": "variables-020", "document_id": "variables", "position": 20, "token_count": 203, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Reference bindings"], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables#reference-bindings"}}
{"chunk_id": "variables-021", "document_id": "variables", "content": "```\n\nTo hold on to a reference, use the `ref` keyword to create a reference binding:\n\n```mojo\nref item_ref = items[1] # item_ref is a reference to item[1]\nitem_ref += 1 # increments items[1]\nprint(items[1]) # prints 78\n```\n\nHere the name `item_ref` is bound to the reference to `items[1]`. All reads and\nwrites to `item_ref` go to the referenced item.\n\nReference bindings can also be used when iterating through collections with\n[`for` loops](/mojo/manual/control-flow#iterating-using-references).\n\nOnce a reference binding is assigned, it can't be re-bound to a different\nlocation. For example:\n\n```mojo\nref item_ref = items[2] # error: invalid redefinition of item_ref\n```\n\nFor more information on references, see\n[Working with references](/mojo/manual/values/lifetimes#working-with-references).", "position": 21, "token_count": 234, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "variables-021", "document_id": "variables", "position": 21, "token_count": 234, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "variables.mdx", "url": "https://docs.modular.com/mojo/manual/variables", "title": "Variables", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/variables"}}

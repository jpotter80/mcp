{"chunk_id": "sql-data_types-typecasting-000", "document_id": "sql-data_types-typecasting", "content": "Typecasting is an operation that converts a value in one particular data type to the closest corresponding value in another data type.\nLike other SQL engines, DuckDB supports both implicit and explicit typecasting.\n\n## Explicit Casting\n\nExplicit typecasting is performed by using a `CAST` expression. For example, `CAST(col AS VARCHAR)` or `col::VARCHAR` explicitly cast the column `col` to `VARCHAR`. See the [cast page]({% link docs/stable/sql/expressions/cast.md %}) for more information.", "position": 0, "token_count": 126, "has_code": false, "section_hierarchy": ["Explicit Casting"], "metadata": {"chunk_id": "sql-data_types-typecasting-000", "document_id": "sql-data_types-typecasting", "position": 0, "token_count": 126, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Explicit Casting"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#explicit-casting"}}
{"chunk_id": "sql-data_types-typecasting-001", "document_id": "sql-data_types-typecasting", "content": "## Implicit Casting\n\nIn many situations, the system will add casts by itself. This is called *implicit* casting and happens, for example, when a function is called with an argument that does not match the type of the function but can be cast to the required type.\n\nImplicit casts can only be added for a number of type combinations, and is generally only possible when the cast cannot fail. For example, an implicit cast can be added from `INTEGER` to `DOUBLE` – but not from `DOUBLE` to `INTEGER`.\n\nConsider the function `sin(DOUBLE)`. This function takes as input argument a column of type `DOUBLE`, however, it can be called with an integer as well: `sin(1)`. The integer is converted into a double before being passed to the `sin` function.\n\n> Tip To check whether a type can be implicitly cast to another type, use the [`can_cast_implicitly` function]({% link docs/stable/sql/functions/utility.md %}#can_cast_implicitlysource_value-target_value).", "position": 1, "token_count": 235, "has_code": false, "section_hierarchy": ["Implicit Casting"], "metadata": {"chunk_id": "sql-data_types-typecasting-001", "document_id": "sql-data_types-typecasting", "position": 1, "token_count": 235, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Implicit Casting"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#implicit-casting"}}
{"chunk_id": "sql-data_types-typecasting-002", "document_id": "sql-data_types-typecasting", "content": "### Combination Casting\n\nWhen values of different types need to be combined to an unspecified joint parent type, the system will perform implicit casts to an automatically selected parent type. For example, `list_value(1::INT64, 1::UINT64)` creates a list of type `INT128[]`. The implicit casts performed in this situation are sometimes more lenient than regular implicit casts. For example, a `BOOL` value may be cast to `INT` (with `true` mapping to `1` and `false` to `0`) even though this is not possible for regular implicit casts.\n\nThis *combination casting* occurs for comparisons (`=` / ``), set operations (`UNION` / `EXCEPT` / `INTERSECT`), and nested type constructors (`list_value` / `[...]` / `MAP`).", "position": 2, "token_count": 193, "has_code": false, "section_hierarchy": ["Combination Casting"], "metadata": {"chunk_id": "sql-data_types-typecasting-002", "document_id": "sql-data_types-typecasting", "position": 2, "token_count": 193, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Combination Casting"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#combination-casting"}}
{"chunk_id": "sql-data_types-typecasting-003", "document_id": "sql-data_types-typecasting", "content": "## Casting Operations Matrix\n\nValues of a particular data type cannot always be cast to any arbitrary target data type. The only exception is the `NULL` value – which can always be converted between types.\nThe following matrix describes which conversions are supported.\nWhen implicit casting is allowed, it implies that explicit casting is also possible.\n\n![Typecasting matrix](/images/typecasting-matrix.png)\n\nEven though a casting operation is supported based on the source and target data type, it does not necessarily mean the cast operation will succeed at runtime.", "position": 3, "token_count": 116, "has_code": false, "section_hierarchy": ["Casting Operations Matrix"], "metadata": {"chunk_id": "sql-data_types-typecasting-003", "document_id": "sql-data_types-typecasting", "position": 3, "token_count": 116, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Casting Operations Matrix"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#casting-operations-matrix"}}
{"chunk_id": "sql-data_types-typecasting-004", "document_id": "sql-data_types-typecasting", "content": "Even though a casting operation is supported based on the source and target data type, it does not necessarily mean the cast operation will succeed at runtime.\n\n> Deprecated Prior to version 0.10.0, DuckDB allowed any type to be implicitly cast to `VARCHAR` during function binding.\n> Version 0.10.0 introduced a [breaking change which no longer allows implicit casts to `VARCHAR`]({% post_url 2024-02-13-announcing-duckdb-0100 %}#breaking-sql-changes).\n> The [`old_implicit_casting` configuration option]({% link docs/stable/configuration/pragmas.md %}#implicit-casting-to-varchar) setting can be used to revert to the old behavior.\n> However, please note that this flag will be deprecated in the future.", "position": 4, "token_count": 192, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-typecasting-004", "document_id": "sql-data_types-typecasting", "position": 4, "token_count": 192, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting"}}
{"chunk_id": "sql-data_types-typecasting-005", "document_id": "sql-data_types-typecasting", "content": "### Lossy Casts\n\nCasting operations that result in loss of precision are allowed. For example, it is possible to explicitly cast a numeric type with fractional digits – such as `DECIMAL`, `FLOAT` or `DOUBLE` – to an integral type like `INTEGER` or `BIGINT`. The number will be rounded.\n\n```sql\nSELECT CAST(3.1 AS INTEGER); -- 3\nSELECT CAST(3.5 AS INTEGER); -- 4\nSELECT CAST(-1.7 AS INTEGER); -- -2\n```", "position": 5, "token_count": 119, "has_code": true, "section_hierarchy": ["Lossy Casts"], "metadata": {"chunk_id": "sql-data_types-typecasting-005", "document_id": "sql-data_types-typecasting", "position": 5, "token_count": 119, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Lossy Casts"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#lossy-casts"}}
{"chunk_id": "sql-data_types-typecasting-006", "document_id": "sql-data_types-typecasting", "content": "### Overflows\n\nCasting operations that would result in a value overflow throw an error. For example, the value `999` is too large to be represented by the `TINYINT` data type. Therefore, an attempt to cast that value to that type results in a runtime error:\n\n```sql\nSELECT CAST(999 AS TINYINT);\n```\n\n```console\nConversion Error:\nType INT32 with value 999 can't be cast because the value is out of range for the destination type INT8\n```\n\nSo even though the cast operation from `INTEGER` to `TINYINT` is supported, it is not possible for this particular value. [TRY_CAST]({% link docs/stable/sql/expressions/cast.md %}) can be used to convert the value into `NULL` instead of throwing an error.", "position": 6, "token_count": 181, "has_code": true, "section_hierarchy": ["Overflows"], "metadata": {"chunk_id": "sql-data_types-typecasting-006", "document_id": "sql-data_types-typecasting", "position": 6, "token_count": 181, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Overflows"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#overflows"}}
{"chunk_id": "sql-data_types-typecasting-007", "document_id": "sql-data_types-typecasting", "content": "### Varchar\n\nThe [`VARCHAR`]({% link docs/stable/sql/data_types/text.md %}) type acts as a universal target: any arbitrary value of any arbitrary type can always be cast to the `VARCHAR` type. This type is also used for displaying values in the shell.\n\n```sql\nSELECT CAST(42.5 AS VARCHAR);\n```\n\nCasting from `VARCHAR` to another data type is supported, but can raise an error at runtime if DuckDB cannot parse and convert the provided text to the target data type.\n\n```sql\nSELECT CAST('NotANumber' AS INTEGER);\n```\n\nIn general, casting to `VARCHAR` is a lossless operation and any type can be cast back to the original type after being converted into text.\n\n```sql\nSELECT CAST(CAST([1, 2, 3] AS VARCHAR) AS INTEGER[]);\n```", "position": 7, "token_count": 215, "has_code": true, "section_hierarchy": ["Varchar"], "metadata": {"chunk_id": "sql-data_types-typecasting-007", "document_id": "sql-data_types-typecasting", "position": 7, "token_count": 215, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Varchar"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#varchar"}}
{"chunk_id": "sql-data_types-typecasting-008", "document_id": "sql-data_types-typecasting", "content": "### Literal Types\n\nInteger literals (such as `42`) and string literals (such as `'string'`) have special implicit casting rules. See the [literal types page]({% link docs/stable/sql/data_types/literal_types.md %}) for more information.\n\n### Lists / Arrays\n\nLists can be explicitly cast to other lists using the same casting rules. The cast is applied to the children of the list. For example, if we convert an `INTEGER[]` list to a `VARCHAR[]` list, the child `INTEGER` elements are individually cast to `VARCHAR` and a new list is constructed.\n\n```sql\nSELECT CAST([1, 2, 3] AS VARCHAR[]);\n```\n\n### Arrays\n\nArrays follow the same casting rules as lists. In addition, arrays can be implicitly cast to lists of the same type. For example, an `INTEGER[3]` array can be implicitly cast to an `INTEGER[]` list.", "position": 8, "token_count": 226, "has_code": true, "section_hierarchy": ["Arrays"], "metadata": {"chunk_id": "sql-data_types-typecasting-008", "document_id": "sql-data_types-typecasting", "position": 8, "token_count": 226, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Arrays"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#arrays"}}
{"chunk_id": "sql-data_types-typecasting-009", "document_id": "sql-data_types-typecasting", "content": "### Structs\n\nStructs can be cast to other structs as long as they share at least one field.\n\n> The rationale behind this requirement is to help avoid unintended errors. If two structs do not have any fields in common, then the cast was likely not intended.\n\n```sql\nSELECT CAST({'a': 42} AS STRUCT(a VARCHAR));\n```\n\nFields that exist in the target struct, but that do not exist in the source struct, default to `NULL`.\n\n```sql\nSELECT CAST({'a': 42} AS STRUCT(a VARCHAR, b VARCHAR));\n```\n\nFields that only exist in the source struct are ignored.\n\n```sql\nSELECT CAST({'a': 42, 'b': 43} AS STRUCT(a VARCHAR));", "position": 9, "token_count": 202, "has_code": true, "section_hierarchy": ["Structs"], "metadata": {"chunk_id": "sql-data_types-typecasting-009", "document_id": "sql-data_types-typecasting", "position": 9, "token_count": 202, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Structs"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#structs"}}
{"chunk_id": "sql-data_types-typecasting-010", "document_id": "sql-data_types-typecasting", "content": "```\n\nFields that only exist in the source struct are ignored.\n\n```sql\nSELECT CAST({'a': 42, 'b': 43} AS STRUCT(a VARCHAR));\n```\n\nThe names of the struct can also be in a different order. The fields of the struct will be reshuffled based on the names of the structs.\n\n```sql\nSELECT CAST({'a': 42, 'b': 84} AS STRUCT(b VARCHAR, a VARCHAR));", "position": 10, "token_count": 127, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-typecasting-010", "document_id": "sql-data_types-typecasting", "position": 10, "token_count": 127, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting"}}
{"chunk_id": "sql-data_types-typecasting-011", "document_id": "sql-data_types-typecasting", "content": "```\n\nFor [combination casting]({% link docs/stable/sql/data_types/typecasting.md %}#combination-casting), the fields of the resulting struct are the superset of all fields of the input structs.\nThis logic also applies recursively to potentially nested structs.\n\n```sql\nSELECT {'outer1': {'inner1': 42, 'inner2': 42}} AS c\nUNION\nSELECT {'outer1': {'inner2': 'hello', 'inner3': 'world'}, 'outer2': '100'} AS c;\n```\n\n```sql\nSELECT [{'a': 42}, {'b': 84}];\n```", "position": 11, "token_count": 173, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-typecasting-011", "document_id": "sql-data_types-typecasting", "position": 11, "token_count": 173, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting"}}
{"chunk_id": "sql-data_types-typecasting-012", "document_id": "sql-data_types-typecasting", "content": "### Unions\n\nUnion casting rules can be found on the [`UNION type page`]({% link docs/stable/sql/data_types/union.md %}#casting-to-unions).", "position": 12, "token_count": 49, "has_code": false, "section_hierarchy": ["Unions"], "metadata": {"chunk_id": "sql-data_types-typecasting-012", "document_id": "sql-data_types-typecasting", "position": 12, "token_count": 49, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Unions"], "file_path": "sql/data_types/typecasting.md", "url": "/sql/data_types/typecasting", "title": "Typecasting", "category": null, "tags": [], "section_url": "/sql/data_types/typecasting#unions"}}

{"chunk_id": "sql-data_types-struct-000", "document_id": "sql-data_types-struct", "content": "Conceptually, a `STRUCT` column contains an ordered list of columns called “entries”. The entries are referenced by name using strings. This document refers to those entry names as keys. Each row in the `STRUCT` column must have the same keys. The names of the struct entries are part of the *schema*. Each row in a `STRUCT` column must have the same layout. The names of the struct entries are case-insensitive.\n\n`STRUCT`s are typically used to nest multiple columns into a single column, and the nested column can be of any type, including other `STRUCT`s and `LIST`s.", "position": 0, "token_count": 149, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-000", "document_id": "sql-data_types-struct", "position": 0, "token_count": 149, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-001", "document_id": "sql-data_types-struct", "content": "`STRUCT`s are typically used to nest multiple columns into a single column, and the nested column can be of any type, including other `STRUCT`s and `LIST`s.\n\n`STRUCT`s are similar to PostgreSQL's `ROW` type. The key difference is that DuckDB `STRUCT`s require the same keys in each row of a `STRUCT` column. This allows DuckDB to provide significantly improved performance by fully utilizing its vectorized execution engine, and also enforces type consistency for improved correctness. DuckDB includes a `row` function as a special way to produce a `STRUCT`, but does not have a `ROW` data type. See an example below and the [`STRUCT` functions documentation]({% link docs/stable/sql/functions/struct.md %}) for details.\n\nSee the [data types overview]({% link docs/stable/sql/data_types/overview.md %}) for a comparison between nested data types.", "position": 1, "token_count": 232, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-001", "document_id": "sql-data_types-struct", "position": 1, "token_count": 232, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-002", "document_id": "sql-data_types-struct", "content": "## Creating Structs\n\nStructs can be created using the [`struct_pack(name := expr, ...)`]({% link docs/stable/sql/functions/struct.md %}) function, the equivalent array notation `{'name': expr, ...}`, using a row variable, or using the `row` function.\n\nCreate a struct using the `struct_pack` function. Note the lack of single quotes around the keys and the use of the `:=` operator:\n\n```sql\nSELECT struct_pack(key1 := 'value1', key2 := 42) AS s;\n```\n\nCreate a struct using the array notation:\n\n```sql\nSELECT {'key1': 'value1', 'key2': 42} AS s;\n```\n\nCreate a struct using a row variable:\n\n```sql\nSELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;", "position": 2, "token_count": 234, "has_code": true, "section_hierarchy": ["Creating Structs"], "metadata": {"chunk_id": "sql-data_types-struct-002", "document_id": "sql-data_types-struct", "position": 2, "token_count": 234, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Creating Structs"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#creating-structs"}}
{"chunk_id": "sql-data_types-struct-003", "document_id": "sql-data_types-struct", "content": "```\n\nCreate a struct using a row variable:\n\n```sql\nSELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;\n```\n\nCreate a struct of integers:\n\n```sql\nSELECT {'x': 1, 'y': 2, 'z': 3} AS s;\n```\n\nCreate a struct of strings with a `NULL` value:\n\n```sql\nSELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;\n```\n\nCreate a struct with a different type for each key:\n\n```sql\nSELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;", "position": 3, "token_count": 185, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-003", "document_id": "sql-data_types-struct", "position": 3, "token_count": 185, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-004", "document_id": "sql-data_types-struct", "content": "```\n\nCreate a struct of structs with `NULL` values:\n\n```sql\nSELECT {\n 'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},\n 'aliens': NULL,\n 'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}\n } AS s;\n```", "position": 4, "token_count": 116, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-004", "document_id": "sql-data_types-struct", "position": 4, "token_count": 116, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-005", "document_id": "sql-data_types-struct", "content": "## Adding or Updating Fields of Structs\n\nTo add new fields or update existing ones, you can use `struct_update`:\n\n```sql\nSELECT struct_update({'a': 1, 'b': 2}, b := 3, c := 4) AS s;\n```\n\nAlternatively, `struct_insert` also allows adding new fields but not updating existing ones.", "position": 5, "token_count": 95, "has_code": true, "section_hierarchy": ["Adding or Updating Fields of Structs"], "metadata": {"chunk_id": "sql-data_types-struct-005", "document_id": "sql-data_types-struct", "position": 5, "token_count": 95, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Adding or Updating Fields of Structs"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#adding-or-updating-fields-of-structs"}}
{"chunk_id": "sql-data_types-struct-006", "document_id": "sql-data_types-struct", "content": "## Retrieving from Structs\n\nRetrieving a value from a struct can be accomplished using dot notation, bracket notation, or through [struct functions]({% link docs/stable/sql/functions/struct.md %}) like `struct_extract`.\n\nUse dot notation to retrieve the value at a key's location. In the following query, the subquery generates a struct column `a`, which we then query with `a.x`.\n\n```sql\nSELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n```\n\nIf a key contains a space, simply wrap it in double quotes (`\"`).\n\n```sql\nSELECT a.\"x space\" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);", "position": 6, "token_count": 207, "has_code": true, "section_hierarchy": ["Retrieving from Structs"], "metadata": {"chunk_id": "sql-data_types-struct-006", "document_id": "sql-data_types-struct", "position": 6, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Retrieving from Structs"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#retrieving-from-structs"}}
{"chunk_id": "sql-data_types-struct-007", "document_id": "sql-data_types-struct", "content": "```\n\nBracket notation may also be used. Note that this uses single quotes (`'`) since the goal is to specify a certain string key and only constant expressions may be used inside the brackets (no expressions):\n\n```sql\nSELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);\n```\n\nThe `struct_extract` function is also equivalent. This returns 1:\n\n```sql\nSELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');\n```", "position": 7, "token_count": 148, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-007", "document_id": "sql-data_types-struct", "position": 7, "token_count": 148, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-008", "document_id": "sql-data_types-struct", "content": "### `unnest` / `STRUCT.*`\n\nRather than retrieving a single key from a struct, the `unnest` special function can be used to retrieve all keys from a struct as separate columns.\nThis is particularly useful when a prior operation creates a struct of unknown shape, or if a query must handle any potential struct keys:\n\n```sql\nSELECT unnest(a)\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);\n```\n\n| x | y | z |\n|--:|--:|--:|\n| 1 | 2 | 3 |\n\nThe same can be achieved with the star notation (`*`), which additionally allows [modifications of the returned columns]({% link docs/stable/sql/expressions/star.md %}):\n\n```sql\nSELECT a.* EXCLUDE ('y')\nFROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);", "position": 8, "token_count": 238, "has_code": true, "section_hierarchy": ["`unnest` / `STRUCT.*`"], "metadata": {"chunk_id": "sql-data_types-struct-008", "document_id": "sql-data_types-struct", "position": 8, "token_count": 238, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`unnest` / `STRUCT.*`"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#unnest--struct"}}
{"chunk_id": "sql-data_types-struct-009", "document_id": "sql-data_types-struct", "content": "```\n\n| x | z |\n|--:|--:|\n| 1 | 3 |\n\n> Warning The star notation is currently limited to top-level struct columns and non-aggregate expressions.", "position": 9, "token_count": 46, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-009", "document_id": "sql-data_types-struct", "position": 9, "token_count": 46, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-010", "document_id": "sql-data_types-struct", "content": "## Dot Notation Order of Operations\n\nReferring to structs with dot notation can be ambiguous with referring to schemas and tables. In general, DuckDB looks for columns first, then for struct keys within columns. DuckDB resolves references in these orders, using the first match to occur:\n\n### No Dots\n\n```sql\nSELECT part1\nFROM tbl;\n```\n\n1. `part1` is a column\n\n### One Dot\n\n```sql\nSELECT part1.part2\nFROM tbl;\n```\n\n1. `part1` is a table, `part2` is a column\n2. `part1` is a column, `part2` is a property of that column", "position": 10, "token_count": 151, "has_code": true, "section_hierarchy": ["One Dot"], "metadata": {"chunk_id": "sql-data_types-struct-010", "document_id": "sql-data_types-struct", "position": 10, "token_count": 151, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["One Dot"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#one-dot"}}
{"chunk_id": "sql-data_types-struct-011", "document_id": "sql-data_types-struct", "content": "### Two (or More) Dots\n\n```sql\nSELECT part1.part2.part3\nFROM tbl;\n```\n\n1. `part1` is a schema, `part2` is a table, `part3` is a column\n2. `part1` is a table, `part2` is a column, `part3` is a property of that column\n3. `part1` is a column, `part2` is a property of that column, `part3` is a property of that column\n\nAny extra parts (e.g., `.part4.part5`, etc.) are always treated as properties", "position": 11, "token_count": 142, "has_code": true, "section_hierarchy": ["Two (or More) Dots"], "metadata": {"chunk_id": "sql-data_types-struct-011", "document_id": "sql-data_types-struct", "position": 11, "token_count": 142, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Two (or More) Dots"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#two-or-more-dots"}}
{"chunk_id": "sql-data_types-struct-012", "document_id": "sql-data_types-struct", "content": "## Creating Structs with the `row` Function\n\nThe `row` function can be used to automatically convert multiple columns to a single struct column.\nWhen using `row` the keys will be empty strings allowing for easy insertion into a table with a struct column.\nColumns, however, cannot be initialized with the `row` function, and must be explicitly named.\nFor example, inserting values into a struct column using the `row` function:\n\n```sql\nCREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));\nINSERT INTO t1 VALUES (row('a', 42));\nSELECT * FROM t1;\n```\n\nThe table will contain a single entry:\n\n```sql\n{'v': a, 'i': 42}\n```\n\nThe following produces the same result as above:\n\n```sql\nCREATE TABLE t1 AS (\n SELECT row('a', 42)::STRUCT(v VARCHAR, i INTEGER)\n);", "position": 12, "token_count": 221, "has_code": true, "section_hierarchy": ["Creating Structs with the `row` Function"], "metadata": {"chunk_id": "sql-data_types-struct-012", "document_id": "sql-data_types-struct", "position": 12, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Creating Structs with the `row` Function"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#creating-structs-with-the-row-function"}}
{"chunk_id": "sql-data_types-struct-013", "document_id": "sql-data_types-struct", "content": "```\n\nThe following produces the same result as above:\n\n```sql\nCREATE TABLE t1 AS (\n SELECT row('a', 42)::STRUCT(v VARCHAR, i INTEGER)\n);\n```\n\nInitializing a struct column with the `row` function will fail:\n\n```sql\nCREATE TABLE t2 AS SELECT row('a');\n```\n\n```console\nInvalid Input Error:\nA table cannot be created from an unnamed struct\n```\n\nWhen casting between structs, the names of at least one field have to match. Therefore, the following query will fail:\n\n```sql\nSELECT a::STRUCT(y INTEGER) AS b\nFROM\n (SELECT {'x': 42} AS a);\n```\n\n```console\nBinder Error:\nSTRUCT to STRUCT cast must have at least one matching member", "position": 13, "token_count": 193, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-013", "document_id": "sql-data_types-struct", "position": 13, "token_count": 193, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-014", "document_id": "sql-data_types-struct", "content": "```\n\n```console\nBinder Error:\nSTRUCT to STRUCT cast must have at least one matching member\n```\n\nA workaround for this is to use [`struct_pack`](#creating-structs) instead:\n\n```sql\nSELECT struct_pack(y := a.x) AS b\nFROM\n (SELECT {'x': 42} AS a);\n```\n\nThe `row` function can be used to return unnamed structs. For example:\n\n```sql\nSELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;\n```\n\nThis produces `(1, 2, a)`.\n\nIf using multiple expressions when creating a struct, the `row` function is optional. The following query returns the same result as the previous one:\n\n```sql\nSELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);\n```", "position": 14, "token_count": 223, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-014", "document_id": "sql-data_types-struct", "position": 14, "token_count": 223, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-015", "document_id": "sql-data_types-struct", "content": "## Comparison and Ordering\n\nThe `STRUCT` type can be compared using all the [comparison operators]({% link docs/stable/sql/expressions/comparison_operators.md %}).\nThese comparisons can be used in [logical expressions]({% link docs/stable/sql/expressions/logical_operators.md %})\nsuch as `WHERE` and `HAVING` clauses, and return [`BOOLEAN` values]({% link docs/stable/sql/data_types/boolean.md %}).\n\nComparisons are done in lexicographical order, with individual entries being compared as usual except that `NULL` values are treated as larger than all other values.\n\nSpecifically:\n\n* If all values of `s1` and `s2` compare equal, then `s1` and `s2` compare equal.\n* else, if `s1.value[i] {'k3': 0, 'k1': 0};", "position": 15, "token_count": 212, "has_code": false, "section_hierarchy": ["Comparison and Ordering"], "metadata": {"chunk_id": "sql-data_types-struct-015", "document_id": "sql-data_types-struct", "position": 15, "token_count": 212, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Comparison and Ordering"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#comparison-and-ordering"}}
{"chunk_id": "sql-data_types-struct-016", "document_id": "sql-data_types-struct", "content": "```\n\nThe following queries return `false`:\n\n```sql\nSELECT {'k1': 1, 'k2': 0} {'k2': 0};\n```\n\n```sql\nSELECT {'k1': 0, 'k2': 0} {'k2': 0, 'k3': 0};\n```", "position": 16, "token_count": 85, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-struct-016", "document_id": "sql-data_types-struct", "position": 16, "token_count": 85, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct"}}
{"chunk_id": "sql-data_types-struct-017", "document_id": "sql-data_types-struct", "content": "## Updating the Schema\n\nStarting with DuckDB v1.3.0, it's possible to update the sub-schema of structs\nusing the [`ALTER TABLE` clause]({% link docs/stable/sql/statements/alter_table.md %}).\n\nTo follow the examples, initialize the `test` table as follows:\n\n```sql\nCREATE TABLE test (s STRUCT(i INTEGER, j INTEGER));\nINSERT INTO test VALUES (ROW(1, 1)), (ROW(2, 2));\n```\n\n### Adding a Field\n\nAdd field `k INTEGER` to struct `s` in table `test`:\n\n```sql\nALTER TABLE test ADD COLUMN s.k INTEGER;\nFROM test;\n```\n\n```text\n┌─────────────────────────────────────────┐\n│ s │\n│ struct(i integer, j integer, k integer) │\n├─────────────────────────────────────────┤\n│ {'i': 1, 'j': 1, 'k': NULL} │\n│ {'i': 2, 'j': 2, 'k': NULL} │\n└─────────────────────────────────────────┘\n```", "position": 17, "token_count": 242, "has_code": true, "section_hierarchy": ["Adding a Field"], "metadata": {"chunk_id": "sql-data_types-struct-017", "document_id": "sql-data_types-struct", "position": 17, "token_count": 242, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Adding a Field"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#adding-a-field"}}
{"chunk_id": "sql-data_types-struct-018", "document_id": "sql-data_types-struct", "content": "### Dropping a Field\n\nDrop field `i` from struct `s` in table `test`:\n\n```sql\nALTER TABLE test DROP COLUMN s.i;\nFROM test;\n```\n\n```text\n┌──────────────────────────────┐\n│ s │\n│ struct(j integer, k integer) │\n├──────────────────────────────┤\n│ {'j': 1, 'k': NULL} │\n│ {'j': 2, 'k': NULL} │\n└──────────────────────────────┘\n```\n\n### Renaming a Field\n\nRenaming field `j` of struct `s` to `v1` in table test`:\n\n```sql\nALTER TABLE test RENAME s.j TO v1;\nFROM test;\n```\n\n```text\n┌───────────────────────────────┐\n│ s │\n│ struct(v1 integer, k integer) │\n├───────────────────────────────┤\n│ {'v1': 1, 'k': NULL} │\n│ {'v1': 2, 'k': NULL} │\n└───────────────────────────────┘\n```", "position": 18, "token_count": 208, "has_code": true, "section_hierarchy": ["Renaming a Field"], "metadata": {"chunk_id": "sql-data_types-struct-018", "document_id": "sql-data_types-struct", "position": 18, "token_count": 208, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Renaming a Field"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#renaming-a-field"}}
{"chunk_id": "sql-data_types-struct-019", "document_id": "sql-data_types-struct", "content": "## Functions\n\nSee [Struct Functions]({% link docs/stable/sql/functions/struct.md %}).", "position": 19, "token_count": 34, "has_code": false, "section_hierarchy": ["Functions"], "metadata": {"chunk_id": "sql-data_types-struct-019", "document_id": "sql-data_types-struct", "position": 19, "token_count": 34, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Functions"], "file_path": "sql/data_types/struct.md", "url": "/sql/data_types/struct", "title": "Struct Data Type", "category": null, "tags": [], "section_url": "/sql/data_types/struct#functions"}}

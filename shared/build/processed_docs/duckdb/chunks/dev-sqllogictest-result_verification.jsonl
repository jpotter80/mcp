{"chunk_id": "dev-sqllogictest-result_verification-000", "document_id": "dev-sqllogictest-result_verification", "content": "The standard way of verifying results of queries is using the `query` statement, followed by the letter `I` times the number of columns that are expected in the result. After the query, four dashes (`----`) are expected followed by the result values separated by tabs. For example,\n\n```sql\nquery II\nSELECT 42, 84 UNION ALL SELECT 10, 20;\n----\n42\t84\n10\t20\n```\n\nFor legacy reasons the letters `R` and `T` are also accepted to denote columns.\n\n> Deprecated DuckDB deprecated the usage of types in the sqllogictest. The DuckDB test runner does not use or need them internally – therefore, only `I` should be used to denote columns.", "position": 0, "token_count": 161, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-000", "document_id": "dev-sqllogictest-result_verification", "position": 0, "token_count": 161, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification"}}
{"chunk_id": "dev-sqllogictest-result_verification-001", "document_id": "dev-sqllogictest-result_verification", "content": "## NULL Values and Empty Strings\n\nEmpty lines have special significance for the SQLLogic test runner: they signify an end of the current statement or query. For that reason, empty strings and NULL values have special syntax that must be used in result verification. NULL values should use the string `NULL`, and empty strings should use the string `(empty)`, e.g.:\n\n```sql\nquery II\nSELECT NULL, ''\n----\nNULL\n(empty)\n```", "position": 1, "token_count": 103, "has_code": true, "section_hierarchy": ["NULL Values and Empty Strings"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-001", "document_id": "dev-sqllogictest-result_verification", "position": 1, "token_count": 103, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["NULL Values and Empty Strings"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#null-values-and-empty-strings"}}
{"chunk_id": "dev-sqllogictest-result_verification-002", "document_id": "dev-sqllogictest-result_verification", "content": "## Error Verification\n\nIn order to signify that an error is expected, the `statement error` indicator can be used. The `statement error` also takes an optional expected result – which is interpreted as the *expected error message*. Similar to `query`, the expected error should be placed after the four dashes (`----`) following the query. The test passes if the error message *contains* the text under `statement error` – the entire error message does not need to be provided. It is recommended that you only use a subset of the error message, so that the test does not break unnecessarily if the formatting of error messages is changed.\n\n```sql\nstatement error\nSELECT * FROM non_existent_table;\n----\nTable with name non_existent_table does not exist!\n```", "position": 2, "token_count": 178, "has_code": true, "section_hierarchy": ["Error Verification"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-002", "document_id": "dev-sqllogictest-result_verification", "position": 2, "token_count": 178, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Error Verification"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#error-verification"}}
{"chunk_id": "dev-sqllogictest-result_verification-003", "document_id": "dev-sqllogictest-result_verification", "content": "## Regex\n\nIn certain cases result values might be very large or complex, and we might only be interested in whether or not the result *contains* a snippet of text. In that case, we can use the `:` modifier followed by a certain regex. If the result value matches the regex the test is passed. This is primarily used for query plan analysis.\n\n```sql\nquery II\nEXPLAIN SELECT tbl.a FROM 'data/parquet-testing/arrow/alltypes_plain.parquet' tbl(a) WHERE a = 1 OR a = 2\n----\nphysical_plan\t:.*PARQUET_SCAN.*Filters: a=1 OR a=2.*\n```\n\nIf we instead want the result *not* to contain a snippet of text, we can use the `:` modifier.", "position": 3, "token_count": 185, "has_code": true, "section_hierarchy": ["Regex"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-003", "document_id": "dev-sqllogictest-result_verification", "position": 3, "token_count": 185, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Regex"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#regex"}}
{"chunk_id": "dev-sqllogictest-result_verification-004", "document_id": "dev-sqllogictest-result_verification", "content": "## File\n\nAs results can grow quite large, and we might want to re-use results over multiple files, it is also possible to read expected results from files using the `` command. The expected result is read from the given file. As convention the file path should be provided as relative to the root of the GitHub repository.\n\n```sql\nquery I\nPRAGMA tpch(1)\n----\n:extension/tpch/dbgen/answers/sf1/q01.csv\n```\n\n## Row-Wise vs. Value-Wise Result Ordering\n\nThe result values of a query can be either supplied in row-wise order, with the individual values separated by tabs, or in value-wise order. In value wise order the individual *values* of the query must appear in row, column order each on an individual line. Consider the following example in both row-wise and value-wise order:\n\n```sql", "position": 4, "token_count": 201, "has_code": true, "section_hierarchy": ["Row-Wise vs. Value-Wise Result Ordering"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-004", "document_id": "dev-sqllogictest-result_verification", "position": 4, "token_count": 201, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Row-Wise vs. Value-Wise Result Ordering"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#row-wise-vs-value-wise-result-ordering"}}
{"chunk_id": "dev-sqllogictest-result_verification-005", "document_id": "dev-sqllogictest-result_verification", "content": "# row-wise\nquery II\nSELECT 42, 84 UNION ALL SELECT 10, 20;\n----\n42\t84\n10\t20", "position": 5, "token_count": 27, "has_code": false, "section_hierarchy": ["row-wise"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-005", "document_id": "dev-sqllogictest-result_verification", "position": 5, "token_count": 27, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["row-wise"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#row-wise"}}
{"chunk_id": "dev-sqllogictest-result_verification-006", "document_id": "dev-sqllogictest-result_verification", "content": "# value-wise\nquery II\nSELECT 42, 84 UNION ALL SELECT 10, 20;\n----\n42\n84\n10\n20\n```", "position": 6, "token_count": 30, "has_code": true, "section_hierarchy": ["value-wise"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-006", "document_id": "dev-sqllogictest-result_verification", "position": 6, "token_count": 30, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["value-wise"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#value-wise"}}
{"chunk_id": "dev-sqllogictest-result_verification-007", "document_id": "dev-sqllogictest-result_verification", "content": "## Hashes and Outputting Values\n\nBesides direct result verification, the sqllogic test suite also has the option of using MD5 hashes for value comparisons. A test using hashes for result verification looks like this:\n\n```sql\nquery I\nSELECT g, string_agg(x,',') FROM strings GROUP BY g\n----\n200 values hashing to b8126ea73f21372cdb3f2dc483106a12\n```\n\nThis approach is useful for reducing the size of tests when results have many output rows. However, it should be used sparingly, as hash values make the tests more difficult to debug if they do break.\n\nAfter it is ensured that the system outputs the correct result, hashes of the queries in a test file can be computed by adding `mode output_hash` to the test file. For example:\n\n```sql\nmode output_hash\n\nquery II\nSELECT 42, 84 UNION ALL SELECT 10, 20;\n----\n42\t84\n10\t20", "position": 7, "token_count": 220, "has_code": true, "section_hierarchy": ["Hashes and Outputting Values"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-007", "document_id": "dev-sqllogictest-result_verification", "position": 7, "token_count": 220, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Hashes and Outputting Values"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#hashes-and-outputting-values"}}
{"chunk_id": "dev-sqllogictest-result_verification-008", "document_id": "dev-sqllogictest-result_verification", "content": "```\n\nThe expected output hashes for every query in the test file will then be printed to the terminal, as follows:", "position": 8, "token_count": 28, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-008", "document_id": "dev-sqllogictest-result_verification", "position": 8, "token_count": 28, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification"}}
{"chunk_id": "dev-sqllogictest-result_verification-009", "document_id": "dev-sqllogictest-result_verification", "content": "```text\n================================================================================\nSQL Query\nSELECT 42, 84 UNION ALL SELECT 10, 20;\n================================================================================\n4 values hashing to 498c69da8f30c24da3bd5b322a2fd455", "position": 9, "token_count": 209, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-009", "document_id": "dev-sqllogictest-result_verification", "position": 9, "token_count": 209, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification"}}
{"chunk_id": "dev-sqllogictest-result_verification-010", "document_id": "dev-sqllogictest-result_verification", "content": "4 values hashing to 498c69da8f30c24da3bd5b322a2fd455\n================================================================================", "position": 10, "token_count": 112, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-010", "document_id": "dev-sqllogictest-result_verification", "position": 10, "token_count": 112, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification"}}
{"chunk_id": "dev-sqllogictest-result_verification-011", "document_id": "dev-sqllogictest-result_verification", "content": "```\n\nIn a similar manner, `mode output_result` can be used in order to force the program to print the result to the terminal for every query run in the test file.", "position": 11, "token_count": 41, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-011", "document_id": "dev-sqllogictest-result_verification", "position": 11, "token_count": 41, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification"}}
{"chunk_id": "dev-sqllogictest-result_verification-012", "document_id": "dev-sqllogictest-result_verification", "content": "## Result Sorting\n\nQueries can have an optional field that indicates that the result should be sorted in a specific manner. This field goes in the same location as the connection label. Because of that, connection labels and result sorting cannot be mixed.\n\nThe possible values of this field are `nosort`, `rowsort` and `valuesort`. An example of how this might be used is given below:\n\n```sql\nquery I rowsort\nSELECT 'world' UNION ALL SELECT 'hello'\n----\nhello\nworld\n```\n\nIn general, we prefer not to use this field and rely on `ORDER BY` in the query to generate deterministic query answers. However, existing sqllogictests use this field extensively, hence it is important to know of its existence.", "position": 12, "token_count": 162, "has_code": true, "section_hierarchy": ["Result Sorting"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-012", "document_id": "dev-sqllogictest-result_verification", "position": 12, "token_count": 162, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Result Sorting"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#result-sorting"}}
{"chunk_id": "dev-sqllogictest-result_verification-013", "document_id": "dev-sqllogictest-result_verification", "content": "## Query Labels\n\nAnother feature that can be used for result verification are `query labels`. These can be used to verify that different queries provide the same result. This is useful for comparing queries that are logically equivalent, but formulated differently. Query labels are provided after the connection label or sorting specifier.\n\nQueries that have a query label do not need to have a result provided. Instead, the results of each of the queries with the same label are compared to each other. For example, the following script verifies that the queries `SELECT 42+1` and `SELECT 44-1` provide the same result:\n\n```sql\nquery I nosort r43\nSELECT 42+1;\n----\n\nquery I nosort r43\nSELECT 44-1;\n----\n```", "position": 13, "token_count": 170, "has_code": true, "section_hierarchy": ["Query Labels"], "metadata": {"chunk_id": "dev-sqllogictest-result_verification-013", "document_id": "dev-sqllogictest-result_verification", "position": 13, "token_count": 170, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Query Labels"], "file_path": "dev/sqllogictest/result_verification.md", "url": "/dev/sqllogictest/result_verification", "title": "Result Verification", "category": null, "tags": [], "section_url": "/dev/sqllogictest/result_verification#query-labels"}}

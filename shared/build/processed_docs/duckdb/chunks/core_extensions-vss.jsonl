{"chunk_id": "core_extensions-vss-000", "document_id": "core_extensions-vss", "content": "The `vss` extension is an experimental extension for DuckDB that adds indexing support to accelerate vector similarity search queries using DuckDB's new fixed-size `ARRAY` type.\n\nSee the [announcement blog post]({% post_url 2024-05-03-vector-similarity-search-vss %}) and the [“What's New in the Vector Similarity Search Extension?” post]({% post_url 2024-10-23-whats-new-in-the-vss-extension %}).", "position": 0, "token_count": 122, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-000", "document_id": "core_extensions-vss", "position": 0, "token_count": 122, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-001", "document_id": "core_extensions-vss", "content": "## Usage\n\nTo create a new HNSW (Hierarchical Navigable Small Worlds) index on a table with an `ARRAY` column, use the `CREATE INDEX` statement with the `USING HNSW` clause. For example:\n\n```sql\nINSTALL vss;\nLOAD vss;\n\nCREATE TABLE my_vector_table (vec FLOAT[3]);\nINSERT INTO my_vector_table\n SELECT array_value(a, b, c)\n FROM range(1, 10) ra(a), range(1, 10) rb(b), range(1, 10) rc(c);\nCREATE INDEX my_hnsw_index ON my_vector_table USING HNSW (vec);\n```\n\nThe index will then be used to accelerate queries that use an `ORDER BY` clause evaluating one of the supported distance metric functions against the indexed columns and a constant vector, followed by a `LIMIT` clause. For example:\n\n```sql\nSELECT *\nFROM my_vector_table\nORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3])\nLIMIT 3;", "position": 1, "token_count": 240, "has_code": true, "section_hierarchy": ["Usage"], "metadata": {"chunk_id": "core_extensions-vss-001", "document_id": "core_extensions-vss", "position": 1, "token_count": 240, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Usage"], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss#usage"}}
{"chunk_id": "core_extensions-vss-002", "document_id": "core_extensions-vss", "content": "```\n\nAdditionally, the overloaded `min_by(col, arg, n)` can also be accelerated with the `HNSW` index if the `arg` argument is a matching distance metric function. This can be used to do quick one-shot nearest neighbor searches. For example, to get the top 3 rows with the closest vectors to `[1, 2, 3]`:\n\n```sql\nSELECT min_by(my_vector_table, array_distance(vec, [1, 2, 3]::FLOAT[3]), 3 ORDER BY vec) AS result\nFROM my_vector_table;\n```\n\n```text\n[{'vec': [1.0, 2.0, 3.0]}, {'vec': [2.0, 2.0, 3.0]}, {'vec': [1.0, 2.0, 4.0]}]", "position": 2, "token_count": 210, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-002", "document_id": "core_extensions-vss", "position": 2, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-003", "document_id": "core_extensions-vss", "content": "```\n\nNote how we pass the table name as the first argument to [`min_by`]({% link docs/stable/sql/functions/aggregates.md %}#min_byarg-val-n) to return a struct containing the entire matched row.\n\nWe can verify that the index is being used by checking the `EXPLAIN` output and looking for the `HNSW_INDEX_SCAN` node in the plan:\n\n```sql\nEXPLAIN\nSELECT *\nFROM my_vector_table\nORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3])\nLIMIT 3;", "position": 3, "token_count": 139, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-003", "document_id": "core_extensions-vss", "position": 3, "token_count": 139, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-004", "document_id": "core_extensions-vss", "content": "```\n\n```text\n┌───────────────────────────┐\n│ PROJECTION │\n│ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │\n│ #0 │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│ PROJECTION │\n│ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │\n│ vec │\n│array_distance(vec, [1.0, 2│\n│ .0, 3.0]) │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│ HNSW_INDEX_SCAN │\n│ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │\n│ t1 (HNSW INDEX SCAN : │\n│ my_idx) │\n│ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │\n│ vec │\n│ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │\n│ EC: 3 │\n└───────────────────────────┘", "position": 4, "token_count": 156, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-004", "document_id": "core_extensions-vss", "position": 4, "token_count": 156, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-005", "document_id": "core_extensions-vss", "content": "```\n\nBy default the HNSW index will be created using the euclidean distance `l2sq` (L2-norm squared) metric, matching DuckDBs `array_distance` function, but other distance metrics can be used by specifying the `metric` option during index creation. For example:\n\n```sql\nCREATE INDEX my_hnsw_cosine_index\nON my_vector_table\nUSING HNSW (vec)\nWITH (metric = 'cosine');", "position": 5, "token_count": 110, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-005", "document_id": "core_extensions-vss", "position": 5, "token_count": 110, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-006", "document_id": "core_extensions-vss", "content": "```\n\nThe following table shows the supported distance metrics and their corresponding DuckDB functions\n\n| Metric | Function | Description |\n|----------|--------------------------------|----------------------------|\n| `l2sq` | `array_distance` | Euclidean distance |\n| `cosine` | `array_cosine_distance` | Cosine similarity distance |\n| `ip` | `array_negative_inner_product` | Negative inner product |\n\nNote that while each `HNSW` index only applies to a single column you can create multiple `HNSW` indexes on the same table each individually indexing a different column. Additionally, you can also create multiple `HNSW` indexes to the same column, each supporting a different distance metric.", "position": 6, "token_count": 225, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-006", "document_id": "core_extensions-vss", "position": 6, "token_count": 225, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-007", "document_id": "core_extensions-vss", "content": "## Index Options\n\nBesides the `metric` option, the `HNSW` index creation statement also supports the following options to control the hyperparameters of the index construction and search process:", "position": 7, "token_count": 42, "has_code": false, "section_hierarchy": ["Index Options"], "metadata": {"chunk_id": "core_extensions-vss-007", "document_id": "core_extensions-vss", "position": 7, "token_count": 42, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Index Options"], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss#index-options"}}
{"chunk_id": "core_extensions-vss-008", "document_id": "core_extensions-vss", "content": "| Option | Default | Description |\n|-------|--:|----------------------------|\n| `ef_construction` | 128 | The number of candidate vertices to consider during the construction of the index. A higher value will result in a more accurate index, but will also increase the time it takes to build the index. |\n| `ef_search` | 64 | The number of candidate vertices to consider during the search phase of the index. A higher value will result in a more accurate index, but will also increase the time it takes to perform a search. |\n| `M` | 16 | The maximum number of neighbors to keep for each vertex in the graph. A higher value will result in a more accurate index, but will also increase the time it takes to build the index. |", "position": 8, "token_count": 196, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-008", "document_id": "core_extensions-vss", "position": 8, "token_count": 196, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-009", "document_id": "core_extensions-vss", "content": "| `M` | 16 | The maximum number of neighbors to keep for each vertex in the graph. A higher value will result in a more accurate index, but will also increase the time it takes to build the index. |\n| `M0` | 2 * `M` | The base connectivity, or the number of neighbors to keep for each vertex in the zero-th level of the graph. A higher value will result in a more accurate index, but will also increase the time it takes to build the index. |", "position": 9, "token_count": 109, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-009", "document_id": "core_extensions-vss", "position": 9, "token_count": 109, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-010", "document_id": "core_extensions-vss", "content": "Additionally, you can also override the `ef_search` parameter set at index construction time by setting the `SET hnsw_ef_search = ⟨int⟩`{:.language-sql .highlight} configuration option at runtime. This can be useful if you want to trade search performance for accuracy or vice-versa on a per-connection basis. You can also unset the override by calling `RESET hnsw_ef_search`{:.language-sql .highlight}.", "position": 10, "token_count": 110, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-010", "document_id": "core_extensions-vss", "position": 10, "token_count": 110, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-011", "document_id": "core_extensions-vss", "content": "## Persistence\n\nDue to some known issues related to persistence of custom extension indexes, the `HNSW` index can only be created on tables in in-memory databases by default, unless the `SET hnsw_enable_experimental_persistence = ⟨bool⟩`{:.language-sql .highlight} configuration option is set to `true`.\n\nThe reasoning for locking this feature behind an experimental flag is that “WAL” recovery is not yet properly implemented for custom indexes, meaning that if a crash occurs or the database is shut down unexpectedly while there are uncommitted changes to a `HNSW`-indexed table, you can end up with **data loss or corruption of the index**.\n\nIf you enable this option and experience an unexpected shutdown, you can try to recover the index by first starting DuckDB separately, loading the `vss` extension and then `ATTACH`ing the database file, which ensures that the `HNSW` index functionality is available during WAL-playback, allowing DuckDB's recovery process to proceed without issues. But we still recommend that you do not use this feature in production environments.", "position": 11, "token_count": 240, "has_code": false, "section_hierarchy": ["Persistence"], "metadata": {"chunk_id": "core_extensions-vss-011", "document_id": "core_extensions-vss", "position": 11, "token_count": 240, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Persistence"], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss#persistence"}}
{"chunk_id": "core_extensions-vss-012", "document_id": "core_extensions-vss", "content": "With the `hnsw_enable_experimental_persistence` option enabled, the index will be persisted into the DuckDB database file (if you run DuckDB with a disk-backed database file), which means that after a database restart, the index can be loaded back into memory from disk instead of having to be re-created. With that in mind, there are no incremental updates to persistent index storage, so every time DuckDB performs a checkpoint the entire index will be serialized to disk and overwrite itself. Similarly, after a restart of the database, the index will be deserialized back into main memory in its entirety. Although this will be deferred until you first access the table associated with the index. Depending on how large the index is, the deserialization process may take some time, but it should still be faster than simply dropping and re-creating the index.", "position": 12, "token_count": 185, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-012", "document_id": "core_extensions-vss", "position": 12, "token_count": 185, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-013", "document_id": "core_extensions-vss", "content": "## Inserts, Updates, Deletes and Re-Compaction\n\nThe HNSW index does support inserting, updating and deleting rows from the table after index creation. However, there are two things to keep in mind:\n\n* It's faster to create the index after the table has been populated with data as the initial bulk load can make better use of parallelism on large tables.\n* Deletes are not immediately reflected in the index, but are instead “marked” as deleted, which can cause the index to grow stale over time and negatively impact query quality and performance.\n\nTo remedy the last point, you can call the `PRAGMA hnsw_compact_index('⟨index_name⟩')`{:.language-sql .highlight} pragma function to trigger a re-compaction of the index pruning deleted items, or re-create the index after a significant number of updates.", "position": 13, "token_count": 197, "has_code": false, "section_hierarchy": ["Inserts, Updates, Deletes and Re-Compaction"], "metadata": {"chunk_id": "core_extensions-vss-013", "document_id": "core_extensions-vss", "position": 13, "token_count": 197, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Inserts, Updates, Deletes and Re-Compaction"], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss#inserts-updates-deletes-and-re-compaction"}}
{"chunk_id": "core_extensions-vss-014", "document_id": "core_extensions-vss", "content": "## Bonus: Vector Similarity Search Joins\n\nThe `vss` extension also provides a couple of table macros to simplify matching multiple vectors against each other, so called \"fuzzy joins\". These are:\n\n* `vss_join(left_table, right_table, left_col, right_col, k, metric := 'l2sq')`\n* `vss_match(right_table\", left_col, right_col, k, metric := 'l2sq')`\n\nThese **do not** currently make use of the `HNSW` index but are provided as convenience utility functions for users who are ok with performing brute-force vector similarity searches without having to write out the join logic themselves. In the future these might become targets for index-based optimizations as well.\n\nThese functions can be used as follows:\n\n```sql\nCREATE TABLE haystack (id int, vec FLOAT[3]);\nCREATE TABLE needle (search_vec FLOAT[3]);", "position": 14, "token_count": 220, "has_code": true, "section_hierarchy": ["Bonus: Vector Similarity Search Joins"], "metadata": {"chunk_id": "core_extensions-vss-014", "document_id": "core_extensions-vss", "position": 14, "token_count": 220, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Bonus: Vector Similarity Search Joins"], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss#bonus-vector-similarity-search-joins"}}
{"chunk_id": "core_extensions-vss-015", "document_id": "core_extensions-vss", "content": "These functions can be used as follows:\n\n```sql\nCREATE TABLE haystack (id int, vec FLOAT[3]);\nCREATE TABLE needle (search_vec FLOAT[3]);\n\nINSERT INTO haystack\n SELECT row_number() OVER (), array_value(a, b, c)\n FROM range(1, 10) ra(a), range(1, 10) rb(b), range(1, 10) rc(c);\n\nINSERT INTO needle\n VALUES ([5, 5, 5]), ([1, 1, 1]);\n\nSELECT *\nFROM vss_join(needle, haystack, search_vec, vec, 3) res;", "position": 15, "token_count": 154, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-015", "document_id": "core_extensions-vss", "position": 15, "token_count": 154, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-016", "document_id": "core_extensions-vss", "content": "```", "position": 16, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-016", "document_id": "core_extensions-vss", "position": 16, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-017", "document_id": "core_extensions-vss", "content": "```text\n┌───────┬─────────────────────────────────┬─────────────────────────────────────┐\n│ score │ left_tbl │ right_tbl │\n│ float │ struct(search_vec float[3]) │ struct(id integer, vec float[3]) │\n├───────┼─────────────────────────────────┼─────────────────────────────────────┤\n│ 0.0 │ {'search_vec': [5.0, 5.0, 5.0]} │ {'id': 365, 'vec': [5.0, 5.0, 5.0]} │\n│ 1.0 │ {'search_vec': [5.0, 5.0, 5.0]} │ {'id': 364, 'vec': [5.0, 4.0, 5.0]} │\n│ 1.0 │ {'search_vec': [5.0, 5.0, 5.0]} │ {'id': 356, 'vec': [4.0, 5.0, 5.0]} │", "position": 17, "token_count": 219, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-017", "document_id": "core_extensions-vss", "position": 17, "token_count": 219, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-018", "document_id": "core_extensions-vss", "content": "│ 0.0 │ {'search_vec': [1.0, 1.0, 1.0]} │ {'id': 1, 'vec': [1.0, 1.0, 1.0]} │\n│ 1.0 │ {'search_vec': [1.0, 1.0, 1.0]} │ {'id': 10, 'vec': [2.0, 1.0, 1.0]} │\n│ 1.0 │ {'search_vec': [1.0, 1.0, 1.0]} │ {'id': 2, 'vec': [1.0, 2.0, 1.0]} │\n└───────┴─────────────────────────────────┴─────────────────────────────────────┘", "position": 18, "token_count": 168, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-018", "document_id": "core_extensions-vss", "position": 18, "token_count": 168, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-019", "document_id": "core_extensions-vss", "content": "```\n\nAlternatively, we can use the `vss_match` macro as a “lateral join” to get the matches already grouped by the left table.\nNote that this requires us to specify the left table first, and then the `vss_match` macro which references the search column from the left\ntable (in this case, `search_vec`):\n\n```sql\nSELECT *\nFROM needle, vss_match(haystack, search_vec, vec, 3) res;", "position": 19, "token_count": 109, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-019", "document_id": "core_extensions-vss", "position": 19, "token_count": 109, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-020", "document_id": "core_extensions-vss", "content": "```", "position": 20, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-020", "document_id": "core_extensions-vss", "position": 20, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-021", "document_id": "core_extensions-vss", "content": "```text\n┌─────────────────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ search_vec │ matches │\n│ float[3] │ struct(score float, \"row\" struct(id integer, vec float[3]))[] │\n├─────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ [5.0, 5.0, 5.0] │ [{'score': 0.0, 'row': {'id': 365, 'vec': [5.0, 5.0, 5.0]}}, {'score': 1.0, 'row': {'id': 364, 'vec': [5.0, 4.0, 5.0]}}, {'score': 1.0, 'row': {'id': 356, 'vec': [4.0, 5.0, 5.0]}}] │", "position": 21, "token_count": 191, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-021", "document_id": "core_extensions-vss", "position": 21, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-022", "document_id": "core_extensions-vss", "content": "│ [1.0, 1.0, 1.0] │ [{'score': 0.0, 'row': {'id': 1, 'vec': [1.0, 1.0, 1.0]}}, {'score': 1.0, 'row': {'id': 10, 'vec': [2.0, 1.0, 1.0]}}, {'score': 1.0, 'row': {'id': 2, 'vec': [1.0, 2.0, 1.0]}}] │\n└─────────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘", "position": 22, "token_count": 143, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-022", "document_id": "core_extensions-vss", "position": 22, "token_count": 143, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-023", "document_id": "core_extensions-vss", "content": "```", "position": 23, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-vss-023", "document_id": "core_extensions-vss", "position": 23, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss"}}
{"chunk_id": "core_extensions-vss-024", "document_id": "core_extensions-vss", "content": "## Limitations\n\n* Only vectors consisting of `FLOAT`s (32-bit, single precision) are supported at the moment.\n* The index itself is not buffer managed and must be able to fit into RAM memory.\n* The size of the index in memory does not count towards DuckDB's `memory_limit` configuration parameter.\n* `HNSW` indexes can only be created on tables in in-memory databases, unless the `SET hnsw_enable_experimental_persistence = ⟨bool⟩`{:.language-sql .highlight} configuration option is set to `true`, see [Persistence](#persistence) for more information.\n* The vector join table macros (`vss_join` and `vss_match`) do not require or make use of the `HNSW` index.", "position": 24, "token_count": 176, "has_code": false, "section_hierarchy": ["Limitations"], "metadata": {"chunk_id": "core_extensions-vss-024", "document_id": "core_extensions-vss", "position": 24, "token_count": 176, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Limitations"], "file_path": "core_extensions/vss.md", "url": "/core_extensions/vss", "title": "Vector Similarity Search Extension", "category": null, "tags": [], "section_url": "/core_extensions/vss#limitations"}}

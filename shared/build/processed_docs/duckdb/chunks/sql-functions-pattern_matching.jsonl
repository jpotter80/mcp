{"chunk_id": "sql-functions-pattern_matching-000", "document_id": "sql-functions-pattern_matching", "content": "There are four separate approaches to pattern matching provided by DuckDB:\nthe traditional SQL [`LIKE` operator](#like),\nthe more recent [`SIMILAR TO` operator](#similar-to) (added in SQL:1999),\na [`GLOB` operator](#glob),\nand POSIX-style [regular expressions](#regular-expressions).", "position": 0, "token_count": 86, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-000", "document_id": "sql-functions-pattern_matching", "position": 0, "token_count": 86, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-001", "document_id": "sql-functions-pattern_matching", "content": "## `LIKE`\n\nThe `LIKE` expression returns `true` if the string matches the supplied pattern. (As expected, the `NOT LIKE` expression returns `false` if `LIKE` returns `true`, and vice versa. An equivalent expression is `NOT (string LIKE pattern)`.)\n\nIf pattern does not contain percent signs or underscores, then the pattern only represents the string itself; in that case `LIKE` acts like the equals operator. An underscore (`_`) in pattern stands for (matches) any single character; a percent sign (`%`) matches any sequence of zero or more characters.\n\n`LIKE` pattern matching always covers the entire string. Therefore, if it's desired to match a sequence anywhere within a string, the pattern must start and end with a percent sign.\n\nSome examples:", "position": 1, "token_count": 176, "has_code": false, "section_hierarchy": ["`LIKE`"], "metadata": {"chunk_id": "sql-functions-pattern_matching-001", "document_id": "sql-functions-pattern_matching", "position": 1, "token_count": 176, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`LIKE`"], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching#like"}}
{"chunk_id": "sql-functions-pattern_matching-002", "document_id": "sql-functions-pattern_matching", "content": "`LIKE` pattern matching always covers the entire string. Therefore, if it's desired to match a sequence anywhere within a string, the pattern must start and end with a percent sign.\n\nSome examples:\n\n```sql\nSELECT 'abc' LIKE 'abc'; -- true\nSELECT 'abc' LIKE 'a%' ; -- true\nSELECT 'abc' LIKE '_b_'; -- true\nSELECT 'abc' LIKE 'c'; -- false\nSELECT 'abc' LIKE 'c%' ; -- false\nSELECT 'abc' LIKE '%c'; -- true\nSELECT 'abc' NOT LIKE '%c'; -- false", "position": 2, "token_count": 138, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-002", "document_id": "sql-functions-pattern_matching", "position": 2, "token_count": 138, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-003", "document_id": "sql-functions-pattern_matching", "content": "```\n\nThe keyword `ILIKE` can be used instead of `LIKE` to make the match case-insensitive according to the active locale:\n\n```sql\nSELECT 'abc' ILIKE '%C'; -- true\n```\n\n```sql\nSELECT 'abc' NOT ILIKE '%C'; -- false", "position": 3, "token_count": 76, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-003", "document_id": "sql-functions-pattern_matching", "position": 3, "token_count": 76, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-004", "document_id": "sql-functions-pattern_matching", "content": "```\n\n```sql\nSELECT 'abc' NOT ILIKE '%C'; -- false\n```\n\nTo search within a string for a character that is a wildcard (`%` or `_`), the pattern must use an `ESCAPE` clause and an escape character to indicate the wildcard should be treated as a literal character instead of a wildcard. See an example below.\n\nAdditionally, the function `like_escape` has the same functionality as a `LIKE` expression with an `ESCAPE` clause, but using function syntax. See the [Text Functions Docs]({% link docs/stable/sql/functions/text.md %}) for details.\n\nSearch for strings with 'a' then a literal percent sign then 'c':\n\n```sql\nSELECT 'a%c' LIKE 'a$%c' ESCAPE '$'; -- true\nSELECT 'azc' LIKE 'a$%c' ESCAPE '$'; -- false\n```\n\nCase-insensitive ILIKE with ESCAPE:\n\n```sql\nSELECT 'A%c' ILIKE 'a$%c' ESCAPE '$'; -- true", "position": 4, "token_count": 248, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-004", "document_id": "sql-functions-pattern_matching", "position": 4, "token_count": 248, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-005", "document_id": "sql-functions-pattern_matching", "content": "```\n\nCase-insensitive ILIKE with ESCAPE:\n\n```sql\nSELECT 'A%c' ILIKE 'a$%c' ESCAPE '$'; -- true\n```\n\nThere are also alternative characters that can be used as keywords in place of `LIKE` expressions. These enhance PostgreSQL compatibility.\n\n| PostgreSQL-style | `LIKE`-style |\n| :--------------- | :----------- |\n| `~~` | `LIKE` |\n| `!~~` | `NOT LIKE` |\n| `~~*` | `ILIKE` |\n| `!~~*` | `NOT ILIKE` |", "position": 5, "token_count": 167, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-005", "document_id": "sql-functions-pattern_matching", "position": 5, "token_count": 167, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-006", "document_id": "sql-functions-pattern_matching", "content": "## `SIMILAR TO`\n\nThe `SIMILAR TO` operator returns true or false depending on whether its pattern matches the given string. It is similar to `LIKE`, except that it interprets the pattern using a [regular expression]({% link docs/stable/sql/functions/regular_expressions.md %}). Like `LIKE`, the `SIMILAR TO` operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string.\n\nA regular expression is a character sequence that is an abbreviated definition of a set of strings (a regular set). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with `LIKE`, pattern characters match string characters exactly unless they are special characters in the regular expression language — but regular expressions use different special characters than `LIKE` does.\n\nSome examples:", "position": 6, "token_count": 196, "has_code": false, "section_hierarchy": ["`SIMILAR TO`"], "metadata": {"chunk_id": "sql-functions-pattern_matching-006", "document_id": "sql-functions-pattern_matching", "position": 6, "token_count": 196, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`SIMILAR TO`"], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching#similar-to"}}
{"chunk_id": "sql-functions-pattern_matching-007", "document_id": "sql-functions-pattern_matching", "content": "Some examples:\n\n```sql\nSELECT 'abc' SIMILAR TO 'abc'; -- true\nSELECT 'abc' SIMILAR TO 'a'; -- false\nSELECT 'abc' SIMILAR TO '.*(b|d).*'; -- true\nSELECT 'abc' SIMILAR TO '(b|c).*'; -- false\nSELECT 'abc' NOT SIMILAR TO 'abc'; -- false", "position": 7, "token_count": 89, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-007", "document_id": "sql-functions-pattern_matching", "position": 7, "token_count": 89, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-008", "document_id": "sql-functions-pattern_matching", "content": "```\n\n> In PostgreSQL, `~` is equivalent to `SIMILAR TO`\n> and `!~` is equivalent to `NOT SIMILAR TO`.\n> In DuckDB, these equivalences do not hold currently,\n> see the [PostgreSQL compatibility page]({% link docs/stable/sql/dialect/postgresql_compatibility.md %}).", "position": 8, "token_count": 89, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-008", "document_id": "sql-functions-pattern_matching", "position": 8, "token_count": 89, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-009", "document_id": "sql-functions-pattern_matching", "content": "## Globbing\n\nDuckDB supports file name expansion, also known as globbing, for discovering files.\nDuckDB's glob syntax uses the question mark (`?`) wildcard to match any single character and the asterisk (`*`) to match zero or more characters.\nIn addition, you can use the bracket syntax (`[...]`) to match any single character contained within the brackets, or within the character range specified by the brackets. An exclamation mark (`!`) may be used inside the first bracket to search for a character that is not contained within the brackets.\nTo learn more, visit the [“glob (programming)” Wikipedia page](https://en.wikipedia.org/wiki/Glob_(programming)).", "position": 9, "token_count": 176, "has_code": false, "section_hierarchy": ["Globbing"], "metadata": {"chunk_id": "sql-functions-pattern_matching-009", "document_id": "sql-functions-pattern_matching", "position": 9, "token_count": 176, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Globbing"], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching#globbing"}}
{"chunk_id": "sql-functions-pattern_matching-010", "document_id": "sql-functions-pattern_matching", "content": "### `GLOB`\n\nThe `GLOB` operator returns `true` or `false` if the string matches the `GLOB` pattern. The `GLOB` operator is most commonly used when searching for filenames that follow a specific pattern (for example a specific file extension).\n\nSome examples:\n\n```sql\nSELECT 'best.txt' GLOB '*.txt'; -- true\nSELECT 'best.txt' GLOB '????.txt'; -- true\nSELECT 'best.txt' GLOB '?.txt'; -- false\nSELECT 'best.txt' GLOB '[abc]est.txt'; -- true\nSELECT 'best.txt' GLOB '[a-z]est.txt'; -- true", "position": 10, "token_count": 186, "has_code": true, "section_hierarchy": ["`GLOB`"], "metadata": {"chunk_id": "sql-functions-pattern_matching-010", "document_id": "sql-functions-pattern_matching", "position": 10, "token_count": 186, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`GLOB`"], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching#glob"}}
{"chunk_id": "sql-functions-pattern_matching-011", "document_id": "sql-functions-pattern_matching", "content": "```\n\nThe bracket syntax is case-sensitive:\n\n```sql\nSELECT 'Best.txt' GLOB '[a-z]est.txt'; -- false\nSELECT 'Best.txt' GLOB '[a-zA-Z]est.txt'; -- true\n```\n\nThe `!` applies to all characters within the brackets:\n\n```sql\nSELECT 'Best.txt' GLOB '[!a-zA-Z]est.txt'; -- false\n```\n\nTo negate a GLOB operator, negate the entire expression:\n\n```sql\nSELECT NOT 'best.txt' GLOB '*.txt'; -- false\n```\n\nThree tildes (`~~~`) may also be used in place of the `GLOB` keyword.\n\n| GLOB-style | Symbolic-style |\n| :--------- | :------------- |\n| `GLOB` | `~~~` |", "position": 11, "token_count": 239, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-011", "document_id": "sql-functions-pattern_matching", "position": 11, "token_count": 239, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-012", "document_id": "sql-functions-pattern_matching", "content": "### Glob Function to Find Filenames\n\nThe glob pattern matching syntax can also be used to search for filenames using the `glob` table function.\nIt accepts one parameter: the path to search (which may include glob patterns).\n\nSearch the current directory for all files:\n\n```sql\nSELECT * FROM glob('*');\n```\n\n| file |\n| ------------- |\n| duckdb.exe |\n| test.csv |\n| test.json |\n| test.parquet |\n| test2.csv |\n| test2.parquet |\n| todos.json |", "position": 12, "token_count": 151, "has_code": true, "section_hierarchy": ["Glob Function to Find Filenames"], "metadata": {"chunk_id": "sql-functions-pattern_matching-012", "document_id": "sql-functions-pattern_matching", "position": 12, "token_count": 151, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Glob Function to Find Filenames"], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching#glob-function-to-find-filenames"}}
{"chunk_id": "sql-functions-pattern_matching-013", "document_id": "sql-functions-pattern_matching", "content": "### Globbing Semantics\n\nDuckDB's globbing implementation follows the semantics of [Python's `glob`](https://docs.python.org/3/library/glob.html) and not the `glob` used in the shell.\nA notable difference is the behavior of the `**/` construct: `**/⟨filename⟩`{:.language-sql .highlight} will not return a file with `⟨filename⟩`{:.language-sql .highlight} in top-level directory.\nFor example, with a `README.md` file present in the directory, the following query finds it:\n\n```sql\nSELECT * FROM glob('README.md');\n```\n\n| file |\n| --------- |\n| README.md |\n\nHowever, the following query returns an empty result:\n\n```sql\nSELECT * FROM glob('**/README.md');", "position": 13, "token_count": 223, "has_code": true, "section_hierarchy": ["Globbing Semantics"], "metadata": {"chunk_id": "sql-functions-pattern_matching-013", "document_id": "sql-functions-pattern_matching", "position": 13, "token_count": 223, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Globbing Semantics"], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching#globbing-semantics"}}
{"chunk_id": "sql-functions-pattern_matching-014", "document_id": "sql-functions-pattern_matching", "content": "```\n\nMeanwhile, the globbing of Bash, Zsh, etc. finds the file using the same syntax:\n\n```batch\nls **/README.md\n```\n\n```text\nREADME.md\n```", "position": 14, "token_count": 54, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-014", "document_id": "sql-functions-pattern_matching", "position": 14, "token_count": 54, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-015", "document_id": "sql-functions-pattern_matching", "content": "## Regular Expressions\n\nDuckDB's regular expression support is documented on the [Regular Expressions page]({% link docs/stable/sql/functions/regular_expressions.md %}).\nDuckDB supports some PostgreSQL-style operators for regular expression matching:", "position": 15, "token_count": 61, "has_code": false, "section_hierarchy": ["Regular Expressions"], "metadata": {"chunk_id": "sql-functions-pattern_matching-015", "document_id": "sql-functions-pattern_matching", "position": 15, "token_count": 61, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Regular Expressions"], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching#regular-expressions"}}
{"chunk_id": "sql-functions-pattern_matching-016", "document_id": "sql-functions-pattern_matching", "content": "| PostgreSQL-style | Equivalent expression |\n| :--------------- | :------------------------------------------------------------------------------------------------------- |\n| `~` | [`regexp_full_match`]({% link docs/stable/sql/functions/text.md %}#regexp_full_matchstring-regex) |\n| `!~` | `NOT` [`regexp_full_match`]({% link docs/stable/sql/functions/text.md %}#regexp_full_matchstring-regex) |", "position": 16, "token_count": 239, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-016", "document_id": "sql-functions-pattern_matching", "position": 16, "token_count": 239, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}
{"chunk_id": "sql-functions-pattern_matching-017", "document_id": "sql-functions-pattern_matching", "content": "| `~*` | (not supported) |\n| `!~*` | (not supported) |", "position": 17, "token_count": 25, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-functions-pattern_matching-017", "document_id": "sql-functions-pattern_matching", "position": 17, "token_count": 25, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/functions/pattern_matching.md", "url": "/sql/functions/pattern_matching", "title": "Pattern Matching", "category": null, "tags": [], "section_url": "/sql/functions/pattern_matching"}}

{"chunk_id": "dev-sqllogictest-intro-000", "document_id": "dev-sqllogictest-intro", "content": "For testing plain SQL, we use an extended version of the SQL logic test suite, adopted from [SQLite](https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki). Every test is a single self-contained file located in the `test/sql` directory.\nTo run tests located outside of the default `test` directory, specify `--test-dir ` and make sure provided test file paths are relative to that root directory.\n\nThe test describes a series of SQL statements, together with either the expected result, a `statement ok` indicator, or a `statement error` indicator. An example of a test file is shown below:\n\n```sql\n# name: test/sql/projection/test_simple_projection.test\n# group [projection]\n\n# enable query verification\nstatement ok\nPRAGMA enable_verification\n\n# create table\nstatement ok\nCREATE TABLE a (i INTEGER, j INTEGER);", "position": 0, "token_count": 199, "has_code": true, "section_hierarchy": ["create table"], "metadata": {"chunk_id": "dev-sqllogictest-intro-000", "document_id": "dev-sqllogictest-intro", "position": 0, "token_count": 199, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["create table"], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro#create-table"}}
{"chunk_id": "dev-sqllogictest-intro-001", "document_id": "dev-sqllogictest-intro", "content": "# insertion: 1 affected row\nstatement ok\nINSERT INTO a VALUES (42, 84);\n\nquery II\nSELECT * FROM a;\n----\n42\t84", "position": 1, "token_count": 33, "has_code": false, "section_hierarchy": ["insertion: 1 affected row"], "metadata": {"chunk_id": "dev-sqllogictest-intro-001", "document_id": "dev-sqllogictest-intro", "position": 1, "token_count": 33, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["insertion: 1 affected row"], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro#insertion-1-affected-row"}}
{"chunk_id": "dev-sqllogictest-intro-002", "document_id": "dev-sqllogictest-intro", "content": "```\n\nIn this example, three statements are executed. The first statements are expected to succeed (prefixed by `statement ok`). The third statement is expected to return a single row with two columns (indicated by `query II`). The values of the row are expected to be `42` and `84` (separated by a tab character). For more information on query result verification, see the [result verification section]({% link docs/stable/dev/sqllogictest/result_verification.md %}).", "position": 2, "token_count": 116, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-intro-002", "document_id": "dev-sqllogictest-intro", "position": 2, "token_count": 116, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro"}}
{"chunk_id": "dev-sqllogictest-intro-003", "document_id": "dev-sqllogictest-intro", "content": "The top of every file should contain a comment describing the name and group of the test. The name of the test is always the relative file path of the file. The group is the folder that the file is in. The name and group of the test are relevant because they can be used to execute *only* that test in the unittest group. For example, if we wanted to execute *only* the above test, we would run the command `unittest test/sql/projection/test_simple_projection.test`. If we wanted to run all tests in a specific directory, we would run the command `unittest \"[projection]\"`.\n\nAny tests that are placed in the `test` directory are automatically added to the test suite. Note that the extension of the test is significant. The sqllogictests should either use the `.test` extension, or the `.test_slow` extension. The `.test_slow` extension indicates that the test takes a while to run, and will only be run when all tests are explicitly run using `unittest *`. Tests with the extension `.test` will be included in the fast set of tests.", "position": 3, "token_count": 246, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-intro-003", "document_id": "dev-sqllogictest-intro", "position": 3, "token_count": 246, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro"}}
{"chunk_id": "dev-sqllogictest-intro-004", "document_id": "dev-sqllogictest-intro", "content": "## Query Verification\n\nMany simple tests start by enabling query verification. This can be done through the following `PRAGMA` statement:\n\n```sql\nstatement ok\nPRAGMA enable_verification\n```\n\nQuery verification performs extra validation to ensure that the underlying code runs correctly. The most important part of that is that it verifies that optimizers do not cause bugs in the query. It does this by running both an unoptimized and optimized version of the query, and verifying that the results of these queries are identical.\n\nQuery verification is very useful because it not only discovers bugs in optimizers, but also finds bugs in e.g., join implementations. This is because the unoptimized version will typically run using cross products instead. Because of this, query verification can be very slow to do when working with larger datasets. It is therefore recommended to turn on query verification for all unit tests, except those involving larger datasets (more than ~10-100 rows).", "position": 4, "token_count": 212, "has_code": true, "section_hierarchy": ["Query Verification"], "metadata": {"chunk_id": "dev-sqllogictest-intro-004", "document_id": "dev-sqllogictest-intro", "position": 4, "token_count": 212, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Query Verification"], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro#query-verification"}}
{"chunk_id": "dev-sqllogictest-intro-005", "document_id": "dev-sqllogictest-intro", "content": "## Editors & Syntax Highlighting\n\nThe sqllogictests are not exactly an industry standard, but several other systems have adopted them as well. Parsing sqllogictests is intentionally simple. All statements have to be separated by empty lines. For that reason, writing a syntax highlighter is not extremely difficult.\n\nA syntax highlighter exists for [Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=benesch.sqllogictest). We have also [made a fork that supports the DuckDB dialect of the sqllogictests](https://github.com/Mytherin/vscode-sqllogictest). You can use the fork by installing the original, then copying the `syntaxes/sqllogictest.tmLanguage.json` into the installed extension (on macOS this is located in `~/.vscode/extensions/benesch.sqllogictest-0.1.1`).", "position": 5, "token_count": 211, "has_code": false, "section_hierarchy": ["Editors & Syntax Highlighting"], "metadata": {"chunk_id": "dev-sqllogictest-intro-005", "document_id": "dev-sqllogictest-intro", "position": 5, "token_count": 211, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Editors & Syntax Highlighting"], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro#editors--syntax-highlighting"}}
{"chunk_id": "dev-sqllogictest-intro-006", "document_id": "dev-sqllogictest-intro", "content": "A syntax highlighter is also available for [CLion](https://plugins.jetbrains.com/plugin/15295-sqltest). It can be installed directly on the IDE by searching SQLTest on the marketplace. A [GitHub repository](https://github.com/pdet/SQLTest) is also available, with extensions and bug reports being welcome.", "position": 6, "token_count": 92, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "dev-sqllogictest-intro-006", "document_id": "dev-sqllogictest-intro", "position": 6, "token_count": 92, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro"}}
{"chunk_id": "dev-sqllogictest-intro-007", "document_id": "dev-sqllogictest-intro", "content": "### Temporary Files\n\nFor some tests (e.g., CSV/Parquet file format tests) it is necessary to create temporary files. Any temporary files should be created in the temporary testing directory. This directory can be used by placing the string `__TEST_DIR__` in a query. This string will be replaced by the path of the temporary testing directory.\n\n```sql\nstatement ok\nCOPY csv_data TO '__TEST_DIR__/output_file.csv.gz' (COMPRESSION gzip);\n```", "position": 7, "token_count": 122, "has_code": true, "section_hierarchy": ["Temporary Files"], "metadata": {"chunk_id": "dev-sqllogictest-intro-007", "document_id": "dev-sqllogictest-intro", "position": 7, "token_count": 122, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Temporary Files"], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro#temporary-files"}}
{"chunk_id": "dev-sqllogictest-intro-008", "document_id": "dev-sqllogictest-intro", "content": "### Require & Extensions\n\nTo avoid bloating the core system, certain functionality of DuckDB is available only as an extension. Tests can be build for those extensions by adding a `require` field in the test. If the extension is not loaded, any statements that occurs after the require field will be skipped. Examples of this are `require parquet` or `require icu`.\n\nAnother usage is to limit a test to a specific vector size. For example, adding `require vector_size 512` to a test will prevent the test from being run unless the vector size greater than or equal to 512. This is useful because certain functionality is not supported for low vector sizes, but we run tests using a vector size of 2 in our CI.", "position": 8, "token_count": 155, "has_code": false, "section_hierarchy": ["Require & Extensions"], "metadata": {"chunk_id": "dev-sqllogictest-intro-008", "document_id": "dev-sqllogictest-intro", "position": 8, "token_count": 155, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Require & Extensions"], "file_path": "dev/sqllogictest/intro.md", "url": "/dev/sqllogictest/intro", "title": "sqllogictest Introduction", "category": null, "tags": [], "section_url": "/dev/sqllogictest/intro#require--extensions"}}

{"chunk_id": "sql-data_types-literal_types-000", "document_id": "sql-data_types-literal_types", "content": "DuckDB has special literal types for representing `NULL`, integer and string literals in queries. These have their own binding and conversion rules.\n\n> Prior to DuckDB version 0.10.0, integer and string literals behaved identically to the `INTEGER` and `VARCHAR` types.\n\n## Null Literals\n\nThe `NULL` literal is denoted with the keyword `NULL`. The `NULL` literal can be implicitly converted to any other type.", "position": 0, "token_count": 100, "has_code": false, "section_hierarchy": ["Null Literals"], "metadata": {"chunk_id": "sql-data_types-literal_types-000", "document_id": "sql-data_types-literal_types", "position": 0, "token_count": 100, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Null Literals"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#null-literals"}}
{"chunk_id": "sql-data_types-literal_types-001", "document_id": "sql-data_types-literal_types", "content": "## Null Literals\n\nThe `NULL` literal is denoted with the keyword `NULL`. The `NULL` literal can be implicitly converted to any other type.\n\n## Integer Literals\n\nInteger literals are denoted as a sequence of one or more decimal digits. At runtime, these result in values of the `INTEGER_LITERAL` type. `INTEGER_LITERAL` types can be implicitly converted to any [integer type]({% link docs/stable/sql/data_types/numeric.md %}#integer-types) in which the value fits. For example, the integer literal `42` can be implicitly converted to a `TINYINT`, but the integer literal `1000` cannot be.\n\n> DuckDB does not support hexadecimal or binary literals directly. However, strings or string literals in hexadecimal or binary notation with `0x` or `0b` prefixes respectively, can be cast to integer types, e.g., `'0xFF'::INT = 255` or `0b101::INT = 5`.", "position": 1, "token_count": 238, "has_code": false, "section_hierarchy": ["Integer Literals"], "metadata": {"chunk_id": "sql-data_types-literal_types-001", "document_id": "sql-data_types-literal_types", "position": 1, "token_count": 238, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Integer Literals"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#integer-literals"}}
{"chunk_id": "sql-data_types-literal_types-002", "document_id": "sql-data_types-literal_types", "content": "## Other Numeric Literals\n\nNon-integer numeric literals can be denoted with decimal notation, using the period character (`.`) to separate the integer part and the decimal part of the number.\nEither the integer part or the decimal part may be omitted:\n\n```sql\nSELECT 1.5; -- 1.5\nSELECT .50; -- 0.5\nSELECT 2.; -- 2.0\n```\n\nNon-integer numeric literals can also be denoted using [_E notation_](https://en.wikipedia.org/wiki/Scientific_notation#E_notation). In E notation, an integer or decimal literal is followed by and exponential part, which is denoted by `e` or `E`, followed by a literal integer indicating the exponent.\nThe exponential part indicates that the preceding value should be multiplied by 10 raised to the power of the exponent:\n\n```sql\nSELECT 1e2; -- 100\nSELECT 6.02214e23; -- Avogadro's constant\nSELECT 1e-10; -- 1 ångström\n```", "position": 2, "token_count": 236, "has_code": true, "section_hierarchy": ["Other Numeric Literals"], "metadata": {"chunk_id": "sql-data_types-literal_types-002", "document_id": "sql-data_types-literal_types", "position": 2, "token_count": 236, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Other Numeric Literals"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#other-numeric-literals"}}
{"chunk_id": "sql-data_types-literal_types-003", "document_id": "sql-data_types-literal_types", "content": "## Underscores in Numeric Literals\n\nDuckDB's SQL dialect allows using the underscore character `_` in numeric literals as an optional separator. The rules for using underscores are as follows:\n\n* Underscores are allowed in integer, decimal, hexadecimal and binary notation.\n* Underscores can not be the first or last character in a literal.\n* Underscores have to have an integer/numeric part on either side of them, i.e., there can not be multiple underscores in a row and not immediately before/after a decimal or exponent.\n\nExamples:\n\n```sql\nSELECT 100_000_000; -- 100000000\nSELECT '0xFF_FF'::INTEGER; -- 65535\nSELECT 1_2.1_2E0_1; -- 121.2\nSELECT '0b0_1_0_1'::INTEGER; -- 5\n```", "position": 3, "token_count": 210, "has_code": true, "section_hierarchy": ["Underscores in Numeric Literals"], "metadata": {"chunk_id": "sql-data_types-literal_types-003", "document_id": "sql-data_types-literal_types", "position": 3, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Underscores in Numeric Literals"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#underscores-in-numeric-literals"}}
{"chunk_id": "sql-data_types-literal_types-004", "document_id": "sql-data_types-literal_types", "content": "## String Literals\n\nString literals are delimited using single quotes (`'`, apostrophe) and result in `STRING_LITERAL` values.\nNote that double quotes (`\"`) cannot be used as string delimiter character: instead, double quotes are used to delimit [quoted identifiers]({% link docs/stable/sql/dialect/keywords_and_identifiers.md %}#identifiers).", "position": 4, "token_count": 103, "has_code": false, "section_hierarchy": ["String Literals"], "metadata": {"chunk_id": "sql-data_types-literal_types-004", "document_id": "sql-data_types-literal_types", "position": 4, "token_count": 103, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["String Literals"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#string-literals"}}
{"chunk_id": "sql-data_types-literal_types-005", "document_id": "sql-data_types-literal_types", "content": "### Implicit String Literal Concatenation\n\nConsecutive single-quoted string literals separated only by whitespace that contains at least one newline are implicitly concatenated:\n\n```sql\nSELECT 'Hello'\n ' '\n 'World' AS greeting;\n```\n\nis equivalent to:\n\n```sql\nSELECT 'Hello'\n || ' '\n || 'World' AS greeting;\n```\n\nThey both return the following result:\n\n| greeting |\n|-------------|\n| Hello World |\n\nNote that implicit concatenation only works if there is at least one newline between the literals. Using adjacent string literals separated by whitespace without a newline results in a syntax error:\n\n```sql\nSELECT 'Hello' ' ' 'World' AS greeting;\n```\n\n```console\nParser Error:\nsyntax error at or near \"' '\"\n\nLINE 1: SELECT 'Hello' ' ' 'World' AS greeting;\n ^\n```\n\nAlso note that implicit concatenation only works with single-quoted string literals, and does not work with other kinds of string values.", "position": 5, "token_count": 235, "has_code": true, "section_hierarchy": ["Implicit String Literal Concatenation"], "metadata": {"chunk_id": "sql-data_types-literal_types-005", "document_id": "sql-data_types-literal_types", "position": 5, "token_count": 235, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implicit String Literal Concatenation"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#implicit-string-literal-concatenation"}}
{"chunk_id": "sql-data_types-literal_types-006", "document_id": "sql-data_types-literal_types", "content": "### Implicit String Conversion\n\n`STRING_LITERAL` instances can be implicitly converted to _any_ other type.\n\nFor example, we can compare string literals with dates:\n\n```sql\nSELECT d > '1992-01-01' AS result\nFROM (VALUES (DATE '1992-01-01')) t(d);\n```\n\n| result |\n|:-------|\n| false |\n\nHowever, we cannot compare `VARCHAR` values with dates.\n\n```sql\nSELECT d > '1992-01-01'::VARCHAR\nFROM (VALUES (DATE '1992-01-01')) t(d);\n```\n\n```console\nBinder Error:\nCannot compare values of type DATE and type VARCHAR - an explicit cast is required\n```", "position": 6, "token_count": 175, "has_code": true, "section_hierarchy": ["Implicit String Conversion"], "metadata": {"chunk_id": "sql-data_types-literal_types-006", "document_id": "sql-data_types-literal_types", "position": 6, "token_count": 175, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Implicit String Conversion"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#implicit-string-conversion"}}
{"chunk_id": "sql-data_types-literal_types-007", "document_id": "sql-data_types-literal_types", "content": "### Escape String Literals\n\nTo escape a single quote (apostrophe) character in a string literal, use `''`. For example, `SELECT '''' AS s` returns `'`.\n\nTo enable some common escape sequences, such as `\\n` for the newline character, prefix a string literal with `e` (or `E`).\n\n```sql\nSELECT e'Hello\\nworld' AS msg;\n```\n\n```text\n┌──────────────┐\n│ msg │\n│ varchar │\n├──────────────┤\n│ Hello\\nworld │\n└──────────────┘\n```\n\nThe following backslash escape sequences are supported:\n\n| Escape sequence | Name | ASCII code |\n|:--|:--|--:|\n| `\\b` | backspace | 8 |\n| `\\f` | form feed | 12 |\n| `\\n` | newline | 10 |\n| `\\r` | carriage return | 13 |\n| `\\t` | tab | 9 |", "position": 7, "token_count": 216, "has_code": true, "section_hierarchy": ["Escape String Literals"], "metadata": {"chunk_id": "sql-data_types-literal_types-007", "document_id": "sql-data_types-literal_types", "position": 7, "token_count": 216, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Escape String Literals"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#escape-string-literals"}}
{"chunk_id": "sql-data_types-literal_types-008", "document_id": "sql-data_types-literal_types", "content": "### Dollar-Quoted String Literals\n\nDuckDB supports dollar-quoted string literals, which are surrounded by double-dollar symbols (`$$`):\n\n```sql\nSELECT $$Hello\nworld$$ AS msg;\n```\n\n```text\n┌──────────────┐\n│ msg │\n│ varchar │\n├──────────────┤\n│ Hello\\nworld │\n└──────────────┘\n```\n\n```sql\nSELECT $$The price is $9.95$$ AS msg;\n```\n\n| msg |\n|--------------------|\n| The price is $9.95 |\n\nEven more, you can insert alphanumeric tags in the double-dollar symbols to allow for the use of regular double-dollar symbols *within* the string literal:\n\n```sql\nSELECT $tag$ this string can contain newlines,\n'single quotes',\n\"double quotes\",\nand $$dollar quotes$$ $tag$ AS msg;", "position": 8, "token_count": 211, "has_code": true, "section_hierarchy": ["Dollar-Quoted String Literals"], "metadata": {"chunk_id": "sql-data_types-literal_types-008", "document_id": "sql-data_types-literal_types", "position": 8, "token_count": 211, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Dollar-Quoted String Literals"], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types#dollar-quoted-string-literals"}}
{"chunk_id": "sql-data_types-literal_types-009", "document_id": "sql-data_types-literal_types", "content": "```\n\n```text\n┌────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ msg │\n│ varchar │\n├────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ this string can contain newlines,\\n'single quotes',\\n\"double quotes\",\\nand $$dollar quotes$$ │\n└────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\n[Implicit concatenation](#implicit-string-literal-concatenation) only works for single-quoted string literals, not with dollar-quoted ones.", "position": 9, "token_count": 91, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-data_types-literal_types-009", "document_id": "sql-data_types-literal_types", "position": 9, "token_count": 91, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/data_types/literal_types.md", "url": "/sql/data_types/literal_types", "title": "Literal Types", "category": null, "tags": [], "section_url": "/sql/data_types/literal_types"}}

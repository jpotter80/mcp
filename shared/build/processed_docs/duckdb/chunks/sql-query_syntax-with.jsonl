{"chunk_id": "sql-query_syntax-with-000", "document_id": "sql-query_syntax-with", "content": "The `WITH` clause allows you to specify common table expressions (CTEs).\nRegular (non-recursive) common-table-expressions are essentially views that are limited in scope to a particular query.\nCTEs can reference each-other and can be nested. [Recursive CTEs](#recursive-ctes) can reference themselves.", "position": 0, "token_count": 78, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-000", "document_id": "sql-query_syntax-with", "position": 0, "token_count": 78, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-001", "document_id": "sql-query_syntax-with", "content": "## Basic CTE Examples\n\nCreate a CTE called `cte` and use it in the main query:\n\n```sql\nWITH cte AS (SELECT 42 AS x)\nSELECT * FROM cte;\n```\n\n| x |\n|---:|\n| 42 |\n\nCreate two CTEs `cte1` and `cte2`, where the second CTE references the first CTE:\n\n```sql\nWITH\n cte1 AS (SELECT 42 AS i),\n cte2 AS (SELECT i * 100 AS x FROM cte1)\nSELECT * FROM cte2;\n```\n\n| x |\n|-----:|\n| 4200 |\n\nYou can specify column names for CTEs:\n\n```sql\nWITH cte(j) AS (SELECT 42 AS i)\nFROM cte;\n```", "position": 1, "token_count": 177, "has_code": true, "section_hierarchy": ["Basic CTE Examples"], "metadata": {"chunk_id": "sql-query_syntax-with-001", "document_id": "sql-query_syntax-with", "position": 1, "token_count": 177, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Basic CTE Examples"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#basic-cte-examples"}}
{"chunk_id": "sql-query_syntax-with-002", "document_id": "sql-query_syntax-with", "content": "## CTE Materialization\n\nDuckDB handles CTEs as _materialized_ by default, meaning that the CTE is evaluated\nonce and the result is stored in a temporary table. However, under certain conditions,\nDuckDB can _inline_ the CTE into the main query, which means that the CTE is not\nmaterialized and its definition is duplicated in each place it is referenced.\nInlining is done using the following heuristics:\n- The CTE is not referenced more than once.\n- The CTE does not contain a `VOLATILE` function.\n- The CTE is using `AS NOT MATERIALIZED` and does not use `AS MATERIALIZED`.\n- The CTE does not perform a grouped aggregation.\n\nMaterialization can be explicitly activated by defining the CTE using `AS MATERIALIZED` and disabled by using `AS NOT MATERIALIZED`. Note that inlining is not always possible, even if the heuristics are met. For example, if the CTE contains a `read_csv` function, it cannot be inlined.\n\nTake the following query for example, which invokes the same CTE three times:", "position": 2, "token_count": 233, "has_code": false, "section_hierarchy": ["CTE Materialization"], "metadata": {"chunk_id": "sql-query_syntax-with-002", "document_id": "sql-query_syntax-with", "position": 2, "token_count": 233, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["CTE Materialization"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#cte-materialization"}}
{"chunk_id": "sql-query_syntax-with-003", "document_id": "sql-query_syntax-with", "content": "Take the following query for example, which invokes the same CTE three times:\n\n```sql\nWITH t(x) AS (⟨complex_query⟩)\nSELECT *\nFROM\n t AS t1,\n t AS t2,\n t AS t3;", "position": 3, "token_count": 55, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-003", "document_id": "sql-query_syntax-with", "position": 3, "token_count": 55, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-004", "document_id": "sql-query_syntax-with", "content": "```\n\nInlining duplicates the definition of `t` for each reference which results in the following query:\n\n```sql\nSELECT *\nFROM\n (⟨complex_query⟩) AS t1(x),\n (⟨complex_query⟩) AS t2(x),\n (⟨complex_query⟩) AS t3(x);\n```\n\nIf `complex_query` is expensive, materializing it with the `MATERIALIZED` keyword can improve performance. In this case, `complex_query` is evaluated only once.\n\n```sql\nWITH t(x) AS MATERIALIZED (⟨complex_query⟩)\nSELECT *\nFROM\n t AS t1,\n t AS t2,\n t AS t3;\n```\n\nIf one wants to disable materialization, use `NOT MATERIALIZED`:\n\n```sql\nWITH t(x) AS NOT MATERIALIZED (⟨complex_query⟩)\nSELECT *\nFROM\n t AS t1,\n t AS t2,\n t AS t3;", "position": 4, "token_count": 205, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-004", "document_id": "sql-query_syntax-with", "position": 4, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-005", "document_id": "sql-query_syntax-with", "content": "```\n\nGenerally, it is not recommended to use explicit materialization hints, as DuckDB's query optimizer is capable of deciding when to materialize or inline a CTE based on the query structure and the heuristics mentioned above. However, in some cases, it may be beneficial to use `MATERIALIZED` or `NOT MATERIALIZED` to control the behavior explicitly.", "position": 5, "token_count": 80, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-005", "document_id": "sql-query_syntax-with", "position": 5, "token_count": 80, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-006", "document_id": "sql-query_syntax-with", "content": "## Recursive CTEs\n\n`WITH RECURSIVE` allows the definition of CTEs which can refer to themselves. Note that the query must be formulated in a way that ensures termination, otherwise, it may run into an infinite loop.", "position": 6, "token_count": 51, "has_code": false, "section_hierarchy": ["Recursive CTEs"], "metadata": {"chunk_id": "sql-query_syntax-with-006", "document_id": "sql-query_syntax-with", "position": 6, "token_count": 51, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Recursive CTEs"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#recursive-ctes"}}
{"chunk_id": "sql-query_syntax-with-007", "document_id": "sql-query_syntax-with", "content": "### Example: Fibonacci Sequence\n\n`WITH RECURSIVE` can be used to make recursive calculations. For example, here is how `WITH RECURSIVE` could be used to calculate the first ten Fibonacci numbers:\n\n```sql\nWITH RECURSIVE FibonacciNumbers (\n RecursionDepth, FibonacciNumber, NextNumber\n) AS (\n -- Base case\n SELECT\n 0 AS RecursionDepth,\n 0 AS FibonacciNumber,\n 1 AS NextNumber\n UNION ALL\n -- Recursive step\n SELECT\n fib.RecursionDepth + 1 AS RecursionDepth,\n fib.NextNumber AS FibonacciNumber,\n fib.FibonacciNumber + fib.NextNumber AS NextNumber\n FROM\n FibonacciNumbers fib\n WHERE\n fib.RecursionDepth + 1", "position": 7, "token_count": 196, "has_code": true, "section_hierarchy": ["Example: Fibonacci Sequence"], "metadata": {"chunk_id": "sql-query_syntax-with-007", "document_id": "sql-query_syntax-with", "position": 7, "token_count": 196, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Example: Fibonacci Sequence"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#example-fibonacci-sequence"}}
{"chunk_id": "sql-query_syntax-with-008", "document_id": "sql-query_syntax-with", "content": "```sql\nCREATE TABLE tag (id INTEGER, name VARCHAR, subclassof INTEGER);\nINSERT INTO tag VALUES\n (1, 'U2', 5),\n (2, 'Blur', 5),\n (3, 'Oasis', 5),\n (4, '2Pac', 6),\n (5, 'Rock', 7),\n (6, 'Rap', 7),\n (7, 'Music', 9),\n (8, 'Movies', 9),\n (9, 'Art', NULL);", "position": 8, "token_count": 119, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-008", "document_id": "sql-query_syntax-with", "position": 8, "token_count": 119, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-009", "document_id": "sql-query_syntax-with", "content": "```\n\nThe following query returns the path from the node `Oasis` to the root of the tree (`Art`).\n\n```sql\nWITH RECURSIVE tag_hierarchy(id, source, path) AS (\n SELECT id, name, [name] AS path\n FROM tag\n WHERE subclassof IS NULL\n UNION ALL\n SELECT tag.id, tag.name, list_prepend(tag.name, tag_hierarchy.path)\n FROM tag, tag_hierarchy\n WHERE tag.subclassof = tag_hierarchy.id\n )\nSELECT path\nFROM tag_hierarchy\nWHERE source = 'Oasis';\n```\n\n| path |\n|---------------------------|\n| [Oasis, Rock, Music, Art] |", "position": 9, "token_count": 171, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-009", "document_id": "sql-query_syntax-with", "position": 9, "token_count": 171, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-010", "document_id": "sql-query_syntax-with", "content": "### Graph Traversal\n\nThe `WITH RECURSIVE` clause can be used to express graph traversal on arbitrary graphs. However, if the graph has cycles, the query must perform cycle detection to prevent infinite loops.\nOne way to achieve this is to store the path of a traversal in a [list]({% link docs/stable/sql/data_types/list.md %}) and, before extending the path with a new edge, check whether its endpoint has been visited before (see the example later).\n\nTake the following directed graph from the [LDBC Graphalytics benchmark](https://arxiv.org/pdf/2011.15028.pdf):", "position": 10, "token_count": 151, "has_code": false, "section_hierarchy": ["Graph Traversal"], "metadata": {"chunk_id": "sql-query_syntax-with-010", "document_id": "sql-query_syntax-with", "position": 10, "token_count": 151, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Graph Traversal"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#graph-traversal"}}
{"chunk_id": "sql-query_syntax-with-011", "document_id": "sql-query_syntax-with", "content": "Take the following directed graph from the [LDBC Graphalytics benchmark](https://arxiv.org/pdf/2011.15028.pdf):\n\n```sql\nCREATE TABLE edge (node1id INTEGER, node2id INTEGER);\nINSERT INTO edge VALUES\n (1, 3), (1, 5), (2, 4), (2, 5), (2, 10), (3, 1),\n (3, 5), (3, 8), (3, 10), (5, 3), (5, 4), (5, 8),\n (6, 3), (6, 4), (7, 4), (8, 1), (9, 4);", "position": 11, "token_count": 164, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-011", "document_id": "sql-query_syntax-with", "position": 11, "token_count": 164, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-012", "document_id": "sql-query_syntax-with", "content": "```\n\nNote that the graph contains directed cycles, e.g., between nodes 1, 5 and 8.", "position": 12, "token_count": 26, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-012", "document_id": "sql-query_syntax-with", "position": 12, "token_count": 26, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-013", "document_id": "sql-query_syntax-with", "content": "#### Enumerate All Paths from a Node\n\nThe following query returns **all paths** starting in node 1:\n\n```sql\nWITH RECURSIVE paths(startNode, endNode, path) AS (\n SELECT -- Define the path as the first edge of the traversal\n node1id AS startNode,\n node2id AS endNode,\n [node1id, node2id] AS path\n FROM edge\n WHERE startNode = 1\n UNION ALL\n SELECT -- Concatenate new edge to the path\n paths.startNode AS startNode,\n node2id AS endNode,\n array_append(path, node2id) AS path\n FROM paths\n JOIN edge ON paths.endNode = node1id\n -- Prevent adding a repeated node to the path.\n -- This ensures that no cycles occur.\n WHERE list_position(paths.path, node2id) IS NULL\n )\nSELECT startNode, endNode, path\nFROM paths\nORDER BY length(path), path;", "position": 13, "token_count": 215, "has_code": true, "section_hierarchy": ["Enumerate All Paths from a Node"], "metadata": {"chunk_id": "sql-query_syntax-with-013", "document_id": "sql-query_syntax-with", "position": 13, "token_count": 215, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Enumerate All Paths from a Node"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#enumerate-all-paths-from-a-node"}}
{"chunk_id": "sql-query_syntax-with-014", "document_id": "sql-query_syntax-with", "content": "```\n\n| startNode | endNode | path |\n|----------:|--------:|---------------|\n| 1 | 3 | [1, 3] |\n| 1 | 5 | [1, 5] |\n| 1 | 5 | [1, 3, 5] |\n| 1 | 8 | [1, 3, 8] |\n| 1 | 10 | [1, 3, 10] |\n| 1 | 3 | [1, 5, 3] |\n| 1 | 4 | [1, 5, 4] |\n| 1 | 8 | [1, 5, 8] |\n| 1 | 4 | [1, 3, 5, 4] |\n| 1 | 8 | [1, 3, 5, 8] |\n| 1 | 8 | [1, 5, 3, 8] |\n| 1 | 10 | [1, 5, 3, 10] |", "position": 14, "token_count": 215, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-014", "document_id": "sql-query_syntax-with", "position": 14, "token_count": 215, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-015", "document_id": "sql-query_syntax-with", "content": "Note that the result of this query is not restricted to shortest paths, e.g., for node 5, the results include paths `[1, 5]` and `[1, 3, 5]`.", "position": 15, "token_count": 47, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-015", "document_id": "sql-query_syntax-with", "position": 15, "token_count": 47, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-016", "document_id": "sql-query_syntax-with", "content": "#### Enumerate Unweighted Shortest Paths from a Node\n\nIn most cases, enumerating all paths is not practical or feasible. Instead, only the **(unweighted) shortest paths** are of interest. To find these, the second half of the `WITH RECURSIVE` query should be adjusted such that it only includes a node if it has not yet been visited. This is implemented by using a subquery that checks if any of the previous paths includes the node:", "position": 16, "token_count": 106, "has_code": false, "section_hierarchy": ["Enumerate Unweighted Shortest Paths from a Node"], "metadata": {"chunk_id": "sql-query_syntax-with-016", "document_id": "sql-query_syntax-with", "position": 16, "token_count": 106, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Enumerate Unweighted Shortest Paths from a Node"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#enumerate-unweighted-shortest-paths-from-a-node"}}
{"chunk_id": "sql-query_syntax-with-017", "document_id": "sql-query_syntax-with", "content": "```sql\nWITH RECURSIVE paths(startNode, endNode, path) AS (\n SELECT -- Define the path as the first edge of the traversal\n node1id AS startNode,\n node2id AS endNode,\n [node1id, node2id] AS path\n FROM edge\n WHERE startNode = 1\n UNION ALL\n SELECT -- Concatenate new edge to the path\n paths.startNode AS startNode,\n node2id AS endNode,\n array_append(path, node2id) AS path\n FROM paths\n JOIN edge ON paths.endNode = node1id\n -- Prevent adding a node that was visited previously by any path.\n -- This ensures that (1) no cycles occur and (2) only nodes that\n -- were not visited by previous (shorter) paths are added to a path.\n WHERE NOT EXISTS (\n FROM paths previous_paths\n WHERE list_contains(previous_paths.path, node2id)\n )\n )\nSELECT startNode, endNode, path\nFROM paths\nORDER BY length(path), path;", "position": 17, "token_count": 227, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-017", "document_id": "sql-query_syntax-with", "position": 17, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-018", "document_id": "sql-query_syntax-with", "content": "```\n\n| startNode | endNode | path |\n|----------:|--------:|------------|\n| 1 | 3 | [1, 3] |\n| 1 | 5 | [1, 5] |\n| 1 | 8 | [1, 3, 8] |\n| 1 | 10 | [1, 3, 10] |\n| 1 | 4 | [1, 5, 4] |\n| 1 | 8 | [1, 5, 8] |", "position": 18, "token_count": 126, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-018", "document_id": "sql-query_syntax-with", "position": 18, "token_count": 126, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-019", "document_id": "sql-query_syntax-with", "content": "#### Enumerate Unweighted Shortest Paths between Two Nodes\n\n`WITH RECURSIVE` can also be used to find **all (unweighted) shortest paths between two nodes**. To ensure that the recursive query is stopped as soon as we reach the end node, we use a [window function]({% link docs/stable/sql/functions/window_functions.md %}) which checks whether the end node is among the newly added nodes.\n\nThe following query returns all unweighted shortest paths between nodes 1 (start node) and 8 (end node):", "position": 19, "token_count": 129, "has_code": false, "section_hierarchy": ["Enumerate Unweighted Shortest Paths between Two Nodes"], "metadata": {"chunk_id": "sql-query_syntax-with-019", "document_id": "sql-query_syntax-with", "position": 19, "token_count": 129, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Enumerate Unweighted Shortest Paths between Two Nodes"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#enumerate-unweighted-shortest-paths-between-two-nodes"}}
{"chunk_id": "sql-query_syntax-with-020", "document_id": "sql-query_syntax-with", "content": "```sql\nWITH RECURSIVE paths(startNode, endNode, path, endReached) AS (\n SELECT -- Define the path as the first edge of the traversal\n node1id AS startNode,\n node2id AS endNode,\n [node1id, node2id] AS path,\n (node2id = 8) AS endReached\n FROM edge\n WHERE startNode = 1\n UNION ALL\n SELECT -- Concatenate new edge to the path\n paths.startNode AS startNode,\n node2id AS endNode,\n array_append(path, node2id) AS path,\n max(CASE WHEN node2id = 8 THEN 1 ELSE 0 END)\n OVER (ROWS BETWEEN UNBOUNDED PRECEDING\n AND UNBOUNDED FOLLOWING) AS endReached\n FROM paths\n JOIN edge ON paths.endNode = node1id\n WHERE NOT EXISTS (\n FROM paths previous_paths\n WHERE list_contains(previous_paths.path, node2id)\n )\n AND paths.endReached = 0\n)\nSELECT startNode, endNode, path\nFROM paths\nWHERE endNode = 8\nORDER BY length(path), path;", "position": 20, "token_count": 242, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-020", "document_id": "sql-query_syntax-with", "position": 20, "token_count": 242, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-021", "document_id": "sql-query_syntax-with", "content": "```\n\n| startNode | endNode | path |\n|----------:|--------:|-----------|\n| 1 | 8 | [1, 3, 8] |\n| 1 | 8 | [1, 5, 8] |", "position": 21, "token_count": 77, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-021", "document_id": "sql-query_syntax-with", "position": 21, "token_count": 77, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-022", "document_id": "sql-query_syntax-with", "content": "## Recursive CTEs with `USING KEY`\n\n`USING KEY` alters the behavior of a regular recursive CTE.\n\nIn each iteration, a regular recursive CTE appends result rows to the union table, which ultimately defines the overall result of the CTE. In contrast, a CTE with `USING KEY` has the ability to update rows that have been placed in the union table in an earlier iteration: if the current iteration produces a row with key `k`, it replaces a row with the same key `k` in the union table (like a dictionary). If no such row exists in the union table yet, the new row is appended to the union table as usual.", "position": 22, "token_count": 151, "has_code": false, "section_hierarchy": ["Recursive CTEs with `USING KEY`"], "metadata": {"chunk_id": "sql-query_syntax-with-022", "document_id": "sql-query_syntax-with", "position": 22, "token_count": 151, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Recursive CTEs with `USING KEY`"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#recursive-ctes-with-using-key"}}
{"chunk_id": "sql-query_syntax-with-023", "document_id": "sql-query_syntax-with", "content": "This allows a CTE to exercise fine-grained control over the union table contents. Avoiding the append-only behavior can lead to significantly smaller union table sizes. This helps query runtime, memory consumption, and makes it feasible to access the union table while the iteration is still ongoing (this is impossible for regular recursive CTEs): in a CTE `WITH RECURSIVE T(...) USING KEY ...`, table `T` denotes the rows added by the last iteration (as is usual for recursive CTEs), while table `recurring.T` denotes the union table built so far. References to `recurring.T` allow for the elegant and idiomatic translation of rather complex algorithms into readable SQL code.", "position": 23, "token_count": 160, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-023", "document_id": "sql-query_syntax-with", "position": 23, "token_count": 160, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-024", "document_id": "sql-query_syntax-with", "content": "### Example: `USING KEY`\n\nThis is a recursive CTE where `USING KEY` has a key column (`a`) and a payload column (`b`).\nThe payload columns correspond to the columns to be overwritten.\nIn the first iteration we have two different keys, `1` and `2`.\nThese two keys will generate two new rows, `(1, 3)` and `(2, 4)`.\nIn the next iteration we produce a new key, `3`, which generates a new row.\nWe also generate the row `(2, 3)`, where `2` is a key that already exists from the previous iteration.\nThis will overwrite the old payload `4` with the new payload `3`.\n\n```sql\nWITH RECURSIVE tbl(a, b) USING KEY (a) AS (\n SELECT a, b\n FROM (VALUES (1, 3), (2, 4)) t(a, b)\n UNION\n SELECT a + 1, b\n FROM tbl\n WHERE a", "position": 24, "token_count": 223, "has_code": true, "section_hierarchy": ["Example: `USING KEY`"], "metadata": {"chunk_id": "sql-query_syntax-with-024", "document_id": "sql-query_syntax-with", "position": 24, "token_count": 223, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Example: `USING KEY`"], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with#example-using-key"}}
{"chunk_id": "sql-query_syntax-with-025", "document_id": "sql-query_syntax-with", "content": "```sql\nCREATE TABLE nodes (id INTEGER);\nINSERT INTO nodes VALUES (1), (2), (3), (4), (5), (6), (7), (8);\nCREATE TABLE edges (node1id INTEGER, node2id INTEGER);\nINSERT INTO edges VALUES\n (1, 3), (2, 3), (3, 7), (7, 8), (5, 4), (6, 4);", "position": 25, "token_count": 105, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-025", "document_id": "sql-query_syntax-with", "position": 25, "token_count": 105, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}
{"chunk_id": "sql-query_syntax-with-026", "document_id": "sql-query_syntax-with", "content": "```\n\n```sql\nWITH RECURSIVE connected_components(id, comp) USING KEY (id) AS (\n SELECT n.id, n.id AS comp\n FROM nodes AS n\n UNION (\n SELECT DISTINCT ON (previous_iter.id) previous_iter.id, initial_iter.comp\n FROM\n recurring.connected_components AS previous_iter,\n connected_components AS initial_iter,\n edges AS e\n WHERE ((e.node1id, e.node2id) = (previous_iter.id, initial_iter.id)\n OR (e.node2id, e.node1id) = (previous_iter.id, initial_iter.id))\n AND initial_iter.comp", "position": 26, "token_count": 165, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-with-026", "document_id": "sql-query_syntax-with", "position": 26, "token_count": 165, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/with.md", "url": "/sql/query_syntax/with", "title": "WITH Clause", "category": null, "tags": [], "section_url": "/sql/query_syntax/with"}}

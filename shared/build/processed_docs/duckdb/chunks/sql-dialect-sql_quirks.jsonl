{"chunk_id": "sql-dialect-sql_quirks-000", "document_id": "sql-dialect-sql_quirks", "content": "Like all programming languages and libraries, DuckDB has its share of idiosyncrasies and inconsistencies.\nSome are vestiges of our feathered friend's evolution; others are inevitable because we strive to adhere to the [SQL Standard](https://blog.ansi.org/sql-standard-iso-iec-9075-2023-ansi-x3-135/) and specifically to PostgreSQL's dialect (see the [“PostgreSQL Compatibility”]({% link docs/stable/sql/dialect/postgresql_compatibility.md %}) page for exceptions).\nThe rest may simply come down to different preferences, or we may even agree on what _should_ be done but just haven’t gotten around to it yet.\n\nAcknowledging these quirks is the best we can do, which is why we have compiled below a list of examples.", "position": 0, "token_count": 200, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-sql_quirks-000", "document_id": "sql-dialect-sql_quirks", "position": 0, "token_count": 200, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks"}}
{"chunk_id": "sql-dialect-sql_quirks-001", "document_id": "sql-dialect-sql_quirks", "content": "## Aggregating Empty Groups\n\nOn empty groups, the aggregate functions `sum`, `list`, and `string_agg` all return `NULL` instead of `0`, `[]` and `''`, respectively. This is dictated by the SQL Standard and obeyed by all SQL implementations we know. This behavior is inherited by the list aggregate [`list_sum`]({% link docs/stable/sql/functions/list.md %}#list_-rewrite-functions), but not by the DuckDB original [`list_dot_product`]({% link docs/stable/sql/functions/list.md %}#list_dot_productlist1-list2) which returns `0` on empty lists.", "position": 1, "token_count": 168, "has_code": false, "section_hierarchy": ["Aggregating Empty Groups"], "metadata": {"chunk_id": "sql-dialect-sql_quirks-001", "document_id": "sql-dialect-sql_quirks", "position": 1, "token_count": 168, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Aggregating Empty Groups"], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks#aggregating-empty-groups"}}
{"chunk_id": "sql-dialect-sql_quirks-002", "document_id": "sql-dialect-sql_quirks", "content": "## 0 vs. 1-Based Indexing\n\nTo comply with standard SQL, one-based indexing is used almost everywhere, e.g., array and string indexing and slicing, and window functions (`row_number`, `rank`, `dense_rank`). However, similarly to PostgreSQL, [JSON features use a zero-based indexing]({% link docs/stable/data/json/overview.md %}#indexing).", "position": 2, "token_count": 108, "has_code": false, "section_hierarchy": ["0 vs. 1-Based Indexing"], "metadata": {"chunk_id": "sql-dialect-sql_quirks-002", "document_id": "sql-dialect-sql_quirks", "position": 2, "token_count": 108, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["0 vs. 1-Based Indexing"], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks#0-vs-1-based-indexing"}}
{"chunk_id": "sql-dialect-sql_quirks-003", "document_id": "sql-dialect-sql_quirks", "content": "## Types\n\n### `UINT8` vs. `INT8`\n\n`UINT8` and `INT8` are aliases to integer types of different widths:\n\n* `UINT8` corresponds to `UTINYINT` because it's an _8-bit_ unsigned integer\n* `INT8` corresponds to `BIGINT` because it's an _8-byte_ signed integer\n\nExplanation: the `n` in the numeric type `INTn` and `UINTn` denote the width of the number in either bytes or bits.\n`INT1`, `INT2`, `INT4` correspond to the number of bytes, while `INT16`, `INT32` and `INT64` correpsond to the number of bits.\nThe same applies to `UINT` values.\nHowever, the value `n = 8` is a valid choice for both the number of bits and bytes.\nFor unsigned values, `UINT8` corresponds to `UTINYINT` (8 bits).\nFor signed values, `INT8` corresponds to `BIGINT` (8 bytes).", "position": 3, "token_count": 239, "has_code": false, "section_hierarchy": ["`UINT8` vs. `INT8`"], "metadata": {"chunk_id": "sql-dialect-sql_quirks-003", "document_id": "sql-dialect-sql_quirks", "position": 3, "token_count": 239, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`UINT8` vs. `INT8`"], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks#uint8-vs-int8"}}
{"chunk_id": "sql-dialect-sql_quirks-004", "document_id": "sql-dialect-sql_quirks", "content": "## Expressions", "position": 4, "token_count": 5, "has_code": false, "section_hierarchy": ["Expressions"], "metadata": {"chunk_id": "sql-dialect-sql_quirks-004", "document_id": "sql-dialect-sql_quirks", "position": 4, "token_count": 5, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Expressions"], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks#expressions"}}
{"chunk_id": "sql-dialect-sql_quirks-005", "document_id": "sql-dialect-sql_quirks", "content": "### Results That May Surprise You", "position": 5, "token_count": 10, "has_code": false, "section_hierarchy": ["Results That May Surprise You"], "metadata": {"chunk_id": "sql-dialect-sql_quirks-005", "document_id": "sql-dialect-sql_quirks", "position": 5, "token_count": 10, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Results That May Surprise You"], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks#results-that-may-surprise-you"}}
{"chunk_id": "sql-dialect-sql_quirks-006", "document_id": "sql-dialect-sql_quirks", "content": "| Expression | Result | Note |\n|----------------------------|---------|-------------------------------------------------------------------------------|\n| `-2^2` | `4.0` | PostgreSQL compatibility means the unary minus has higher precedence than the exponentiation operator. Use additional parentheses, e.g., `-(2^2)` or the [`pow` function]({% link docs/stable/sql/functions/numeric.md %}#powx-y), e.g., `-pow(2, 2)`, to avoid mistakes. |", "position": 6, "token_count": 235, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-sql_quirks-006", "document_id": "sql-dialect-sql_quirks", "position": 6, "token_count": 235, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks"}}
{"chunk_id": "sql-dialect-sql_quirks-007", "document_id": "sql-dialect-sql_quirks", "content": "| `'t' = true` | `true` | Compatible with PostgreSQL. |\n| `1 = '1'` | `true` | Compatible with PostgreSQL. |\n| `1 = ' 1'` | `true` | Compatible with PostgreSQL. |\n| `1 = '01'` | `true` | Compatible with PostgreSQL. |\n| `1 = ' 01 '` | `true` | Compatible with PostgreSQL. |\n| `1 = true` | `true` | Not compatible with PostgreSQL. |\n| `1 = '1.1'` | `true` | Not compatible with PostgreSQL. |\n| `1 IN (0, NULL)` | `NULL` | Makes sense if you think of the `NULL`s in the input and output as `UNKNOWN`. |\n| `1 in [0, NULL]` | `false` | |", "position": 7, "token_count": 211, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-sql_quirks-007", "document_id": "sql-dialect-sql_quirks", "position": 7, "token_count": 211, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks"}}
{"chunk_id": "sql-dialect-sql_quirks-008", "document_id": "sql-dialect-sql_quirks", "content": "| `1 in [0, NULL]` | `false` | |\n| `concat('abc', NULL)` | `abc` | Compatible with PostgreSQL. `list_concat` behaves similarly. |\n| `'abc' || NULL` | `NULL` | |", "position": 8, "token_count": 69, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-sql_quirks-008", "document_id": "sql-dialect-sql_quirks", "position": 8, "token_count": 69, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks"}}
{"chunk_id": "sql-dialect-sql_quirks-009", "document_id": "sql-dialect-sql_quirks", "content": "### `NaN` Values\n\n`'NaN'::FLOAT = 'NaN'::FLOAT` and `'NaN'::FLOAT > 3` violate IEEE-754 but mean floating point data types have a total order, like all other data types (beware the consequences for `greatest` / `least`).\n\n### `age` Function\n\n`age(x)` is `current_date - x` instead of `current_timestamp - x`. Another quirk inherited from PostgreSQL.\n\n### Extract Functions\n\n`list_extract` / `map_extract` return `NULL` on non-existing keys. `struct_extract` throws an error because keys of structs are like columns.", "position": 9, "token_count": 161, "has_code": false, "section_hierarchy": ["Extract Functions"], "metadata": {"chunk_id": "sql-dialect-sql_quirks-009", "document_id": "sql-dialect-sql_quirks", "position": 9, "token_count": 161, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Extract Functions"], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks#extract-functions"}}
{"chunk_id": "sql-dialect-sql_quirks-010", "document_id": "sql-dialect-sql_quirks", "content": "## Clauses\n\n### Automatic Column Deduplication in `SELECT`\n\nColumn names are deduplicated with the first occurrence shadowing the others:\n\n```sql\nCREATE TABLE tbl AS SELECT 1 AS a;\nSELECT a FROM (SELECT *, 2 AS a FROM tbl);\n```\n\n| a |\n|--:|\n| 1 |\n\n### Case Insensitivity for `SELECT`ing Columns\n\nDue to case-insensitivity, it's not possible to use `SELECT a FROM 'file.parquet'` when a column called `A` appears before the desired column `a` in `file.parquet`.\n\n### `USING SAMPLE`\n\nThe `USING SAMPLE` clause is syntactically placed after the `WHERE` and `GROUP BY` clauses (same as the `LIMIT` clause) but is semantically applied before both (unlike the `LIMIT` clause).", "position": 10, "token_count": 195, "has_code": true, "section_hierarchy": ["`USING SAMPLE`"], "metadata": {"chunk_id": "sql-dialect-sql_quirks-010", "document_id": "sql-dialect-sql_quirks", "position": 10, "token_count": 195, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`USING SAMPLE`"], "file_path": "sql/dialect/sql_quirks.md", "url": "/sql/dialect/sql_quirks", "title": "SQL Quirks", "category": null, "tags": [], "section_url": "/sql/dialect/sql_quirks#using-sample"}}

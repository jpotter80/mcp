{"chunk_id": "clients-julia-000", "document_id": "clients-julia", "content": "The DuckDB Julia package provides a high-performance front-end for DuckDB. Much like SQLite, DuckDB runs in-process within the Julia client, and provides a DBInterface front-end.\n\nThe package also supports multi-threaded execution. It uses Julia threads/tasks for this purpose. If you wish to run queries in parallel, you must launch Julia with multi-threading support (by e.g., setting the `JULIA_NUM_THREADS` environment variable).\n\n## Installation\n\nInstall DuckDB as follows:\n\n```julia\nusing Pkg\nPkg.add(\"DuckDB\")\n```\n\nAlternatively, enter the package manager using the `]` key, and issue the following command:\n\n```julia\npkg> add DuckDB\n```\n\n## Basics\n\n```julia\nusing DuckDB\n\n# create a new in-memory database\ncon = DBInterface.connect(DuckDB.DB, \":memory:\")\n\n# create a table\nDBInterface.execute(con, \"CREATE TABLE integers (i INTEGER)\")", "position": 0, "token_count": 231, "has_code": true, "section_hierarchy": ["create a table"], "metadata": {"chunk_id": "clients-julia-000", "document_id": "clients-julia", "position": 0, "token_count": 231, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["create a table"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#create-a-table"}}
{"chunk_id": "clients-julia-001", "document_id": "clients-julia", "content": "# create a table\nDBInterface.execute(con, \"CREATE TABLE integers (i INTEGER)\")\n\n# insert data by executing a prepared statement\nstmt = DBInterface.prepare(con, \"INSERT INTO integers VALUES(?)\")\nDBInterface.execute(stmt, [42])", "position": 1, "token_count": 69, "has_code": false, "section_hierarchy": ["insert data by executing a prepared statement"], "metadata": {"chunk_id": "clients-julia-001", "document_id": "clients-julia", "position": 1, "token_count": 69, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["insert data by executing a prepared statement"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#insert-data-by-executing-a-prepared-statement"}}
{"chunk_id": "clients-julia-002", "document_id": "clients-julia", "content": "# insert data by executing a prepared statement\nstmt = DBInterface.prepare(con, \"INSERT INTO integers VALUES(?)\")\nDBInterface.execute(stmt, [42])\n\n# query the database\nresults = DBInterface.execute(con, \"SELECT 42 a\")\nprint(results)\n```\n\nSome SQL statements, such as PIVOT and IMPORT DATABASE are executed as multiple prepared statements and will error when using `DuckDB.execute()`. Instead they can be run with `DuckDB.query()` instead of `DuckDB.execute()` and will always return a materialized result.\n\n## Scanning DataFrames\n\nThe DuckDB Julia package also provides support for querying Julia DataFrames. Note that the DataFrames are directly read by DuckDB â€“ they are not inserted or copied into the database itself.\n\nIf you wish to load data from a DataFrame into a DuckDB table you can run a `CREATE TABLE ... AS` or `INSERT INTO` query.\n\n```julia\nusing DuckDB\nusing DataFrames", "position": 2, "token_count": 228, "has_code": true, "section_hierarchy": ["Scanning DataFrames"], "metadata": {"chunk_id": "clients-julia-002", "document_id": "clients-julia", "position": 2, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Scanning DataFrames"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#scanning-dataframes"}}
{"chunk_id": "clients-julia-003", "document_id": "clients-julia", "content": "# create a new in-memory dabase\ncon = DBInterface.connect(DuckDB.DB)\n\n# create a DataFrame\ndf = DataFrame(a = [1, 2, 3], b = [42, 84, 42])\n\n# register it as a view in the database\nDuckDB.register_data_frame(con, df, \"my_df\")", "position": 3, "token_count": 86, "has_code": false, "section_hierarchy": ["register it as a view in the database"], "metadata": {"chunk_id": "clients-julia-003", "document_id": "clients-julia", "position": 3, "token_count": 86, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["register it as a view in the database"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#register-it-as-a-view-in-the-database"}}
{"chunk_id": "clients-julia-004", "document_id": "clients-julia", "content": "# register it as a view in the database\nDuckDB.register_data_frame(con, df, \"my_df\")\n\n# run a SQL query over the DataFrame\nresults = DBInterface.execute(con, \"SELECT * FROM my_df\")\nprint(results)\n```\n\n## Appender API\n\nThe DuckDB Julia package also supports the [Appender API]({% link docs/stable/data/appender.md %}), which is much faster than using prepared statements or individual `INSERT INTO` statements. Appends are made in row-wise format. For every column, an `append()` call should be made, after which the row should be finished by calling `flush()`. After all rows have been appended, `close()` should be used to finalize the Appender and clean up the resulting memory.\n\n```julia\nusing DuckDB, DataFrames, Dates\ndb = DuckDB.DB()", "position": 4, "token_count": 218, "has_code": true, "section_hierarchy": ["Appender API"], "metadata": {"chunk_id": "clients-julia-004", "document_id": "clients-julia", "position": 4, "token_count": 218, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Appender API"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#appender-api"}}
{"chunk_id": "clients-julia-005", "document_id": "clients-julia", "content": "# create a table\nDBInterface.execute(db,\n \"CREATE OR REPLACE TABLE data (id INTEGER PRIMARY KEY, value FLOAT, timestamp TIMESTAMP, date DATE)\")\n# create data to insert\nlen = 100\ndf = DataFrames.DataFrame(\n id = collect(1:len),\n value = rand(len),\n timestamp = Dates.now() + Dates.Second.(1:len),\n date = Dates.today() + Dates.Day.(1:len)\n )\n# append data by row\nappender = DuckDB.Appender(db, \"data\")\nfor i in eachrow(df)\n for j in i\n DuckDB.append(appender, j)\n end\n DuckDB.end_row(appender)\nend", "position": 5, "token_count": 175, "has_code": false, "section_hierarchy": ["append data by row"], "metadata": {"chunk_id": "clients-julia-005", "document_id": "clients-julia", "position": 5, "token_count": 175, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["append data by row"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#append-data-by-row"}}
{"chunk_id": "clients-julia-006", "document_id": "clients-julia", "content": "# close the appender after all rows\nDuckDB.close(appender)\n```", "position": 6, "token_count": 23, "has_code": true, "section_hierarchy": ["close the appender after all rows"], "metadata": {"chunk_id": "clients-julia-006", "document_id": "clients-julia", "position": 6, "token_count": 23, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["close the appender after all rows"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#close-the-appender-after-all-rows"}}
{"chunk_id": "clients-julia-007", "document_id": "clients-julia", "content": "## Concurrency\n\nWithin a Julia process, tasks are able to concurrently read and write to the database, as long as each task maintains its own connection to the database. In the example below, a single task is spawned to periodically read the database and many tasks are spawned to write to the database using both [`INSERT` statements]({% link docs/stable/sql/statements/insert.md %}) as well as the [Appender API]({% link docs/stable/data/appender.md %}).\n\n```julia\nusing Dates, DataFrames, DuckDB\ndb = DuckDB.DB()\nDBInterface.connect(db)\nDBInterface.execute(db, \"CREATE OR REPLACE TABLE data (date TIMESTAMP, id INTEGER)\")", "position": 7, "token_count": 173, "has_code": true, "section_hierarchy": ["Concurrency"], "metadata": {"chunk_id": "clients-julia-007", "document_id": "clients-julia", "position": 7, "token_count": 173, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Concurrency"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#concurrency"}}
{"chunk_id": "clients-julia-008", "document_id": "clients-julia", "content": "function run_reader(db)\n # create a DuckDB connection specifically for this task\n conn = DBInterface.connect(db)\n while true\n println(DBInterface.execute(conn,\n \"SELECT id, count(date) AS count, max(date) AS max_date\n FROM data GROUP BY id ORDER BY id\") |> DataFrames.DataFrame)\n Threads.sleep(1)\n end\n DBInterface.close(conn)\nend", "position": 8, "token_count": 102, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-julia-008", "document_id": "clients-julia", "position": 8, "token_count": 102, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia"}}
{"chunk_id": "clients-julia-009", "document_id": "clients-julia", "content": "# spawn one reader task\nThreads.@spawn run_reader(db)\n\nfunction run_inserter(db, id)\n # create a DuckDB connection specifically for this task\n conn = DBInterface.connect(db)\n for i in 1:1000\n Threads.sleep(0.01)\n DuckDB.execute(conn, \"INSERT INTO data VALUES (current_timestamp, ?)\"; id);\n end\n DBInterface.close(conn)\nend\n# spawn many insert tasks\nfor i in 1:100\n Threads.@spawn run_inserter(db, 1)\nend\n\nfunction run_appender(db, id)\n # create a DuckDB connection specifically for this task\n appender = DuckDB.Appender(db, \"data\")\n for i in 1:1000\n Threads.sleep(0.01)\n row = (Dates.now(Dates.UTC), id)\n for j in row\n DuckDB.append(appender, j);\n end\n DuckDB.end_row(appender);\n end\n DuckDB.close(appender);\nend", "position": 9, "token_count": 235, "has_code": false, "section_hierarchy": ["spawn many insert tasks"], "metadata": {"chunk_id": "clients-julia-009", "document_id": "clients-julia", "position": 9, "token_count": 235, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["spawn many insert tasks"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#spawn-many-insert-tasks"}}
{"chunk_id": "clients-julia-010", "document_id": "clients-julia", "content": "# spawn many appender tasks\nfor i in 1:100\n Threads.@spawn run_appender(db, 2)\nend\n```\n\n## Original Julia Connector\n\nCredits to kimmolinna for the [original DuckDB Julia connector](https://github.com/kimmolinna/DuckDB.jl).", "position": 10, "token_count": 76, "has_code": true, "section_hierarchy": ["Original Julia Connector"], "metadata": {"chunk_id": "clients-julia-010", "document_id": "clients-julia", "position": 10, "token_count": 76, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Original Julia Connector"], "file_path": "clients/julia.md", "url": "/clients/julia", "title": "Julia Client", "category": null, "tags": [], "section_url": "/clients/julia#original-julia-connector"}}

{"chunk_id": "sql-statements-attach-000", "document_id": "sql-statements-attach", "content": "DuckDB allows attaching to and detaching from database files.", "position": 0, "token_count": 16, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-000", "document_id": "sql-statements-attach", "position": 0, "token_count": 16, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-001", "document_id": "sql-statements-attach", "content": "## Examples\n\nAttach the database `file.db` with the alias inferred from the name (`file`):\n\n```sql\nATTACH 'file.db';\n```\n\nAttach the database `file.db` with an explicit alias (`file_db`):\n\n```sql\nATTACH 'file.db' AS file_db;\n```\n\nAttach the database `file.db` in read only mode:\n\n```sql\nATTACH 'file.db' (READ_ONLY);\n```\n\nAttach the database `file.db` with a block size of 16 kB:\n\n```sql\nATTACH 'file.db' (BLOCK_SIZE 16_384);\n```\n\nAttach the database `file.db` with a row group size of 2048 rows:\n\n```sql\nATTACH 'file.db' (ROW_GROUP_SIZE 2048);", "position": 1, "token_count": 189, "has_code": true, "section_hierarchy": ["Examples"], "metadata": {"chunk_id": "sql-statements-attach-001", "document_id": "sql-statements-attach", "position": 1, "token_count": 189, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Examples"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#examples"}}
{"chunk_id": "sql-statements-attach-002", "document_id": "sql-statements-attach", "content": "```\n\nAttach the database `file.db` with a row group size of 2048 rows:\n\n```sql\nATTACH 'file.db' (ROW_GROUP_SIZE 2048);\n```\n\nAttach a SQLite database for reading and writing (see the [`sqlite` extension]({% link docs/stable/core_extensions/sqlite.md %}) for more information):\n\n```sql\nATTACH 'sqlite_file.db' AS sqlite_db (TYPE sqlite);\n```\n\nAttach the database `file.db` if inferred database alias `file` does not yet exist:\n\n```sql\nATTACH IF NOT EXISTS 'file.db';\n```\n\nAttach the database `file.db` if explicit database alias `file_db` does not yet exist:\n\n```sql\nATTACH IF NOT EXISTS 'file.db' AS file_db;", "position": 2, "token_count": 196, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-002", "document_id": "sql-statements-attach", "position": 2, "token_count": 196, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-003", "document_id": "sql-statements-attach", "content": "```\n\nAttach the database `file.db` if explicit database alias `file_db` does not yet exist:\n\n```sql\nATTACH IF NOT EXISTS 'file.db' AS file_db;\n```\n\nAttach the database `file2.db` as alias `file_db` detaching and replacing the existing alias if it exists:\n\n```sql\nATTACH OR REPLACE 'file2.db' AS file_db;\n```\n\nCreate a table in the attached database with alias `file`:\n\n```sql\nCREATE TABLE file.new_table (i INTEGER);\n```\n\nDetach the database with alias `file`:\n\n```sql\nDETACH file;\n```\n\nShow a list of all attached databases:\n\n```sql\nSHOW DATABASES;\n```\n\nChange the default database that is used to the database `file`:\n\n```sql\nUSE file;\n```", "position": 3, "token_count": 192, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-003", "document_id": "sql-statements-attach", "position": 3, "token_count": 192, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-004", "document_id": "sql-statements-attach", "content": "## `ATTACH`\n\nThe `ATTACH` statement adds a new database file to the catalog that can be read from and written to.\nNote that attachment definitions are not persisted between sessions: when a new session is launched, you have to re-attach to all databases.", "position": 4, "token_count": 56, "has_code": false, "section_hierarchy": ["`ATTACH`"], "metadata": {"chunk_id": "sql-statements-attach-004", "document_id": "sql-statements-attach", "position": 4, "token_count": 56, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`ATTACH`"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#attach"}}
{"chunk_id": "sql-statements-attach-005", "document_id": "sql-statements-attach", "content": "### `ATTACH` Syntax\n\n`ATTACH` allows DuckDB to operate on multiple database files, and allows for transfer of data between different database files.\n\n`ATTACH` supports HTTP and S3 endpoints. For these, it creates a read-only connection by default.\nTherefore, the following two commands are equivalent:\n\n```sql\nATTACH 'https://blobs.duckdb.org/databases/stations.duckdb' AS stations_db;\nATTACH 'https://blobs.duckdb.org/databases/stations.duckdb' AS stations_db (READ_ONLY);\n```\n\nSimilarly, the following two commands connecting to S3 are equivalent:\n\n```sql\nATTACH 's3://⟨blobs-duckdb⟩/databases/stations.duckdb' AS stations_db;\nATTACH 's3://⟨blobs-duckdb⟩/databases/stations.duckdb' AS stations_db (READ_ONLY);\n```", "position": 5, "token_count": 213, "has_code": true, "section_hierarchy": ["`ATTACH` Syntax"], "metadata": {"chunk_id": "sql-statements-attach-005", "document_id": "sql-statements-attach", "position": 5, "token_count": 213, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`ATTACH` Syntax"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#attach-syntax"}}
{"chunk_id": "sql-statements-attach-006", "document_id": "sql-statements-attach", "content": "### Explicit Storage Versions\n\n[DuckDB v1.2.0 introduced the `STORAGE_VERSION` option]({% post_url 2025-02-05-announcing-duckdb-120 %}#explicit-storage-versions), which allows explicitly specifying the storage version.\nUsing this, you can opt-in to newer forwards-incompatible features:\n\n```sql\nATTACH 'file.db' (STORAGE_VERSION 'v1.2.0');\n```\n\nThis setting specifies the minimum DuckDB version that should be able to read the database file. When database files are written with this option, the resulting files cannot be opened by older DuckDB released versions than the specified version. They can be read by the specified version and all newer versions of DuckDB.\n\nFor more details, see the [“Storage” page]({% link docs/stable/internals/storage.md %}#explicit-storage-versions).", "position": 6, "token_count": 204, "has_code": true, "section_hierarchy": ["Explicit Storage Versions"], "metadata": {"chunk_id": "sql-statements-attach-006", "document_id": "sql-statements-attach", "position": 6, "token_count": 204, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Explicit Storage Versions"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#explicit-storage-versions"}}
{"chunk_id": "sql-statements-attach-007", "document_id": "sql-statements-attach", "content": "### Database Encryption\n\nDuckDB supports database encryption. By default, it uses [AES encryption](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) with a key length of 256 bits using the recommended [GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode) mode. The encryption covers the main database file, the write-ahead-log (WAL) file, and even temporary files. To attach to an encrypted database, use the `ATTACH` statement with an `ENCRYPTION_KEY`.\n\n```sql\nATTACH 'encrypted.db' AS enc_db (ENCRYPTION_KEY 'quack_quack');", "position": 7, "token_count": 159, "has_code": true, "section_hierarchy": ["Database Encryption"], "metadata": {"chunk_id": "sql-statements-attach-007", "document_id": "sql-statements-attach", "position": 7, "token_count": 159, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Database Encryption"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#database-encryption"}}
{"chunk_id": "sql-statements-attach-008", "document_id": "sql-statements-attach", "content": "```\n\nTo encrypt data, DuckDB can use either the built-in `mbedtls` library or the OpenSSL library from the [`httpfs` extension]({% link docs/stable/core_extensions/httpfs/overview.md %}). Note that the OpenSSL versions are much faster due to hardware acceleration, so make sure to load the `httpfs` for good encryption performance:\n\n```sql\nLOAD httpfs;\nATTACH 'encrypted.db' AS enc_db (ENCRYPTION_KEY 'quack_quack'); -- will be faster thanks to httpfs\n```\n\nTo change the AES mode to [CBC]() or [CTR](), use the `ENCRYPTION_CIPHER` option:\n\n```sql\nATTACH 'encrypted.db' AS enc_db (ENCRYPTION_KEY 'quack_quack', ENCRYPTION_CIPHER 'CBC');\nATTACH 'encrypted.db' AS enc_db (ENCRYPTION_KEY 'quack_quack', ENCRYPTION_CIPHER 'CTR');", "position": 8, "token_count": 242, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-008", "document_id": "sql-statements-attach", "position": 8, "token_count": 242, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-009", "document_id": "sql-statements-attach", "content": "```\n\nDatabase encryption implies using [storage version](#explicit-storage-versions) 1.4.0 or later.", "position": 9, "token_count": 29, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-009", "document_id": "sql-statements-attach", "position": 9, "token_count": 29, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-010", "document_id": "sql-statements-attach", "content": "### Options\n\nZero or more copy options may be provided within parentheses following the `ATTACH` statement. Parameter values can be passed in with or without wrapping in single quotes. Arbitrary expressions may be used for parameter values.", "position": 10, "token_count": 46, "has_code": false, "section_hierarchy": ["Options"], "metadata": {"chunk_id": "sql-statements-attach-010", "document_id": "sql-statements-attach", "position": 10, "token_count": 46, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Options"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#options"}}
{"chunk_id": "sql-statements-attach-011", "document_id": "sql-statements-attach", "content": "| Name | Description | Type | Default value |\n| ------------------- | --------------------------------------------------------------------------------------------------------------------------- | --------- | ------------- |\n| `ACCESS_MODE` | Access mode of the database (`AUTOMATIC`, `READ_ONLY`, or `READ_WRITE`). | `VARCHAR` | `automatic` |", "position": 11, "token_count": 223, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-011", "document_id": "sql-statements-attach", "position": 11, "token_count": 223, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-012", "document_id": "sql-statements-attach", "content": "| `ACCESS_MODE` | Access mode of the database (`AUTOMATIC`, `READ_ONLY`, or `READ_WRITE`). | `VARCHAR` | `automatic` |\n| `COMPRESS` | Whether the database is compressed. Only applicable for in-memory databases. | `VARCHAR` | `false` |\n| `TYPE` | The file type (`DUCKDB` or `SQLITE`), or deduced from the input string literal (MySQL, PostgreSQL). | `VARCHAR` | `DUCKDB` |\n| `BLOCK_SIZE` | The block size of a new database file. Must be a power of two and within [16384, 262144]. Cannot be set for existing files. | `UBIGINT` | `262144` |\n| `ROW_GROUP_SIZE` | The row group size of a new database file. | `UBIGINT` | `122880` |", "position": 12, "token_count": 215, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-012", "document_id": "sql-statements-attach", "position": 12, "token_count": 215, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-013", "document_id": "sql-statements-attach", "content": "| `ROW_GROUP_SIZE` | The row group size of a new database file. | `UBIGINT` | `122880` |\n| `STORAGE_VERSION` | The version of the storage used. | `VARCHAR` | `v1.0.0` |\n| `ENCRYPTION_KEY` | The encryption key used for encrypting the database. | `VARCHAR` | - |\n| `ENCRYPTION_CIPHER` | The encryption cipher used for encrypting the database (`CBC`, `CTR` or `GCM`). | `VARCHAR` | - |", "position": 13, "token_count": 136, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-013", "document_id": "sql-statements-attach", "position": 13, "token_count": 136, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-014", "document_id": "sql-statements-attach", "content": "## `DETACH`\n\nThe `DETACH` statement allows previously attached database files to be closed and detached, releasing any locks held on the database file.\n\nNote that it is not possible to detach from the default database: if you would like to do so, issue the [`USE` statement]({% link docs/stable/sql/statements/use.md %}) to change the default database to another one. For example, if you are connected to a persistent database, you may change to an in-memory database by issuing:\n\n```sql\nATTACH ':memory:' AS memory_db;\nUSE memory_db;\n```\n\n> Warning Closing the connection, e.g., invoking the [`close()` function in Python]({% link docs/stable/clients/python/dbapi.md %}#connection), does not release the locks held on the database files as the file handles are held by the main DuckDB instance (in Python's case, the `duckdb` module).\n\n### `DETACH` Syntax", "position": 14, "token_count": 232, "has_code": true, "section_hierarchy": ["`DETACH` Syntax"], "metadata": {"chunk_id": "sql-statements-attach-014", "document_id": "sql-statements-attach", "position": 14, "token_count": 232, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`DETACH` Syntax"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#detach-syntax"}}
{"chunk_id": "sql-statements-attach-015", "document_id": "sql-statements-attach", "content": "## Name Qualification\n\nThe fully qualified name of catalog objects contains the _catalog_, the _schema_ and the _name_ of the object. For example:\n\nAttach the database `new_db`:\n\n```sql\nATTACH 'new_db.db';\n```\n\nCreate the schema `my_schema` in the database `new_db`:\n\n```sql\nCREATE SCHEMA new_db.my_schema;\n```\n\nCreate the table `my_table` in the schema `my_schema`:\n\n```sql\nCREATE TABLE new_db.my_schema.my_table (col INTEGER);\n```\n\nRefer to the column `col` inside the table `my_table`:\n\n```sql\nSELECT new_db.my_schema.my_table.col FROM new_db.my_schema.my_table;", "position": 15, "token_count": 193, "has_code": true, "section_hierarchy": ["Name Qualification"], "metadata": {"chunk_id": "sql-statements-attach-015", "document_id": "sql-statements-attach", "position": 15, "token_count": 193, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Name Qualification"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#name-qualification"}}
{"chunk_id": "sql-statements-attach-016", "document_id": "sql-statements-attach", "content": "```\n\nNote that often the fully qualified name is not required. When a name is not fully qualified, the system looks for which entries to reference using the _catalog search path_. The default catalog search path includes the system catalog, the temporary catalog and the initially attached database together with the `main` schema.\n\nAlso note the rules on [identifiers and database names in particular]({% link docs/stable/sql/dialect/keywords_and_identifiers.md %}#database-names).", "position": 16, "token_count": 113, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-attach-016", "document_id": "sql-statements-attach", "position": 16, "token_count": 113, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach"}}
{"chunk_id": "sql-statements-attach-017", "document_id": "sql-statements-attach", "content": "### Default Database and Schema\n\nWhen a table is created without any qualifications, the table is created in the default schema of the default database. The default database is the database that is launched when the system is created – and the default schema is `main`.\n\nCreate the table `my_table` in the default database:\n\n```sql\nCREATE TABLE my_table (col INTEGER);\n```\n\n### Changing the Default Database and Schema\n\nThe default database and schema can be changed using the `USE` command.\n\nSet the default database schema to `new_db.main`:\n\n```sql\nUSE new_db;\n```\n\nSet the default database schema to `new_db.my_schema`:\n\n```sql\nUSE new_db.my_schema;\n```", "position": 17, "token_count": 176, "has_code": true, "section_hierarchy": ["Changing the Default Database and Schema"], "metadata": {"chunk_id": "sql-statements-attach-017", "document_id": "sql-statements-attach", "position": 17, "token_count": 176, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Changing the Default Database and Schema"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#changing-the-default-database-and-schema"}}
{"chunk_id": "sql-statements-attach-018", "document_id": "sql-statements-attach", "content": "### Resolving Conflicts\n\nWhen providing only a single qualification, the system can interpret this as _either_ a catalog _or_ a schema, as long as there are no conflicts. For example:\n\n```sql\nATTACH 'new_db.db';\nCREATE SCHEMA my_schema;\n```\n\nCreates the table `new_db.main.tbl`:\n\n```sql\nCREATE TABLE new_db.tbl (i INTEGER);\n```\n\nCreates the table `default_db.my_schema.tbl`:\n\n```sql\nCREATE TABLE my_schema.tbl (i INTEGER);\n```\n\nIf we create a conflict (i.e., we have both a schema and a catalog with the same name) the system requests that a fully qualified path is used instead:\n\n```sql\nCREATE SCHEMA new_db;\nCREATE TABLE new_db.tbl (i INTEGER);\n```\n\n```console\nBinder Error:\nAmbiguous reference to catalog or schema \"new_db\" - use a fully qualified path like \"memory.new_db\"\n```", "position": 18, "token_count": 240, "has_code": true, "section_hierarchy": ["Resolving Conflicts"], "metadata": {"chunk_id": "sql-statements-attach-018", "document_id": "sql-statements-attach", "position": 18, "token_count": 240, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Resolving Conflicts"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#resolving-conflicts"}}
{"chunk_id": "sql-statements-attach-019", "document_id": "sql-statements-attach", "content": "### Changing the Catalog Search Path\n\nThe catalog search path can be adjusted by setting the `search_path` configuration option, which uses a comma-separated list of values that will be on the search path. The following example demonstrates searching in two databases:\n\n```sql\nATTACH ':memory:' AS db1;\nATTACH ':memory:' AS db2;\nCREATE table db1.tbl1 (i INTEGER);\nCREATE table db2.tbl2 (j INTEGER);\n```\n\nReference the tables using their fully qualified name:\n\n```sql\nSELECT * FROM db1.tbl1;\nSELECT * FROM db2.tbl2;\n```\n\nOr set the search path and reference the tables using their name:\n\n```sql\nSET search_path = 'db1,db2';\nSELECT * FROM tbl1;\nSELECT * FROM tbl2;\n```", "position": 19, "token_count": 191, "has_code": true, "section_hierarchy": ["Changing the Catalog Search Path"], "metadata": {"chunk_id": "sql-statements-attach-019", "document_id": "sql-statements-attach", "position": 19, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Changing the Catalog Search Path"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#changing-the-catalog-search-path"}}
{"chunk_id": "sql-statements-attach-020", "document_id": "sql-statements-attach", "content": "## Transactional Semantics\n\nWhen running queries on multiple databases, the system opens separate transactions per database. The transactions are started _lazily_ by default – when a given database is referenced for the first time in a query, a transaction for that database will be started. `SET immediate_transaction_mode = true` can be toggled to change this behavior to eagerly start transactions in all attached databases instead.\n\nWhile multiple transactions can be active at a time – the system only supports _writing_ to a single attached database in a single transaction. If you try to write to multiple attached databases in a single transaction the following error will be thrown:\n\n```console\nAttempting to write to database \"db2\" in a transaction that has already modified database \"db1\" -\na single transaction can only write to a single attached database.\n```\n\nThe reason for this restriction is that the system does not maintain atomicity for transactions across attached databases. Transactions are only atomic _within_ each database file. By restricting the global transaction to write to only a single database file the atomicity guarantees are maintained.", "position": 20, "token_count": 225, "has_code": true, "section_hierarchy": ["Transactional Semantics"], "metadata": {"chunk_id": "sql-statements-attach-020", "document_id": "sql-statements-attach", "position": 20, "token_count": 225, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Transactional Semantics"], "file_path": "sql/statements/attach.md", "url": "/sql/statements/attach", "title": "ATTACH and DETACH Statements", "category": null, "tags": [], "section_url": "/sql/statements/attach#transactional-semantics"}}

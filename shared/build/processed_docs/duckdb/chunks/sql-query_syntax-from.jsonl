{"chunk_id": "sql-query_syntax-from-000", "document_id": "sql-query_syntax-from", "content": "The `FROM` clause specifies the *source* of the data on which the remainder of the query should operate. Logically, the `FROM` clause is where the query starts execution. The `FROM` clause can contain a single table, a combination of multiple tables that are joined together using `JOIN` clauses, or another `SELECT` query inside a subquery node. DuckDB also has an optional `FROM`-first syntax which enables you to also query without a `SELECT` statement.", "position": 0, "token_count": 104, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-000", "document_id": "sql-query_syntax-from", "position": 0, "token_count": 104, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-001", "document_id": "sql-query_syntax-from", "content": "## Examples\n\nSelect all columns from the table called `tbl`:\n\n```sql\nSELECT *\nFROM tbl;\n```\n\nSelect all columns from the table using the `FROM`-first syntax:\n\n```sql\nFROM tbl\nSELECT *;\n```\n\nSelect all columns using the `FROM`-first syntax and omitting the `SELECT` clause:\n\n```sql\nFROM tbl;\n```\n\nSelect all columns from the table called `tbl` through an alias `tn`:\n\n```sql\nSELECT tn.*\nFROM tbl tn;\n```\n\nUse a prefix alias:\n\n```sql\nSELECT tn.*\nFROM tn: tbl;\n```\n\nSelect all columns from the table `tbl` in the schema `schema_name`:\n\n```sql\nSELECT *\nFROM schema_name.tbl;", "position": 1, "token_count": 182, "has_code": true, "section_hierarchy": ["Examples"], "metadata": {"chunk_id": "sql-query_syntax-from-001", "document_id": "sql-query_syntax-from", "position": 1, "token_count": 182, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Examples"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#examples"}}
{"chunk_id": "sql-query_syntax-from-002", "document_id": "sql-query_syntax-from", "content": "```\n\nSelect all columns from the table `tbl` in the schema `schema_name`:\n\n```sql\nSELECT *\nFROM schema_name.tbl;\n```\n\nSelect the column `i` from the table function `range`, where the first column of the range function is renamed to `i`:\n\n```sql\nSELECT t.i\nFROM range(100) AS t(i);\n```\n\nSelect all columns from the CSV file called `test.csv`:\n\n```sql\nSELECT *\nFROM 'test.csv';\n```\n\nSelect all columns from a subquery:\n\n```sql\nSELECT *\nFROM (SELECT * FROM tbl);\n```\n\nSelect the entire row of the table as a struct:\n\n```sql\nSELECT t\nFROM t;", "position": 2, "token_count": 177, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-002", "document_id": "sql-query_syntax-from", "position": 2, "token_count": 177, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-003", "document_id": "sql-query_syntax-from", "content": "```\n\nSelect the entire row of the table as a struct:\n\n```sql\nSELECT t\nFROM t;\n```\n\nSelect the entire row of the subquery as a struct (i.e., a single column):\n\n```sql\nSELECT t\nFROM (SELECT unnest(generate_series(41, 43)) AS x, 'hello' AS y) t;\n```\n\nJoin two tables together:\n\n```sql\nSELECT *\nFROM tbl\nJOIN other_table\n ON tbl.key = other_table.key;\n```\n\nSelect a 10% sample from a table:\n\n```sql\nSELECT *\nFROM tbl\nTABLESAMPLE 10%;\n```\n\nSelect a sample of 10 rows from a table:\n\n```sql\nSELECT *\nFROM tbl\nTABLESAMPLE 10 ROWS;\n```\n\nUse the `FROM`-first syntax with `WHERE` clause and aggregation:\n\n```sql\nFROM range(100) AS t(i)\nSELECT sum(t.i)\nWHERE i % 2 = 0;\n```", "position": 3, "token_count": 226, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-003", "document_id": "sql-query_syntax-from", "position": 3, "token_count": 226, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-004", "document_id": "sql-query_syntax-from", "content": "### Table Functions", "position": 4, "token_count": 7, "has_code": false, "section_hierarchy": ["Table Functions"], "metadata": {"chunk_id": "sql-query_syntax-from-004", "document_id": "sql-query_syntax-from", "position": 4, "token_count": 7, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Table Functions"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#table-functions"}}
{"chunk_id": "sql-query_syntax-from-005", "document_id": "sql-query_syntax-from", "content": "Some functions in duckdb return entire tables rather than individual values. These functions are accordingly called _table functions_ and can be used with a `FROM` clause like regular table references.", "position": 5, "token_count": 39, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-005", "document_id": "sql-query_syntax-from", "position": 5, "token_count": 39, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-006", "document_id": "sql-query_syntax-from", "content": "Examples include [`read_csv`]({%link docs/stable/data/csv/overview.md %}#csv-functions), [`read_parquet`]({%link docs/stable/data/parquet/overview.md %}#read_parquet-function), [`range`]({% link docs/stable/sql/functions/list.md %}#rangestart-stop-step), [`generate_series`]({% link docs/stable/sql/functions/list.md %}#generate_seriesstart-stop-step), [`repeat`]({% link docs/stable/sql/functions/utility.md", "position": 6, "token_count": 165, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-006", "document_id": "sql-query_syntax-from", "position": 6, "token_count": 165, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-007", "document_id": "sql-query_syntax-from", "content": "%}#generate_seriesstart-stop-step), [`repeat`]({% link docs/stable/sql/functions/utility.md %}#repeat_rowvarargs-num_rows), [`unnest`]({% link docs/stable/sql/query_syntax/unnest.md %}), and [`glob`]({%link docs/stable/sql/functions/utility.md %}#globsearch_path) (note that some of the examples here can be used as both scalar and table functions).", "position": 7, "token_count": 139, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-007", "document_id": "sql-query_syntax-from", "position": 7, "token_count": 139, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-008", "document_id": "sql-query_syntax-from", "content": "For example,\n\n```sql\nSELECT *\nFROM 'test.csv';", "position": 8, "token_count": 19, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-008", "document_id": "sql-query_syntax-from", "position": 8, "token_count": 19, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-009", "document_id": "sql-query_syntax-from", "content": "```\n\nis implicitly translated to a call of the `read_csv` table function:\n\n```sql\nSELECT *\nFROM read_csv('test.csv');\n```\n\nAll table functions support a `WITH ORDINALITY` prefix, which extends the returned table by an integer column `ordinality` that enumerates the generated rows starting at `1`.\n\n```sql\nSELECT *\nFROM read_csv('test.csv') WITH ORDINALITY;\n```\n\nNote that the same result could be achieved using the [`row_number` window function]({% link docs/stable/sql/functions/window_functions.md %}#row_numberorder-by-ordering).\nIn the presence of [joins](#joins), however, `WITH ORDINALITY` allows enumerating one side of the join instead of the final result set, without having to resort to sub-queries.", "position": 9, "token_count": 210, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-009", "document_id": "sql-query_syntax-from", "position": 9, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-010", "document_id": "sql-query_syntax-from", "content": "## Joins\n\nJoins are a fundamental relational operation used to connect two tables or relations horizontally.\nThe relations are referred to as the _left_ and _right_ sides of the join\nbased on how they are written in the join clause.\nEach result row has the columns from both relations.\n\nA join uses a rule to match pairs of rows from each relation.\nOften this is a predicate, but there are other implied rules that may be specified.\n\n### Outer Joins\n\nRows that do not have any matches can still be returned if an `OUTER` join is specified.\nOuter joins can be one of:\n\n* `LEFT` (All rows from the left relation appear at least once)\n* `RIGHT` (All rows from the right relation appear at least once)\n* `FULL` (All rows from both relations appear at least once)\n\nA join that is not `OUTER` is `INNER` (only rows that get paired are returned).\n\nWhen an unpaired row is returned, the attributes from the other table are set to `NULL`.", "position": 10, "token_count": 214, "has_code": false, "section_hierarchy": ["Outer Joins"], "metadata": {"chunk_id": "sql-query_syntax-from-010", "document_id": "sql-query_syntax-from", "position": 10, "token_count": 214, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Outer Joins"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#outer-joins"}}
{"chunk_id": "sql-query_syntax-from-011", "document_id": "sql-query_syntax-from", "content": "### Cross Product Joins (Cartesian Product)\n\nThe simplest type of join is a `CROSS JOIN`.\nThere are no conditions for this type of join,\nand it just returns all the possible pairs.\n\nReturn all pairs of rows:\n\n```sql\nSELECT a.*, b.*\nFROM a\nCROSS JOIN b;\n```\n\nThis is equivalent to omitting the `JOIN` clause:\n\n```sql\nSELECT a.*, b.*\nFROM a, b;\n```", "position": 11, "token_count": 104, "has_code": true, "section_hierarchy": ["Cross Product Joins (Cartesian Product)"], "metadata": {"chunk_id": "sql-query_syntax-from-011", "document_id": "sql-query_syntax-from", "position": 11, "token_count": 104, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Cross Product Joins (Cartesian Product)"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#cross-product-joins-cartesian-product"}}
{"chunk_id": "sql-query_syntax-from-012", "document_id": "sql-query_syntax-from", "content": "### Conditional Joins\n\nMost joins are specified by a predicate that connects\nattributes from one side to attributes from the other side.\nThe conditions can be explicitly specified using an `ON` clause\nwith the join (clearer) or implied by the `WHERE` clause (old-fashioned).\n\nWe use the `l_regions` and the `l_nations` tables from the TPC-H schema:\n\n```sql\nCREATE TABLE l_regions (\n r_regionkey INTEGER NOT NULL PRIMARY KEY,\n r_name CHAR(25) NOT NULL,\n r_comment VARCHAR(152)\n);\n\nCREATE TABLE l_nations (\n n_nationkey INTEGER NOT NULL PRIMARY KEY,\n n_name CHAR(25) NOT NULL,\n n_regionkey INTEGER NOT NULL,\n n_comment VARCHAR(152),\n FOREIGN KEY (n_regionkey) REFERENCES l_regions(r_regionkey)\n);\n```\n\nReturn the regions for the nations:\n\n```sql\nSELECT n.*, r.*\nFROM l_nations n\nJOIN l_regions r ON (n_regionkey = r_regionkey);", "position": 12, "token_count": 235, "has_code": true, "section_hierarchy": ["Conditional Joins"], "metadata": {"chunk_id": "sql-query_syntax-from-012", "document_id": "sql-query_syntax-from", "position": 12, "token_count": 235, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Conditional Joins"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#conditional-joins"}}
{"chunk_id": "sql-query_syntax-from-013", "document_id": "sql-query_syntax-from", "content": "```\n\nReturn the regions for the nations:\n\n```sql\nSELECT n.*, r.*\nFROM l_nations n\nJOIN l_regions r ON (n_regionkey = r_regionkey);\n```\n\nIf the column names are the same and are required to be equal,\nthen the simpler `USING` syntax can be used:\n\n```sql\nCREATE TABLE l_regions (regionkey INTEGER NOT NULL PRIMARY KEY,\n name CHAR(25) NOT NULL,\n comment VARCHAR(152));\n\nCREATE TABLE l_nations (nationkey INTEGER NOT NULL PRIMARY KEY,\n name CHAR(25) NOT NULL,\n regionkey INTEGER NOT NULL,\n comment VARCHAR(152),\n FOREIGN KEY (regionkey) REFERENCES l_regions(regionkey));\n```\n\nReturn the regions for the nations:\n\n```sql\nSELECT n.*, r.*\nFROM l_nations n\nJOIN l_regions r USING (regionkey);", "position": 13, "token_count": 200, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-013", "document_id": "sql-query_syntax-from", "position": 13, "token_count": 200, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-014", "document_id": "sql-query_syntax-from", "content": "```\n\nReturn the regions for the nations:\n\n```sql\nSELECT n.*, r.*\nFROM l_nations n\nJOIN l_regions r USING (regionkey);\n```\n\nThe expressions do not have to be equalities â€“ any predicate can be used:\n\nReturn the pairs of jobs where one ran longer but cost less:\n\n```sql\nSELECT s1.t_id, s2.t_id\nFROM west s1, west s2\nWHERE s1.time > s2.time\n AND s1.cost\n\n| i | j |\n|--:|--:|\n| 0 | 1 |\n| 2 | 3 |\n| 1 | 2 |\n\nLateral joins are a generalization of correlated subqueries, as they can return multiple values per input value rather than only a single value.\n\n```sql\nSELECT *\nFROM\n generate_series(0, 1) t(i),\n LATERAL (SELECT i + 10 UNION ALL SELECT i + 100) t2(j);", "position": 14, "token_count": 210, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-014", "document_id": "sql-query_syntax-from", "position": 14, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-015", "document_id": "sql-query_syntax-from", "content": "```\n\n| i | j |\n|--:|----:|\n| 0 | 10 |\n| 1 | 11 |\n| 0 | 100 |\n| 1 | 101 |\n\nIt may be helpful to think about `LATERAL` as a loop where we iterate through the rows of the first subquery and use it as input to the second (`LATERAL`) subquery.\nIn the examples above, we iterate through table `t` and refer to its column `i` from the definition of table `t2`. The rows of `t2` form column `j` in the result.\n\nIt is possible to refer to multiple attributes from the `LATERAL` subquery. Using the table from the first example:\n\n```sql\nCREATE TABLE t1 AS\n SELECT *\n FROM range(3) t(i), LATERAL (SELECT i + 1) t2(j);\n\nSELECT *\n FROM t1, LATERAL (SELECT i + j) t2(k)\n ORDER BY ALL;", "position": 15, "token_count": 212, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-015", "document_id": "sql-query_syntax-from", "position": 15, "token_count": 212, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-016", "document_id": "sql-query_syntax-from", "content": "```\n\n| i | j | k |\n|--:|--:|--:|\n| 0 | 1 | 1 |\n| 1 | 2 | 3 |\n| 2 | 3 | 5 |\n\n> DuckDB detects when `LATERAL` joins should be used, making the use of the `LATERAL` keyword optional.", "position": 16, "token_count": 72, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-016", "document_id": "sql-query_syntax-from", "position": 16, "token_count": 72, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-017", "document_id": "sql-query_syntax-from", "content": "### Positional Joins\n\nWhen working with data frames or other embedded tables of the same size,\nthe rows may have a natural correspondence based on their physical order.\nIn scripting languages, this is easily expressed using a loop:\n\n```cpp\nfor (i = 0; i\n\n| x | s |\n|--:|------|\n| 1 | a |\n| 2 | b |\n| 3 | NULL |\n\nPositional joins are always `FULL OUTER` joins, i.e., missing values (the last values in the shorter column) are set to `NULL`.", "position": 17, "token_count": 126, "has_code": true, "section_hierarchy": ["Positional Joins"], "metadata": {"chunk_id": "sql-query_syntax-from-017", "document_id": "sql-query_syntax-from", "position": 17, "token_count": 126, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Positional Joins"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#positional-joins"}}
{"chunk_id": "sql-query_syntax-from-018", "document_id": "sql-query_syntax-from", "content": "### As-Of Joins\n\nA common operation when working with temporal or similarly-ordered data\nis to find the nearest (first) event in a reference table (such as prices).\nThis is called an _as-of join:_\n\nAttach prices to stock trades:\n\n```sql\nSELECT t.*, p.price\nFROM trades t\nASOF JOIN prices p\n ON t.symbol = p.symbol AND t.when >= p.when;", "position": 18, "token_count": 95, "has_code": true, "section_hierarchy": ["As-Of Joins"], "metadata": {"chunk_id": "sql-query_syntax-from-018", "document_id": "sql-query_syntax-from", "position": 18, "token_count": 95, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["As-Of Joins"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#as-of-joins"}}
{"chunk_id": "sql-query_syntax-from-019", "document_id": "sql-query_syntax-from", "content": "```\n\nThe `ASOF` join requires at least one inequality condition on the ordering field.\nThe inequality can be any inequality condition (`>=`, `>`, `=` on a temporal type.\nAny other conditions must be equalities (or `NOT DISTINCT`).\nThis means that the left/right order of the tables is significant.\n\n`ASOF` joins each left side row with at most one right side row.\nIt can be specified as an `OUTER` join to find unpaired rows\n(e.g., trades without prices or prices which have no trades.)\n\nAttach prices or NULLs to stock trades:\n\n```sql\nSELECT *\nFROM trades t\nASOF LEFT JOIN prices p\n ON t.symbol = p.symbol\n AND t.when >= p.when;\n```\n\n`ASOF` joins can also specify join conditions on matching column names with the `USING` syntax,\nbut the *last* attribute in the list must be the inequality,\nwhich will be greater than or equal to (`>=`):\n\n```sql\nSELECT *\nFROM trades t\nASOF JOIN prices p USING (symbol, \"when\");", "position": 19, "token_count": 244, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-019", "document_id": "sql-query_syntax-from", "position": 19, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-020", "document_id": "sql-query_syntax-from", "content": "```\n\nReturns symbol, trades.when, price (but NOT prices.when):\n\nIf you combine `USING` with a `SELECT *` like this,\nthe query will return the left side (probe) column values for the matches,\nnot the right side (build) column values.\nTo get the `prices` times in the example, you will need to list the columns explicitly:\n\n```sql\nSELECT t.symbol, t.when AS trade_when, p.when AS price_when, price\nFROM trades t\nASOF LEFT JOIN prices p USING (symbol, \"when\");\n```", "position": 20, "token_count": 129, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-query_syntax-from-020", "document_id": "sql-query_syntax-from", "position": 20, "token_count": 129, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from"}}
{"chunk_id": "sql-query_syntax-from-021", "document_id": "sql-query_syntax-from", "content": "### Self-Joins\n\nDuckDB allows self-joins for all types of joins.\nNote that tables need to be aliased, using the same table name without aliases will result in an error:\n\n```sql\nCREATE TABLE t (x INTEGER);\nSELECT * FROM t JOIN t USING(x);\n```\n\n```console\nBinder Error:\nDuplicate alias \"t\" in query!\n```\n\nAdding the aliases allows the query to parse successfully:\n\n```sql\nSELECT * FROM t AS t1 JOIN t AS t2 USING(x);\n```", "position": 21, "token_count": 124, "has_code": true, "section_hierarchy": ["Self-Joins"], "metadata": {"chunk_id": "sql-query_syntax-from-021", "document_id": "sql-query_syntax-from", "position": 21, "token_count": 124, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Self-Joins"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#self-joins"}}
{"chunk_id": "sql-query_syntax-from-022", "document_id": "sql-query_syntax-from", "content": "### Shorthands in the `JOIN` Clause\n\nYou can specify column names in the `JOIN` clause:\n\n```sql\nCREATE TABLE t1 (x INTEGER);\nCREATE TABLE t2 (y INTEGER);\nINSERT INTO t1 VALUES (1), (2), (4);\nINSERT INTO t2 VALUES (2), (3);\nSELECT * FROM t1 NATURAL JOIN t2 t2(x);\n```\n\n| x |\n|--:|\n| 2 |\n\nYou can also use the `VALUES` clause in the `JOIN` clause:\n\n```sql\nSELECT * FROM t1 NATURAL JOIN (VALUES (2), (4)) _(x);\n```\n\n| x |\n|--:|\n| 2 |\n| 4 |", "position": 22, "token_count": 166, "has_code": true, "section_hierarchy": ["Shorthands in the `JOIN` Clause"], "metadata": {"chunk_id": "sql-query_syntax-from-022", "document_id": "sql-query_syntax-from", "position": 22, "token_count": 166, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Shorthands in the `JOIN` Clause"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#shorthands-in-the-join-clause"}}
{"chunk_id": "sql-query_syntax-from-023", "document_id": "sql-query_syntax-from", "content": "## `FROM`-First Syntax\n\nDuckDB's SQL supports the `FROM`-first syntax, i.e., it allows putting the `FROM` clause before the `SELECT` clause or completely omitting the `SELECT` clause. We use the following example to demonstrate it:\n\n```sql\nCREATE TABLE tbl AS\n SELECT *\n FROM (VALUES ('a'), ('b')) t1(s), range(1, 3) t2(i);\n```\n\n### `FROM`-First Syntax with a `SELECT` Clause\n\nThe following statement demonstrates the use of the `FROM`-first syntax:\n\n```sql\nFROM tbl\nSELECT i, s;\n```\n\nThis is equivalent to:\n\n```sql\nSELECT i, s\nFROM tbl;\n```\n\n| i | s |\n|--:|---|\n| 1 | a |\n| 2 | a |\n| 1 | b |\n| 2 | b |", "position": 23, "token_count": 209, "has_code": true, "section_hierarchy": ["`FROM`-First Syntax with a `SELECT` Clause"], "metadata": {"chunk_id": "sql-query_syntax-from-023", "document_id": "sql-query_syntax-from", "position": 23, "token_count": 209, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`FROM`-First Syntax with a `SELECT` Clause"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#from-first-syntax-with-a-select-clause"}}
{"chunk_id": "sql-query_syntax-from-024", "document_id": "sql-query_syntax-from", "content": "### `FROM`-First Syntax without a `SELECT` Clause\n\nThe following statement demonstrates the use of the optional `SELECT` clause:\n\n```sql\nFROM tbl;\n```\n\nThis is equivalent to:\n\n```sql\nSELECT *\nFROM tbl;\n```\n\n| s | i |\n|---|--:|\n| a | 1 |\n| a | 2 |\n| b | 1 |\n| b | 2 |", "position": 24, "token_count": 94, "has_code": true, "section_hierarchy": ["`FROM`-First Syntax without a `SELECT` Clause"], "metadata": {"chunk_id": "sql-query_syntax-from-024", "document_id": "sql-query_syntax-from", "position": 24, "token_count": 94, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`FROM`-First Syntax without a `SELECT` Clause"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#from-first-syntax-without-a-select-clause"}}
{"chunk_id": "sql-query_syntax-from-025", "document_id": "sql-query_syntax-from", "content": "## Syntax", "position": 25, "token_count": 5, "has_code": false, "section_hierarchy": ["Syntax"], "metadata": {"chunk_id": "sql-query_syntax-from-025", "document_id": "sql-query_syntax-from", "position": 25, "token_count": 5, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Syntax"], "file_path": "sql/query_syntax/from.md", "url": "/sql/query_syntax/from", "title": "FROM and JOIN Clauses", "category": null, "tags": [], "section_url": "/sql/query_syntax/from#syntax"}}

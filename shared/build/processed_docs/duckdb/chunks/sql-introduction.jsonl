{"chunk_id": "sql-introduction-000", "document_id": "sql-introduction", "content": "Here we provide an overview of how to perform simple operations in SQL.\nThis tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL.\nThis tutorial is adapted from the [PostgreSQL tutorial](https://www.postgresql.org/docs/current/tutorial-sql-intro.html).\n\n> DuckDB's SQL dialect closely follows the conventions of the PostgreSQL dialect.\n> The few exceptions to this are listed on the [PostgreSQL compatibility page]({% link docs/stable/sql/dialect/postgresql_compatibility.md %}).\n\nIn the examples that follow, we assume that you have installed the DuckDB Command Line Interface (CLI) shell. See the [installation page]({% link install/index.html %}?environment=cli) for information on how to install the CLI.", "position": 0, "token_count": 207, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-000", "document_id": "sql-introduction", "position": 0, "token_count": 207, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-001", "document_id": "sql-introduction", "content": "## Concepts\n\nDuckDB is a relational database management system (RDBMS). That means it is a system for managing data stored in relations. A relation is essentially a mathematical term for a table.\n\nEach table is a named collection of rows. Each row of a given table has the same set of named columns, and each column is of a specific data type. Tables themselves are stored inside schemas, and a collection of schemas constitutes the entire database that you can access.", "position": 1, "token_count": 101, "has_code": false, "section_hierarchy": ["Concepts"], "metadata": {"chunk_id": "sql-introduction-001", "document_id": "sql-introduction", "position": 1, "token_count": 101, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Concepts"], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction#concepts"}}
{"chunk_id": "sql-introduction-002", "document_id": "sql-introduction", "content": "## Creating a New Table\n\nYou can create a new table by specifying the table name, along with all column names and their types:\n\n```sql\nCREATE TABLE weather (\n city VARCHAR,\n temp_lo INTEGER, -- minimum temperature on a day\n temp_hi INTEGER, -- maximum temperature on a day\n prcp FLOAT,\n date DATE\n);", "position": 2, "token_count": 77, "has_code": true, "section_hierarchy": ["Creating a New Table"], "metadata": {"chunk_id": "sql-introduction-002", "document_id": "sql-introduction", "position": 2, "token_count": 77, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Creating a New Table"], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction#creating-a-new-table"}}
{"chunk_id": "sql-introduction-003", "document_id": "sql-introduction", "content": "```\n\nYou can enter this into the shell with the line breaks. The command is not terminated until the semicolon.\n\nWhite space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands. That means you can type the command aligned differently than above, or even all on one line. Two dash characters (`--`) introduce comments. Whatever follows them is ignored up to the end of the line. SQL is case-insensitive about keywords and identifiers. When returning identifiers, [their original cases are preserved]({% link docs/stable/sql/dialect/keywords_and_identifiers.md %}#rules-for-case-sensitivity).\n\nIn the SQL command, we first specify the type of command that we want to perform: `CREATE TABLE`. After that follows the parameters for the command. First, the table name, `weather`, is given. Then the column names and column types follow.", "position": 3, "token_count": 214, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-003", "document_id": "sql-introduction", "position": 3, "token_count": 214, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-004", "document_id": "sql-introduction", "content": "`city VARCHAR` specifies that the table has a column called `city` that is of type `VARCHAR`. `VARCHAR` specifies a data type that can store text of arbitrary length. The temperature fields are stored in an `INTEGER` type, a type that stores integer numbers (i.e., whole numbers without a decimal point). `FLOAT` columns store single precision floating-point numbers (i.e., numbers with a decimal point). `DATE` stores a date (i.e., year, month, day combination). `DATE` only stores the specific day, not a time associated with that day.\n\nDuckDB supports the standard SQL types `INTEGER`, `SMALLINT`, `FLOAT`, `DOUBLE`, `DECIMAL`, `CHAR(n)`, `VARCHAR(n)`, `DATE`, `TIME` and `TIMESTAMP`.\n\nThe second example will store cities and their associated geographical location:\n\n```sql\nCREATE TABLE cities (\n name VARCHAR,\n lat DECIMAL,\n lon DECIMAL\n);", "position": 4, "token_count": 231, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-004", "document_id": "sql-introduction", "position": 4, "token_count": 231, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-005", "document_id": "sql-introduction", "content": "```\n\nFinally, it should be mentioned that if you don't need a table any longer or want to recreate it differently you can remove it using the following command:\n\n```sql\nDROP TABLE ⟨tablename⟩;\n```", "position": 5, "token_count": 52, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-005", "document_id": "sql-introduction", "position": 5, "token_count": 52, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-006", "document_id": "sql-introduction", "content": "## Populating a Table with Rows\n\nThe insert statement is used to populate a table with rows:\n\n```sql\nINSERT INTO weather\nVALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');\n```\n\nConstants that are not numeric values (e.g., text and dates) must be surrounded by single quotes (`''`), as in the example. Input dates for the date type must be formatted as `'YYYY-MM-DD'`.\n\nWe can insert into the `cities` table in the same manner.\n\n```sql\nINSERT INTO cities\nVALUES ('San Francisco', -194.0, 53.0);\n```\n\nThe syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly:\n\n```sql\nINSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\nVALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');", "position": 6, "token_count": 233, "has_code": true, "section_hierarchy": ["Populating a Table with Rows"], "metadata": {"chunk_id": "sql-introduction-006", "document_id": "sql-introduction", "position": 6, "token_count": 233, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Populating a Table with Rows"], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction#populating-a-table-with-rows"}}
{"chunk_id": "sql-introduction-007", "document_id": "sql-introduction", "content": "```\n\nYou can list the columns in a different order if you wish or even omit some columns, e.g., if the `prcp` is unknown:\n\n```sql\nINSERT INTO weather (date, city, temp_hi, temp_lo)\nVALUES ('1994-11-29', 'Hayward', 54, 37);\n```\n\n> Tip Many developers consider explicitly listing the columns better style than relying on the order implicitly.\n\nPlease enter all the commands shown above so you have some data to work with in the following sections.\n\nAlternatively, you can use the `COPY` statement. This is faster for large amounts of data because the `COPY` command is optimized for bulk loading while allowing less flexibility than `INSERT`. An example with [`weather.csv`]({% link data/weather.csv %}) would be:\n\n```sql\nCOPY weather\nFROM 'weather.csv';", "position": 7, "token_count": 203, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-007", "document_id": "sql-introduction", "position": 7, "token_count": 203, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-008", "document_id": "sql-introduction", "content": "```\n\nWhere the file name for the source file must be available on the machine running the process. There are many other ways of loading data into DuckDB, see the [corresponding documentation section]({% link docs/stable/data/overview.md %}) for more information.", "position": 8, "token_count": 63, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-008", "document_id": "sql-introduction", "position": 8, "token_count": 63, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-009", "document_id": "sql-introduction", "content": "## Querying a Table\n\nTo retrieve data from a table, the table is queried. A SQL `SELECT` statement is used to do this. The statement is divided into a select list (the part that lists the columns to be returned), a table list (the part that lists the tables from which to retrieve the data), and an optional qualification (the part that specifies any restrictions). For example, to retrieve all the rows of table weather, type:\n\n```sql\nSELECT *\nFROM weather;\n```\n\nHere `*` is a shorthand for “all columns”. So the same result would be had with:\n\n```sql\nSELECT city, temp_lo, temp_hi, prcp, date\nFROM weather;", "position": 9, "token_count": 157, "has_code": true, "section_hierarchy": ["Querying a Table"], "metadata": {"chunk_id": "sql-introduction-009", "document_id": "sql-introduction", "position": 9, "token_count": 157, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Querying a Table"], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction#querying-a-table"}}
{"chunk_id": "sql-introduction-010", "document_id": "sql-introduction", "content": "```\n\nThe output should be:\n\n| city | temp_lo | temp_hi | prcp | date |\n|---------------|--------:|--------:|-----:|------------|\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 |\n| San Francisco | 43 | 57 | 0.0 | 1994-11-29 |\n| Hayward | 37 | 54 | NULL | 1994-11-29 |\n\nYou can write expressions, not just simple column references, in the select list. For example, you can do:\n\n```sql\nSELECT city, (temp_hi + temp_lo) / 2 AS temp_avg, date\nFROM weather;", "position": 10, "token_count": 190, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-010", "document_id": "sql-introduction", "position": 10, "token_count": 190, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-011", "document_id": "sql-introduction", "content": "```\n\nThis should give:\n\n| city | temp_avg | date |\n|---------------|---------:|------------|\n| San Francisco | 48.0 | 1994-11-27 |\n| San Francisco | 50.0 | 1994-11-29 |\n| Hayward | 45.5 | 1994-11-29 |\n\nNotice how the `AS` clause is used to relabel the output column. (The `AS` clause is optional.)\n\nA query can be “qualified” by adding a `WHERE` clause that specifies which rows are wanted. The `WHERE` clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (`AND`, `OR`, and `NOT`) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:\n\n```sql\nSELECT *\nFROM weather\nWHERE city = 'San Francisco'\n AND prcp > 0.0;", "position": 11, "token_count": 243, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-011", "document_id": "sql-introduction", "position": 11, "token_count": 243, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-012", "document_id": "sql-introduction", "content": "```\n\nResult:\n\n| city | temp_lo | temp_hi | prcp | date |\n|---------------|--------:|--------:|-----:|------------|\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 |\n\nYou can request that the results of a query be returned in sorted order:\n\n```sql\nSELECT *\nFROM weather\nORDER BY city;", "position": 12, "token_count": 127, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-012", "document_id": "sql-introduction", "position": 12, "token_count": 127, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-013", "document_id": "sql-introduction", "content": "```\n\n| city | temp_lo | temp_hi | prcp | date |\n|---------------|--------:|--------:|-----:|------------|\n| Hayward | 37 | 54 | NULL | 1994-11-29 |\n| San Francisco | 43 | 57 | 0.0 | 1994-11-29 |\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 |\n\nIn this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:\n\n```sql\nSELECT *\nFROM weather\nORDER BY city, temp_lo;\n```\n\nYou can request that duplicate rows be removed from the result of a query:\n\n```sql\nSELECT DISTINCT city\nFROM weather;", "position": 13, "token_count": 216, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-013", "document_id": "sql-introduction", "position": 13, "token_count": 216, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-014", "document_id": "sql-introduction", "content": "```\n\nYou can request that duplicate rows be removed from the result of a query:\n\n```sql\nSELECT DISTINCT city\nFROM weather;\n```\n\n| city |\n|---------------|\n| San Francisco |\n| Hayward |\n\nHere again, the result row ordering might vary. You can ensure consistent results by using `DISTINCT` and `ORDER BY` together:\n\n```sql\nSELECT DISTINCT city\nFROM weather\nORDER BY city;\n```", "position": 14, "token_count": 103, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-014", "document_id": "sql-introduction", "position": 14, "token_count": 103, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-015", "document_id": "sql-introduction", "content": "## Joins between Tables\n\nThus far, our queries have only accessed one table at a time. Queries can access multiple tables at once, or access the same table in such a way that multiple rows of the table are being processed at the same time. A query that accesses multiple rows of the same or different tables at one time is called a join query. As an example, say you wish to list all the weather records together with the location of the associated city. To do that, we need to compare the city column of each row of the `weather` table with the name column of all rows in the `cities` table, and select the pairs of rows where these values match.\n\nThis would be accomplished by the following query:\n\n```sql\nSELECT *\nFROM weather, cities\nWHERE city = name;", "position": 15, "token_count": 167, "has_code": true, "section_hierarchy": ["Joins between Tables"], "metadata": {"chunk_id": "sql-introduction-015", "document_id": "sql-introduction", "position": 15, "token_count": 167, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Joins between Tables"], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction#joins-between-tables"}}
{"chunk_id": "sql-introduction-016", "document_id": "sql-introduction", "content": "```\n\n| city | temp_lo | temp_hi | prcp | date | name | lat | lon |\n|---------------|--------:|--------:|-----:|------------|---------------|---------:|-------:|\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 | San Francisco | -194.000 | 53.000 |\n| San Francisco | 43 | 57 | 0.0 | 1994-11-29 | San Francisco | -194.000 | 53.000 |\n\nObserve two things about the result set:", "position": 16, "token_count": 192, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-016", "document_id": "sql-introduction", "position": 16, "token_count": 192, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-017", "document_id": "sql-introduction", "content": "Observe two things about the result set:\n\n* There is no result row for the city of Hayward. This is because there is no matching entry in the `cities` table for Hayward, so the join ignores the unmatched rows in the `weather` table. We will see shortly how this can be fixed.\n* There are two columns containing the city name. This is correct because the lists of columns from the `weather` and `cities` tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using `*`:\n\n```sql\nSELECT city, temp_lo, temp_hi, prcp, date, lon, lat\nFROM weather, cities\nWHERE city = name;", "position": 17, "token_count": 163, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-017", "document_id": "sql-introduction", "position": 17, "token_count": 163, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-018", "document_id": "sql-introduction", "content": "```\n\n| city | temp_lo | temp_hi | prcp | date | lon | lat |\n|---------------|--------:|--------:|-----:|------------|-------:|---------:|\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 | 53.000 | -194.000 |\n| San Francisco | 43 | 57 | 0.0 | 1994-11-29 | 53.000 | -194.000 |\n\nSince the columns all had different names, the parser automatically found which table they belong to. If there were duplicate column names in the two tables you'd need to qualify the column names to show which one you meant, as in:", "position": 18, "token_count": 208, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-018", "document_id": "sql-introduction", "position": 18, "token_count": 208, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-019", "document_id": "sql-introduction", "content": "Since the columns all had different names, the parser automatically found which table they belong to. If there were duplicate column names in the two tables you'd need to qualify the column names to show which one you meant, as in:\n\n```sql\nSELECT weather.city, weather.temp_lo, weather.temp_hi,\n weather.prcp, weather.date, cities.lon, cities.lat\nFROM weather, cities\nWHERE cities.name = weather.city;", "position": 19, "token_count": 104, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-019", "document_id": "sql-introduction", "position": 19, "token_count": 104, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-020", "document_id": "sql-introduction", "content": "```\n\nIt is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.\n\nJoin queries of the kind seen thus far can also be written in this alternative form:\n\n```sql\nSELECT *\nFROM weather\nINNER JOIN cities ON weather.city = cities.name;\n```\n\nThis syntax is not as commonly used as the one above, but we show it here to help you understand the following topics.\n\nNow we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the `weather` table and for each row to find the matching cities row(s). If no matching row is found we want some “empty values” to be substituted for the `cities` table's columns. This kind of query is called an outer join. (The joins we have seen so far are inner joins.) The command looks like this:\n\n```sql\nSELECT *\nFROM weather\nLEFT OUTER JOIN cities ON weather.city = cities.name;", "position": 20, "token_count": 229, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-020", "document_id": "sql-introduction", "position": 20, "token_count": 229, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-021", "document_id": "sql-introduction", "content": "```\n\n| city | temp_lo | temp_hi | prcp | date | name | lat | lon |\n|---------------|--------:|--------:|-----:|------------|---------------|---------:|-------:|\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 | San Francisco | -194.000 | 53.000 |\n| San Francisco | 43 | 57 | 0.0 | 1994-11-29 | San Francisco | -194.000 | 53.000 |\n| Hayward | 37 | 54 | NULL | 1994-11-29 | NULL | NULL | NULL |", "position": 21, "token_count": 205, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-021", "document_id": "sql-introduction", "position": 21, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-022", "document_id": "sql-introduction", "content": "This query is called a left outer join because the table mentioned on the left of the join operator will have each of its rows in the output at least once, whereas the table on the right will only have those rows output that match some row of the left table. When outputting a left-table row for which there is no right-table match, empty (null) values are substituted for the right-table columns.", "position": 22, "token_count": 87, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-022", "document_id": "sql-introduction", "position": 22, "token_count": 87, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-023", "document_id": "sql-introduction", "content": "## Aggregate Functions\n\nLike most other relational database products, DuckDB supports aggregate functions. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the `count`, `sum`, `avg` (average), `max` (maximum) and `min` (minimum) over a set of rows.\n\nAs an example, we can find the highest low-temperature reading anywhere with:\n\n```sql\nSELECT max(temp_lo)\nFROM weather;\n```\n\n| max(temp_lo) |\n|-------------:|\n| 46 |\n\nIf we wanted to know what city (or cities) that reading occurred in, we might try:\n\n```sql\nSELECT city\nFROM weather\nWHERE temp_lo = max(temp_lo);\n```\n\nBut this will not work since the aggregate max cannot be used in the `WHERE` clause:\n\n```console\nBinder Error:\nWHERE clause cannot contain aggregates!", "position": 23, "token_count": 218, "has_code": true, "section_hierarchy": ["Aggregate Functions"], "metadata": {"chunk_id": "sql-introduction-023", "document_id": "sql-introduction", "position": 23, "token_count": 218, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Aggregate Functions"], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction#aggregate-functions"}}
{"chunk_id": "sql-introduction-024", "document_id": "sql-introduction", "content": "```\n\nBut this will not work since the aggregate max cannot be used in the `WHERE` clause:\n\n```console\nBinder Error:\nWHERE clause cannot contain aggregates!\n```\n\nThis restriction exists because the `WHERE` clause determines which rows will be included in the aggregate calculation; so obviously it has to be evaluated before aggregate functions are computed.\nHowever, as is often the case the query can be restated to accomplish the desired result, here by using a subquery:\n\n```sql\nSELECT city\nFROM weather\nWHERE temp_lo = (SELECT max(temp_lo) FROM weather);\n```\n\n| city |\n|---------------|\n| San Francisco |\n\nThis is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query.\n\nAggregates are also very useful in combination with `GROUP BY` clauses. For example, we can get the maximum low temperature observed in each city with:\n\n```sql\nSELECT city, max(temp_lo)\nFROM weather\nGROUP BY city;", "position": 24, "token_count": 235, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-024", "document_id": "sql-introduction", "position": 24, "token_count": 235, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-025", "document_id": "sql-introduction", "content": "```\n\n| city | max(temp_lo) |\n|---------------|--------------|\n| San Francisco | 46 |\n| Hayward | 37 |\n\nWhich gives us one output row per city. Each aggregate result is computed over the table rows matching that city. We can filter these grouped rows using `HAVING`:\n\n```sql\nSELECT city, max(temp_lo)\nFROM weather\nGROUP BY city\nHAVING max(temp_lo) '1994-11-28';\n```\n\nLook at the new state of the data:\n\n```sql\nSELECT *\nFROM weather;", "position": 25, "token_count": 148, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-025", "document_id": "sql-introduction", "position": 25, "token_count": 148, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-026", "document_id": "sql-introduction", "content": "```\n\nLook at the new state of the data:\n\n```sql\nSELECT *\nFROM weather;\n```\n\n| city | temp_lo | temp_hi | prcp | date |\n|---------------|--------:|--------:|-----:|------------|\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 |\n| San Francisco | 41 | 55 | 0.0 | 1994-11-29 |\n| Hayward | 35 | 52 | NULL | 1994-11-29 |", "position": 26, "token_count": 152, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-026", "document_id": "sql-introduction", "position": 26, "token_count": 152, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}
{"chunk_id": "sql-introduction-027", "document_id": "sql-introduction", "content": "## Deletions\n\nRows can be removed from a table using the `DELETE` command. Suppose you are no longer interested in the weather of Hayward. Then you can do the following to delete those rows from the table:\n\n```sql\nDELETE FROM weather\nWHERE city = 'Hayward';\n```\n\nAll weather records belonging to Hayward are removed.\n\n```sql\nSELECT *\nFROM weather;\n```\n\n| city | temp_lo | temp_hi | prcp | date |\n|---------------|--------:|--------:|-----:|------------|\n| San Francisco | 46 | 50 | 0.25 | 1994-11-27 |\n| San Francisco | 41 | 55 | 0.0 | 1994-11-29 |\n\nOne should be cautious when issuing statements of the following form:\n\n```sql\nDELETE FROM ⟨table_name⟩;", "position": 27, "token_count": 224, "has_code": true, "section_hierarchy": ["Deletions"], "metadata": {"chunk_id": "sql-introduction-027", "document_id": "sql-introduction", "position": 27, "token_count": 224, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Deletions"], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction#deletions"}}
{"chunk_id": "sql-introduction-028", "document_id": "sql-introduction", "content": "```\n\n> Warning Without a qualification, `DELETE` will remove all rows from the given table, leaving it empty. The system will not request confirmation before doing this.", "position": 28, "token_count": 38, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-introduction-028", "document_id": "sql-introduction", "position": 28, "token_count": 38, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/introduction.md", "url": "/sql/introduction", "title": "SQL Introduction", "category": null, "tags": [], "section_url": "/sql/introduction"}}

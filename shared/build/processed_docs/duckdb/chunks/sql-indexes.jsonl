{"chunk_id": "sql-indexes-000", "document_id": "sql-indexes", "content": "## Index Types\n\nDuckDB has two built-in index types. Indexes can also be defined via [extensions]({% link docs/stable/extensions/overview.md %}).\n\n### Min-Max Index (Zonemap)\n\nA [min-max index](https://en.wikipedia.org/wiki/Block_Range_Index) (also known as zonemap or block range index) is _automatically created_ for columns of all [general-purpose data types]({% link docs/stable/sql/data_types/overview.md %}).\n\n### Adaptive Radix Tree (ART)\n\nAn [Adaptive Radix Tree (ART)](https://db.in.tum.de/~leis/papers/ART.pdf) is mainly used to ensure primary key constraints and to speed up point and very highly selective (i.e., Warning ART indexes must currently be able to fit in memory during index creation. Avoid creating ART indexes if the index does not fit in memory during index creation.", "position": 0, "token_count": 235, "has_code": false, "section_hierarchy": ["Adaptive Radix Tree (ART)"], "metadata": {"chunk_id": "sql-indexes-000", "document_id": "sql-indexes", "position": 0, "token_count": 235, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Adaptive Radix Tree (ART)"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#adaptive-radix-tree-art"}}
{"chunk_id": "sql-indexes-001", "document_id": "sql-indexes", "content": "### Indexes Defined by Extensions\n\nDuckDB supports [R-trees for spatial indexing]({% link docs/stable/core_extensions/spatial/r-tree_indexes.md %}) via the `spatial` extension.", "position": 1, "token_count": 55, "has_code": false, "section_hierarchy": ["Indexes Defined by Extensions"], "metadata": {"chunk_id": "sql-indexes-001", "document_id": "sql-indexes", "position": 1, "token_count": 55, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Indexes Defined by Extensions"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#indexes-defined-by-extensions"}}
{"chunk_id": "sql-indexes-002", "document_id": "sql-indexes", "content": "## Persistence\n\nBoth min-max indexes and ART indexes are persisted on disk.\n\n## `CREATE INDEX` and `DROP INDEX` Statements\n\nTo create an [ART index](#adaptive-radix-tree-art), use the [`CREATE INDEX` statement]({% link docs/stable/sql/statements/create_index.md %}#create-index).\nTo drop an [ART index](#adaptive-radix-tree-art), use the [`DROP INDEX` statement]({% link docs/stable/sql/statements/create_index.md %}#drop-index).", "position": 2, "token_count": 142, "has_code": false, "section_hierarchy": ["`CREATE INDEX` and `DROP INDEX` Statements"], "metadata": {"chunk_id": "sql-indexes-002", "document_id": "sql-indexes", "position": 2, "token_count": 142, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`CREATE INDEX` and `DROP INDEX` Statements"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#create-index-and-drop-index-statements"}}
{"chunk_id": "sql-indexes-003", "document_id": "sql-indexes", "content": "## Limitations of ART Indexes\n\nART indexes create a secondary copy of the data in a second location.\nMaintaining that second copy complicates processing, particularly when combined with transactions.\nThus, certain limitations currently apply when it comes to modifying data that is also stored in secondary indexes.\n\n> As expected, indexes have a strong effect on performance, slowing down loading and updates, but speeding up certain queries. Please consult the [Performance Guide]({% link docs/stable/guides/performance/indexing.md %}) for details.", "position": 3, "token_count": 117, "has_code": false, "section_hierarchy": ["Limitations of ART Indexes"], "metadata": {"chunk_id": "sql-indexes-003", "document_id": "sql-indexes", "position": 3, "token_count": 117, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Limitations of ART Indexes"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#limitations-of-art-indexes"}}
{"chunk_id": "sql-indexes-004", "document_id": "sql-indexes", "content": "### Constraint Checking in `UPDATE` Statements\n\n`UPDATE` statements on indexed columns and columns that cannot be updated in place are transformed into a `DELETE` of the original row followed by an `INSERT` of the updated row.\nThis rewrite has performance implications, particularly for wide tables, as entire rows are rewritten instead of only the affected columns.\n\nAdditionally, it causes the following constraint-checking limitation of `UPDATE` statements.\nThe same limitation exists in other DBMSs, like PostgreSQL.\n\nIn the example below, note how the number of rows exceeds DuckDB's standard vector size, which is 2048 by default.\nThe `UPDATE` statement is rewritten into a `DELETE`, followed by an `INSERT`.\nThis rewrite happens per chunk of data (2048 rows) moving through DuckDB's processing pipeline.\nWhen updating `i = 2047` to `i = 2048`, we do not yet know that 2048 becomes 2049, and so forth.\nThat is because we have not yet seen that chunk.\nThus, we throw a constraint violation.", "position": 4, "token_count": 231, "has_code": false, "section_hierarchy": ["Constraint Checking in `UPDATE` Statements"], "metadata": {"chunk_id": "sql-indexes-004", "document_id": "sql-indexes", "position": 4, "token_count": 231, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Constraint Checking in `UPDATE` Statements"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#constraint-checking-in-update-statements"}}
{"chunk_id": "sql-indexes-005", "document_id": "sql-indexes", "content": "```sql\nCREATE TABLE my_table (i INTEGER PRIMARY KEY);\nINSERT INTO my_table SELECT range FROM range(3_000);\nUPDATE my_table SET i = i + 1;", "position": 5, "token_count": 44, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-005", "document_id": "sql-indexes", "position": 5, "token_count": 44, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}
{"chunk_id": "sql-indexes-006", "document_id": "sql-indexes", "content": "```\n\n```console\nConstraint Error:\nDuplicate key \"i: 2048\" violates primary key constraint.\n```\n\nA workaround is to split the `UPDATE` into a `DELETE ... RETURNING ...` followed by an `INSERT`,\nwith some additional logic to (temporarily) store the result of the `DELETE`.\nAll statements should be run inside a transaction via `BEGIN`, and eventually `COMMIT`.\n\nHere's an example of how that could look like in the command line client.\n\n```sql\nCREATE TABLE my_table (i INTEGER PRIMARY KEY);\nINSERT INTO my_table SELECT range FROM range(3_000);\n\nBEGIN;\nCREATE TEMP TABLE tmp AS SELECT i FROM my_table;\nDELETE FROM my_table;\nINSERT INTO my_table SELECT i FROM tmp;\nDROP TABLE tmp;\nCOMMIT;", "position": 6, "token_count": 185, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-006", "document_id": "sql-indexes", "position": 6, "token_count": 185, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}
{"chunk_id": "sql-indexes-007", "document_id": "sql-indexes", "content": "```\n\nIn other clients, you might be able to fetch the result of `DELETE ... RETURNING ...`.\nThen, you can use that result in a subsequent `INSERT ...` statements, or potentially make use of DuckDB's `Appender` (if available in the client).", "position": 7, "token_count": 70, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-007", "document_id": "sql-indexes", "position": 7, "token_count": 70, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}
{"chunk_id": "sql-indexes-008", "document_id": "sql-indexes", "content": "### Over-Eager Constraint Checking in Foreign Keys\n\nThis limitation occurs if you meet the following conditions:\n\n* A table has a `FOREIGN KEY` constraint.\n* There is an `UPDATE` on the corresponding `PRIMARY KEY` table, which DuckDB rewrites into a `DELETE` followed by an `INSERT`.\n* The to-be-deleted row exists in the foreign key table.\n\nIf these hold, you'll encounter an unexpected constraint violation:\n\n```sql\nCREATE TABLE pk_table (id INTEGER PRIMARY KEY, payload VARCHAR[]);\nINSERT INTO pk_table VALUES (1, ['hello']);\nCREATE TABLE fk_table (id INTEGER REFERENCES pk_table(id));\nINSERT INTO fk_table VALUES (1);\nUPDATE pk_table SET payload = ['world'] WHERE id = 1;\n```\n\n```console\nConstraint Error:\nViolates foreign key constraint because key \"id: 1\" is still referenced by a foreign key in a different table. If this is an unexpected constraint violation, please refer to our foreign key limitations in the documentation", "position": 8, "token_count": 236, "has_code": true, "section_hierarchy": ["Over-Eager Constraint Checking in Foreign Keys"], "metadata": {"chunk_id": "sql-indexes-008", "document_id": "sql-indexes", "position": 8, "token_count": 236, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Over-Eager Constraint Checking in Foreign Keys"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#over-eager-constraint-checking-in-foreign-keys"}}
{"chunk_id": "sql-indexes-009", "document_id": "sql-indexes", "content": "```\n\nThe reason for this is that DuckDB does not yet support “looking ahead”.\nDuring the `INSERT`, it is unaware it will reinsert the foreign key value as part of the `UPDATE` rewrite.", "position": 9, "token_count": 49, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-009", "document_id": "sql-indexes", "position": 9, "token_count": 49, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}
{"chunk_id": "sql-indexes-010", "document_id": "sql-indexes", "content": "### Constraint Checking after Delete with Concurrent Transactions\n\nTo better understand the limitations of indexes, we'll first provide a brief overview of index storage in DuckDB.\nDuckDB creates a physical secondary copy of the key column expressions and their row IDs when defining index-based constraints, or when using the `CREATE [UNIQUE] INDEX` statement.\nThat secondary structure lives in the physical storage of the table to which it belongs.\nNote that constraint violations are only relevant for primary key, foreign key, and `UNIQUE` indexes.\n\nWhen running transactions, DuckDB can only change or delete a value after there are no more dependencies to it from older transactions.\nI.e., after all older transactions that still need to see the old value have finished.\nDuckDB uses MVCC to ensure that transactionality.\nFor the table storage, each transaction knows if it still has visibility on a value or not.\nA transaction has visibility on a value, if it started before the `COMMIT` of the change/delete.\nSimilarly, it has no more visibility on the value, if it started afterward.", "position": 10, "token_count": 227, "has_code": false, "section_hierarchy": ["Constraint Checking after Delete with Concurrent Transactions"], "metadata": {"chunk_id": "sql-indexes-010", "document_id": "sql-indexes", "position": 10, "token_count": 227, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Constraint Checking after Delete with Concurrent Transactions"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#constraint-checking-after-delete-with-concurrent-transactions"}}
{"chunk_id": "sql-indexes-011", "document_id": "sql-indexes", "content": "**Indexes do not yet have such functionality.**\nLet's say that a `value-row_id` pair exists in the global index and there is a `COMMIT` changing/deleting that value.\nIn that case, it **also** stays visible to newer transactions until all **older**, dependent transactions have finished.\nThat behavior causes two main limitations, which are listed in more detail below.\n\nThe long-term solution to these limitations is to enable transaction-timestamp tracking in indexes.\nHowever, as-of now, DuckDB does not fully support MVCC for its indexes.", "position": 11, "token_count": 133, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-011", "document_id": "sql-indexes", "position": 11, "token_count": 133, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}
{"chunk_id": "sql-indexes-012", "document_id": "sql-indexes", "content": "#### Workarounds\n\nAs this is a limitation in DuckDB, there is currently no pure-SQL workaround.\nIf you have concurrent reads and writes on a table with indexes, then you need to add application-side locks.\nI.e., if you have multiple writes happening while a concurrent read is running, then these have to wait for the read(s) to finish.\n\nYou might also consider not using indexes altogether.\nInstead, DuckDB's `MERGE INTO` statement might suit your needs better.", "position": 12, "token_count": 111, "has_code": false, "section_hierarchy": ["Workarounds"], "metadata": {"chunk_id": "sql-indexes-012", "document_id": "sql-indexes", "position": 12, "token_count": 111, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Workarounds"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#workarounds"}}
{"chunk_id": "sql-indexes-013", "document_id": "sql-indexes", "content": "#### Over-Eager Unique Constraint Checking\n\nFor uniqueness constraints, inserts can fail when they should succeed:\n\n```cpp\n// Assume \"someTable\" is a table with an index enforcing uniqueness.\ntx1 = duckdbTxStart()\nsomeRecord = duckdb(tx1, \"SELECT * FROM someTable USING SAMPLE 1 ROWS\")\n\ntx2 = duckdbTxStart()\nduckdbDelete(tx2, someRecord)\nduckdbTxCommit(tx2)\n\n// At this point someRecord is deleted, but tx1 still needs visibility on that record.\n// Thus, the ART index is not updated, so the following query fails with a constraint error:\ntx3 = duckdbTxStart()\nduckdbInsert(tx3, someRecord)\nduckdbTxCommit(tx3)\n\n// Following this, the above insert succeeds because the ART index was allowed to update.\nduckdbTxCommit(tx1)", "position": 13, "token_count": 221, "has_code": true, "section_hierarchy": ["Over-Eager Unique Constraint Checking"], "metadata": {"chunk_id": "sql-indexes-013", "document_id": "sql-indexes", "position": 13, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Over-Eager Unique Constraint Checking"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#over-eager-unique-constraint-checking"}}
{"chunk_id": "sql-indexes-014", "document_id": "sql-indexes", "content": "```\n\nNote that in older versions of DuckDB some variations of this might've **seemed** to work (no constraint exception).\nThat is especially the case for `UPSERT` statements.\nHowever, these variations caused incorrect states, as constraint checking was incorrectly based on an already-deleted value.", "position": 14, "token_count": 66, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-014", "document_id": "sql-indexes", "position": 14, "token_count": 66, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}
{"chunk_id": "sql-indexes-015", "document_id": "sql-indexes", "content": "#### Under-Eager Foreign Key Constraint Checking\n\nFor foreign key constraints, inserts can succeed when they should fail:\n\n```cpp\n// Setup: Create a primary table with a UUID primary key and a secondary table with a foreign key reference.\nprimaryId = generateNewGUID()\nconn = duckdbConnectInMemory()\n\n// Create tables and insert the initial record in the primary table.\nduckdb(conn, \"CREATE TABLE primary_table (id UUID PRIMARY KEY)\")\nduckdb(conn, \"CREATE TABLE secondary_table (primary_id UUID, FOREIGN KEY (primary_id) REFERENCES primary_table(id))\")\nduckdbInsert(conn, \"primary_table\", {id: primaryId})\n\n// Start a transaction tx1, which reads from primary_table.\ntx1 = duckdbTxStart(conn)\nreadRecord = duckdb(tx1, \"SELECT id FROM primary_table LIMIT 1\")", "position": 15, "token_count": 221, "has_code": true, "section_hierarchy": ["Under-Eager Foreign Key Constraint Checking"], "metadata": {"chunk_id": "sql-indexes-015", "document_id": "sql-indexes", "position": 15, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Under-Eager Foreign Key Constraint Checking"], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes#under-eager-foreign-key-constraint-checking"}}
{"chunk_id": "sql-indexes-016", "document_id": "sql-indexes", "content": "// Note: tx1 remains open, holding locks/resources.\n// Outside of tx1, delete the record from primary_table.\nduckdbDelete(conn, \"primary_table\", {id: primaryId})\n\n// Try to insert into secondary_table, which has a foreign key reference to the now-deleted primary record.\n// This succeeds because tx1 is still open and the constraint isn't fully enforced yet.\nduckdbInsert(conn, \"secondary_table\", {primary_id: primaryId})\n\n// Commit tx1, releasing any locks/resources.\nduckdbTxCommit(tx1)\n\n// Verify the primary record is indeed deleted.\ncount = duckdb(conn, \"SELECT count() FROM primary_table WHERE id = $primaryId\", {primaryId: primaryId})\nassert(count == 0, \"Record should be deleted\")", "position": 16, "token_count": 199, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-016", "document_id": "sql-indexes", "position": 16, "token_count": 199, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}
{"chunk_id": "sql-indexes-017", "document_id": "sql-indexes", "content": "// Verify the secondary record with the foreign key reference exists, an inconsistent state!\ncount = duckdb(conn, \"SELECT count() FROM secondary_table WHERE primary_id = $primaryId\", {primaryId: primaryId})\nassert(count == 1, \"Foreign key reference should exist\")\n```", "position": 17, "token_count": 72, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-indexes-017", "document_id": "sql-indexes", "position": 17, "token_count": 72, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/indexes.md", "url": "/sql/indexes", "title": "Indexes", "category": null, "tags": [], "section_url": "/sql/indexes"}}

{"chunk_id": "sql-statements-merge_into-000", "document_id": "sql-statements-merge_into", "content": "The `MERGE INTO` statement is an alternative to `INSERT INTO ... ON CONFLICT` that doesn't need a primary key since it allows for a custom match condition. This is a very useful alternative for upserting use cases (`INSERT` + `UPDATE`) when the destination table does not have a primary key constraint.", "position": 0, "token_count": 71, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-merge_into-000", "document_id": "sql-statements-merge_into", "position": 0, "token_count": 71, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into"}}
{"chunk_id": "sql-statements-merge_into-001", "document_id": "sql-statements-merge_into", "content": "## Examples\n\nFirst, let's create a simple table.\n\n```sql\nCREATE TABLE people (id INTEGER, name VARCHAR, salary FLOAT);\nINSERT INTO people VALUES (1, 'John', 92_000.0), (2, 'Anna', 100_000.0);\n```\n\nThe simplest upsert would be updating or inserting a whole row.\n\n```sql\nMERGE INTO people\n USING (\n SELECT\n unnest([3, 1]) AS id,\n unnest(['Sarah', 'John']) AS name,\n unnest([95_000.0, 105_000.0]) AS salary\n ) AS upserts\n ON (upserts.id = people.id)\n WHEN MATCHED THEN UPDATE\n WHEN NOT MATCHED THEN INSERT;\n\nFROM people\nORDER BY id;", "position": 1, "token_count": 178, "has_code": true, "section_hierarchy": ["Examples"], "metadata": {"chunk_id": "sql-statements-merge_into-001", "document_id": "sql-statements-merge_into", "position": 1, "token_count": 178, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Examples"], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into#examples"}}
{"chunk_id": "sql-statements-merge_into-002", "document_id": "sql-statements-merge_into", "content": "```\n\n| id | name | salary |\n|---:|-------|---------:|\n| 1 | John | 105000.0 |\n| 2 | Anna | 100000.0 |\n| 3 | Sarah | 95000.0 |\n\nIn the previous example we are updating the whole row if `id` matches. However, it is also a common pattern to receive a _change set_ with some keys and the changed value. This is a good use for `SET`. If the match condition uses a column that has the same name in the source and destination, the keyword `USING` can be used in the match condition.\n\n```sql\nMERGE INTO people\n USING (\n SELECT\n 1 AS id,\n 98_000.0 AS salary\n ) AS salary_updates\n USING (id)\n WHEN MATCHED THEN UPDATE SET salary = salary_updates.salary;\n\nFROM people\nORDER BY id;", "position": 2, "token_count": 199, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-merge_into-002", "document_id": "sql-statements-merge_into", "position": 2, "token_count": 199, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into"}}
{"chunk_id": "sql-statements-merge_into-003", "document_id": "sql-statements-merge_into", "content": "```\n\n| id | name | salary |\n|---:|-------|---------:|\n| 1 | John | 98000.0 |\n| 2 | Anna | 100000.0 |\n| 3 | Sarah | 95000.0 |\n\nAnother common pattern is to receive a _delete set_ of rows, which may only contain ids of rows to be deleted.\n\n```sql\nMERGE INTO people\n USING (\n SELECT\n 1 AS id,\n ) AS deletes\n USING (id)\n WHEN MATCHED THEN DELETE;\n\nFROM people\nORDER BY id;", "position": 3, "token_count": 129, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-merge_into-003", "document_id": "sql-statements-merge_into", "position": 3, "token_count": 129, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into"}}
{"chunk_id": "sql-statements-merge_into-004", "document_id": "sql-statements-merge_into", "content": "```\n\n| id | name | salary |\n|---:|-------|---------:|\n| 2 | Anna | 100000.0 |\n| 3 | Sarah | 95000.0 |\n\n`MERGE INTO` also supports more complex conditions, for example, for a given _delete set_ we can decide to only remove rows that contain a `salary` bigger or equal than a certain amount.\n\n```sql\nMERGE INTO people\n USING (\n SELECT\n unnest([3, 2]) AS id,\n ) AS deletes\n USING (id)\n WHEN MATCHED AND people.salary >= 100_000.0 THEN DELETE;\n\nFROM people\nORDER BY id;", "position": 4, "token_count": 154, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-merge_into-004", "document_id": "sql-statements-merge_into", "position": 4, "token_count": 154, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into"}}
{"chunk_id": "sql-statements-merge_into-005", "document_id": "sql-statements-merge_into", "content": "```\n\n| id | name | salary |\n|---:|-------|--------:|\n| 3 | Sarah | 95000.0 |\n\nIf needed, DuckDB also supports multiple `UPDATE` and `DELETE` conditions. The `RETURNING` clause can be used to indicate which rows where affected by the `MERGE` statement.\n\n```sql\n-- Let's get John back in!\nINSERT INTO people VALUES (1, 'John', 105_000.0);\n\nMERGE INTO people\n USING (\n SELECT\n unnest([3, 1]) AS id,\n unnest([89_000.0, 70_000.0]) AS salary\n ) AS upserts\n USING (id)\n WHEN MATCHED AND people.salary 100_000.0 THEN DELETE\n WHEN NOT MATCHED THEN INSERT BY NAME\n RETURNING merge_action, *;", "position": 5, "token_count": 193, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-merge_into-005", "document_id": "sql-statements-merge_into", "position": 5, "token_count": 193, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into"}}
{"chunk_id": "sql-statements-merge_into-006", "document_id": "sql-statements-merge_into", "content": "```\n\n| merge_action | id | name | salary |\n|--------------|---:|-------|---------:|\n| UPDATE | 3 | Sarah | 89000.0 |\n| DELETE | 1 | John | 105000.0 |\n\nIn some cases, you may want to perform a different action specifically if the source doesn't meet a condition. For example, if we expect that data that is not present on the source shouldn't be present in the target:\n\n```sql\nCREATE TABLE source AS\n SELECT unnest([1,2]) AS id;\n\nMERGE INTO source\n USING (SELECT 1 AS id) target\n USING (id)\n WHEN MATCHED THEN UPDATE\n WHEN NOT MATCHED BY SOURCE THEN DELETE\n RETURNING merge_action, *;", "position": 6, "token_count": 186, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-merge_into-006", "document_id": "sql-statements-merge_into", "position": 6, "token_count": 186, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into"}}
{"chunk_id": "sql-statements-merge_into-007", "document_id": "sql-statements-merge_into", "content": "```\n\n| merge_action | id |\n|--------------|---:|\n| UPDATE | 1 |\n| DELETE | 2 |\n\nThere is also the possibility of specifying `WHEN NOT MATCHED BY TARGET`. However, the behavior is, as you may expect, the same as `WHEN NOT MATCHED` since by default when specifying conditions, we look at the target.", "position": 7, "token_count": 93, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-merge_into-007", "document_id": "sql-statements-merge_into", "position": 7, "token_count": 93, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into"}}
{"chunk_id": "sql-statements-merge_into-008", "document_id": "sql-statements-merge_into", "content": "## Syntax", "position": 8, "token_count": 5, "has_code": false, "section_hierarchy": ["Syntax"], "metadata": {"chunk_id": "sql-statements-merge_into-008", "document_id": "sql-statements-merge_into", "position": 8, "token_count": 5, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Syntax"], "file_path": "sql/statements/merge_into.md", "url": "/sql/statements/merge_into", "title": "MERGE INTO Statement", "category": null, "tags": [], "section_url": "/sql/statements/merge_into#syntax"}}

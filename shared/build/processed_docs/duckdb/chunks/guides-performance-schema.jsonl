{"chunk_id": "guides-performance-schema-000", "document_id": "guides-performance-schema", "content": "## Types\n\nIt is important to use the correct type for encoding columns (e.g., `BIGINT`, `DATE`, `DATETIME`). While it is always possible to use string types (`VARCHAR`, etc.) to encode more specific values, this is not recommended. Strings use more space and are slower to process in operations such as filtering, join, and aggregation.\n\nWhen loading CSV files, you may leverage the CSV reader's [auto-detection mechanism]({% link docs/stable/data/csv/auto_detection.md %}) to get the correct types for CSV inputs.\n\nIf you run in a memory-constrained environment, using smaller data types (e.g., `TINYINT`) can reduce the amount of memory and disk space required to complete a query. DuckDB’s [bitpacking compression]({% post_url 2022-10-28-lightweight-compression %}#bit-packing) means small values stored in larger data types will not take up larger sizes on disk, but they will take up more memory during processing.", "position": 0, "token_count": 242, "has_code": false, "section_hierarchy": ["Types"], "metadata": {"chunk_id": "guides-performance-schema-000", "document_id": "guides-performance-schema", "position": 0, "token_count": 242, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Types"], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema#types"}}
{"chunk_id": "guides-performance-schema-001", "document_id": "guides-performance-schema", "content": "> Bestpractice Use the most restrictive types possible when creating columns. Avoid using strings for encoding more specific data items.", "position": 1, "token_count": 27, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "guides-performance-schema-001", "document_id": "guides-performance-schema", "position": 1, "token_count": 27, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema"}}
{"chunk_id": "guides-performance-schema-002", "document_id": "guides-performance-schema", "content": "### Microbenchmark: Using Timestamps\n\nWe illustrate the difference in aggregation speed using the [`creationDate` column of the LDBC Comment table on scale factor 300](https://blobs.duckdb.org/data/ldbc-sf300-comments-creationDate.parquet). This table has approx. 554 million unordered timestamp values. We run a simple aggregation query that returns the average day-of-the month from the timestamps in two configurations.\n\nFirst, we use a `DATETIME` to encode the values and run the query using the [`extract` datetime function]({% link docs/stable/sql/functions/timestamp.md %}):\n\n```sql\nSELECT avg(extract('day' FROM creationDate)) FROM Comment;\n```\n\nSecond, we use the `VARCHAR` type and use string operations:\n\n```sql\nSELECT avg(CAST(creationDate[9:10] AS INTEGER)) FROM Comment;", "position": 2, "token_count": 227, "has_code": true, "section_hierarchy": ["Microbenchmark: Using Timestamps"], "metadata": {"chunk_id": "guides-performance-schema-002", "document_id": "guides-performance-schema", "position": 2, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Microbenchmark: Using Timestamps"], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema#microbenchmark-using-timestamps"}}
{"chunk_id": "guides-performance-schema-003", "document_id": "guides-performance-schema", "content": "```\n\nSecond, we use the `VARCHAR` type and use string operations:\n\n```sql\nSELECT avg(CAST(creationDate[9:10] AS INTEGER)) FROM Comment;\n```\n\nThe results of the microbenchmark are as follows:\n\n| Column type | Storage size | Query time |\n| ----------- | -----------: | ---------: |\n| `DATETIME` | 3.3 GB | 0.9 s |\n| `VARCHAR` | 5.2 GB | 3.9 s |\n\nThe results show that using the `DATETIME` value yields smaller storage sizes and faster processing.", "position": 3, "token_count": 159, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "guides-performance-schema-003", "document_id": "guides-performance-schema", "position": 3, "token_count": 159, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema"}}
{"chunk_id": "guides-performance-schema-004", "document_id": "guides-performance-schema", "content": "### Microbenchmark: Joining on Strings\n\nWe illustrate the difference caused by joining on different types by computing a self-join on the [LDBC Comment table at scale factor 100](https://blobs.duckdb.org/data/ldbc-sf100-comments.tar.zst). The table has 64-bit integer identifiers used as the `id` attribute of each row. We perform the following join operation:\n\n```sql\nSELECT count(*) AS count\nFROM Comment c1\nJOIN Comment c2 ON c1.ParentCommentId = c2.id;", "position": 4, "token_count": 128, "has_code": true, "section_hierarchy": ["Microbenchmark: Joining on Strings"], "metadata": {"chunk_id": "guides-performance-schema-004", "document_id": "guides-performance-schema", "position": 4, "token_count": 128, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Microbenchmark: Joining on Strings"], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema#microbenchmark-joining-on-strings"}}
{"chunk_id": "guides-performance-schema-005", "document_id": "guides-performance-schema", "content": "```\n\nIn the first experiment, we use the correct (most restrictive) types, i.e., both the `id` and the `ParentCommentId` columns are defined as `BIGINT`.\nIn the second experiment, we define all columns with the `VARCHAR` type.\nWhile the results of the queries are the same for all both experiments, their runtime vary significantly.\nThe results below show that joining on `BIGINT` columns is approx. 1.8× faster than performing the same join on `VARCHAR`-typed columns encoding the same value.", "position": 5, "token_count": 125, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "guides-performance-schema-005", "document_id": "guides-performance-schema", "position": 5, "token_count": 125, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema"}}
{"chunk_id": "guides-performance-schema-006", "document_id": "guides-performance-schema", "content": "| Join column payload type | Join column schema type | Example value | Query time |\n| ------------------------ | ----------------------- | ------------------ | ---------: |\n| `BIGINT` | `BIGINT` | `70368755640078` | 1.2 s |\n| `BIGINT` | `VARCHAR` | `'70368755640078'` | 2.1 s |\n\n> Bestpractice Avoid representing numeric values as strings, especially if you intend to perform e.g., join operations on them.", "position": 6, "token_count": 186, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "guides-performance-schema-006", "document_id": "guides-performance-schema", "position": 6, "token_count": 186, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema"}}
{"chunk_id": "guides-performance-schema-007", "document_id": "guides-performance-schema", "content": "## Constraints\n\nDuckDB allows defining [constraints]({% link docs/stable/sql/constraints.md %}) such as `UNIQUE`, `PRIMARY KEY`, and `FOREIGN KEY`. These constraints can be beneficial for ensuring data integrity but they have a negative effect on load performance as they necessitate building indexes and performing checks. Moreover, they _very rarely improve the performance of queries_ as DuckDB does not rely on these indexes for join and aggregation operators (see [indexing]({% link docs/stable/guides/performance/indexing.md %}) for more details).\n\n> Bestpractice Do not define constraints unless your goal is to ensure data integrity.", "position": 7, "token_count": 153, "has_code": false, "section_hierarchy": ["Constraints"], "metadata": {"chunk_id": "guides-performance-schema-007", "document_id": "guides-performance-schema", "position": 7, "token_count": 153, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Constraints"], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema#constraints"}}
{"chunk_id": "guides-performance-schema-008", "document_id": "guides-performance-schema", "content": "### Microbenchmark: The Effect of Primary Keys\n\nWe illustrate the effect of using primary keys with the [LDBC Comment table at scale factor 300](https://blobs.duckdb.org/data/ldbc-sf300-comments.tar.zst).\nThis table has approx. 554 million entries.\nIn the first experiments, we create the schema *without* a primary key, then load the data.\nIn the second experiment, we create the schema *with* a primary key, then load the data.\nIn the third case, we create the schema *without* a primary key, load the data and then add the primary key constraint.\nIn all cases, we take the data from `.csv.gz` files, and measure the time required to perform the loading.", "position": 8, "token_count": 177, "has_code": false, "section_hierarchy": ["Microbenchmark: The Effect of Primary Keys"], "metadata": {"chunk_id": "guides-performance-schema-008", "document_id": "guides-performance-schema", "position": 8, "token_count": 177, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Microbenchmark: The Effect of Primary Keys"], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema#microbenchmark-the-effect-of-primary-keys"}}
{"chunk_id": "guides-performance-schema-009", "document_id": "guides-performance-schema", "content": "| Operation | Execution time |\n|-----------------------------------------------|---------------:|\n| Load with primary key | 461.6 s |\n| Load without primary key | 121.0 s |\n| Load without primary key then add primary key | 242.0 s |\n\nFor this dataset, primary keys will only have a (small) positive effect on highly selective queries such as when filtering on a single identifier.\nDefining primary keys (or indexes) will not have an effect on join and aggregation operators.\n\n> Bestpractice For best bulk load performance, avoid primary key constraints.\n> If they are required, define them after the bulk loading step.", "position": 9, "token_count": 193, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "guides-performance-schema-009", "document_id": "guides-performance-schema", "position": 9, "token_count": 193, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "guides/performance/schema.md", "url": "/guides/performance/schema", "title": "Schema", "category": null, "tags": [], "section_url": "/guides/performance/schema"}}

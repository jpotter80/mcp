{"chunk_id": "sql-statements-insert-000", "document_id": "sql-statements-insert", "content": "The `INSERT` statement inserts new data into a table.\n\n## Examples\n\nInsert the values 1, 2, 3 into `tbl`:\n\n```sql\nINSERT INTO tbl\n VALUES (1), (2), (3);\n```\n\nInsert the result of a query into a table:\n\n```sql\nINSERT INTO tbl\n SELECT * FROM other_tbl;\n```\n\nInsert values into the `i` column, inserting the default value into other columns:\n\n```sql\nINSERT INTO tbl (i)\n VALUES (1), (2), (3);\n```\n\nExplicitly insert the default value into a column:\n\n```sql\nINSERT INTO tbl (i)\n VALUES (1), (DEFAULT), (3);\n```\n\nAssuming `tbl` has a primary key/unique constraint, do nothing on conflict:\n\n```sql\nINSERT OR IGNORE INTO tbl (i)\n VALUES (1);\n```\n\nOr update the table with the new values instead:\n\n```sql\nINSERT OR REPLACE INTO tbl (i)\n VALUES (1);\n```", "position": 0, "token_count": 236, "has_code": true, "section_hierarchy": ["Examples"], "metadata": {"chunk_id": "sql-statements-insert-000", "document_id": "sql-statements-insert", "position": 0, "token_count": 236, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Examples"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#examples"}}
{"chunk_id": "sql-statements-insert-001", "document_id": "sql-statements-insert", "content": "## Syntax\n\n`INSERT INTO` inserts new rows into a table. One can insert one or more rows specified by value expressions, or zero or more rows resulting from a query.", "position": 1, "token_count": 39, "has_code": false, "section_hierarchy": ["Syntax"], "metadata": {"chunk_id": "sql-statements-insert-001", "document_id": "sql-statements-insert", "position": 1, "token_count": 39, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Syntax"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#syntax"}}
{"chunk_id": "sql-statements-insert-002", "document_id": "sql-statements-insert", "content": "## Insert Column Order\n\nIt's possible to provide an optional insert column order, this can either be `BY POSITION` (the default) or `BY NAME`.\nEach column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or `NULL` if there is none.\n\nIf the expression for any column is not of the correct data type, automatic type conversion will be attempted.", "position": 2, "token_count": 91, "has_code": false, "section_hierarchy": ["Insert Column Order"], "metadata": {"chunk_id": "sql-statements-insert-002", "document_id": "sql-statements-insert", "position": 2, "token_count": 91, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Insert Column Order"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#insert-column-order"}}
{"chunk_id": "sql-statements-insert-003", "document_id": "sql-statements-insert", "content": "### `INSERT INTO ... [BY POSITION]`\n\nThe order that values are inserted into the columns of the table is determined by the order that the columns were declared in.\nThat is, the values supplied by the `VALUES` clause or query are associated with the column list left-to-right.\nThis is the default option, that can be explicitly specified using the `BY POSITION` option.\nFor example:\n\n```sql\nCREATE TABLE tbl (a INTEGER, b INTEGER);\nINSERT INTO tbl\n VALUES (5, 42);\n```\n\nSpecifying `BY POSITION` is optional and is equivalent to the default behavior:\n\n```sql\nINSERT INTO tbl\n BY POSITION\n VALUES (5, 42);\n```\n\nTo use a different order, column names can be provided as part of the target, for example:\n\n```sql\nCREATE TABLE tbl (a INTEGER, b INTEGER);\nINSERT INTO tbl (b, a)\n VALUES (5, 42);\n```\n\nAdding `BY POSITION` results in the same behavior:\n\n```sql\nINSERT INTO tbl\n BY POSITION (b, a)\n VALUES (5, 42);", "position": 3, "token_count": 242, "has_code": true, "section_hierarchy": ["`INSERT INTO ... [BY POSITION]`"], "metadata": {"chunk_id": "sql-statements-insert-003", "document_id": "sql-statements-insert", "position": 3, "token_count": 242, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`INSERT INTO ... [BY POSITION]`"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#insert-into--by-position"}}
{"chunk_id": "sql-statements-insert-004", "document_id": "sql-statements-insert", "content": "```\n\nAdding `BY POSITION` results in the same behavior:\n\n```sql\nINSERT INTO tbl\n BY POSITION (b, a)\n VALUES (5, 42);\n```\n\nThis will insert `5` into `b` and `42` into `a`.", "position": 4, "token_count": 60, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-insert-004", "document_id": "sql-statements-insert", "position": 4, "token_count": 60, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert"}}
{"chunk_id": "sql-statements-insert-005", "document_id": "sql-statements-insert", "content": "### `INSERT INTO ... BY NAME`\n\nUsing the `BY NAME` modifier, the names of the column list of the `SELECT` statement are matched against the column names of the table to determine the order that values should be inserted into the table. This allows inserting even in cases when the order of the columns in the table differs from the order of the values in the `SELECT` statement or certain columns are missing.\n\nFor example:\n\n```sql\nCREATE TABLE tbl (a INTEGER, b INTEGER);\nINSERT INTO tbl BY NAME (SELECT 42 AS b, 32 AS a);\nINSERT INTO tbl BY NAME (SELECT 22 AS b);\nSELECT * FROM tbl;\n```\n\n| a | b |\n|-----:|---:|\n| 32 | 42 |\n| NULL | 22 |\n\nIt's important to note that when using `INSERT INTO ... BY NAME`, the column names specified in the `SELECT` statement must match the column names in the table. If a column name is misspelled or does not exist in the table, an error will occur. Columns that are missing from the `SELECT` statement will be filled with the default value.", "position": 5, "token_count": 255, "has_code": true, "section_hierarchy": ["`INSERT INTO ... BY NAME`"], "metadata": {"chunk_id": "sql-statements-insert-005", "document_id": "sql-statements-insert", "position": 5, "token_count": 255, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`INSERT INTO ... BY NAME`"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#insert-into--by-name"}}
{"chunk_id": "sql-statements-insert-006", "document_id": "sql-statements-insert", "content": "## `ON CONFLICT` Clause\n\nAn `ON CONFLICT` clause can be used to perform a certain action on conflicts that arise from `UNIQUE` or `PRIMARY KEY` constraints.\nAn example for such a conflict is shown in the following example:\n\n```sql\nCREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);\nINSERT INTO tbl\n VALUES (1, 42);\nINSERT INTO tbl\n VALUES (1, 84);\n```\n\nThis raises as an error:\n\n```console\nConstraint Error:\nDuplicate key \"i: 1\" violates primary key constraint.\n```\n\nThe table will contain the row that was first inserted:\n\n```sql\nSELECT * FROM tbl;\n```\n\n| i | j |\n|--:|---:|\n| 1 | 42 |\n\nThese error messages can be avoided by explicitly handling conflicts.\nDuckDB supports two such clauses: [`ON CONFLICT DO NOTHING`](#do-nothing-clause) and [`ON CONFLICT DO UPDATE SET ...`](#do-update-clause-upsert).", "position": 6, "token_count": 226, "has_code": true, "section_hierarchy": ["`ON CONFLICT` Clause"], "metadata": {"chunk_id": "sql-statements-insert-006", "document_id": "sql-statements-insert", "position": 6, "token_count": 226, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`ON CONFLICT` Clause"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#on-conflict-clause"}}
{"chunk_id": "sql-statements-insert-007", "document_id": "sql-statements-insert", "content": "### `DO NOTHING` Clause\n\nThe `DO NOTHING` clause causes the error(s) to be ignored, and the values are not inserted or updated.\nFor example:\n\n```sql\nCREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);\nINSERT INTO tbl\n VALUES (1, 42);\nINSERT INTO tbl\n VALUES (1, 84)\n ON CONFLICT DO NOTHING;\n```\n\nThese statements finish successfully and leaves the table with the row ``.\n\n#### `INSERT OR IGNORE INTO`\n\nThe `INSERT OR IGNORE INTO ...` statement is a shorter syntax alternative to `INSERT INTO ... ON CONFLICT DO NOTHING`.\nFor example, the following statements are equivalent:\n\n```sql\nINSERT OR IGNORE INTO tbl\n VALUES (1, 84);\nINSERT INTO tbl\n VALUES (1, 84) ON CONFLICT DO NOTHING;\n```", "position": 7, "token_count": 182, "has_code": true, "section_hierarchy": ["`INSERT OR IGNORE INTO`"], "metadata": {"chunk_id": "sql-statements-insert-007", "document_id": "sql-statements-insert", "position": 7, "token_count": 182, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`INSERT OR IGNORE INTO`"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#insert-or-ignore-into"}}
{"chunk_id": "sql-statements-insert-008", "document_id": "sql-statements-insert", "content": "### `DO UPDATE` Clause (Upsert)\n\nThe `DO UPDATE` clause causes the `INSERT` to turn into an `UPDATE` on the conflicting row(s) instead.\nThe `SET` expressions that follow determine how these rows are updated. The expressions can use the special virtual table `EXCLUDED`, which contains the conflicting values for the row.\nOptionally you can provide an additional `WHERE` clause that can exclude certain rows from the update.\nThe conflicts that don't meet this condition are ignored instead.\n\nBecause we need a way to refer to both the **to-be-inserted** tuple and the **existing** tuple, we introduce the special `EXCLUDED` qualifier.\nWhen the `EXCLUDED` qualifier is provided, the reference refers to the **to-be-inserted** tuple, otherwise, it refers to the **existing** tuple.\nThis special qualifier can be used within the `WHERE` clauses and `SET` expressions of the `ON CONFLICT` clause.", "position": 8, "token_count": 214, "has_code": false, "section_hierarchy": ["`DO UPDATE` Clause (Upsert)"], "metadata": {"chunk_id": "sql-statements-insert-008", "document_id": "sql-statements-insert", "position": 8, "token_count": 214, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`DO UPDATE` Clause (Upsert)"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#do-update-clause-upsert"}}
{"chunk_id": "sql-statements-insert-009", "document_id": "sql-statements-insert", "content": "```sql\nCREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);\nINSERT INTO tbl VALUES (1, 42);\nINSERT INTO tbl VALUES (1, 52), (1, 62) ON CONFLICT DO UPDATE SET j = EXCLUDED.j;", "position": 9, "token_count": 58, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-insert-009", "document_id": "sql-statements-insert", "position": 9, "token_count": 58, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert"}}
{"chunk_id": "sql-statements-insert-010", "document_id": "sql-statements-insert", "content": "```", "position": 10, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-insert-010", "document_id": "sql-statements-insert", "position": 10, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert"}}
{"chunk_id": "sql-statements-insert-011", "document_id": "sql-statements-insert", "content": "#### Examples\n\nAn example using `DO UPDATE` is the following:\n\n```sql\nCREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);\nINSERT INTO tbl\n VALUES (1, 42);\nINSERT INTO tbl\n VALUES (1, 84)\n ON CONFLICT DO UPDATE SET j = EXCLUDED.j;\nSELECT * FROM tbl;\n```\n\n| i | j |\n|--:|---:|\n| 1 | 84 |\n\nRearranging columns and using `BY NAME` is also possible:\n\n```sql\nCREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);\nINSERT INTO tbl\n VALUES (1, 42);\nINSERT INTO tbl (j, i)\n VALUES (168, 1)\n ON CONFLICT DO UPDATE SET j = EXCLUDED.j;\nINSERT INTO tbl\n BY NAME (SELECT 1 AS i, 336 AS j)\n ON CONFLICT DO UPDATE SET j = EXCLUDED.j;\nSELECT * FROM tbl;\n```\n\n| i | j |\n|--:|----:|\n| 1 | 336 |", "position": 11, "token_count": 223, "has_code": true, "section_hierarchy": ["Examples"], "metadata": {"chunk_id": "sql-statements-insert-011", "document_id": "sql-statements-insert", "position": 11, "token_count": 223, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Examples"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#examples"}}
{"chunk_id": "sql-statements-insert-012", "document_id": "sql-statements-insert", "content": "#### `INSERT OR REPLACE INTO`\n\nThe `INSERT OR REPLACE INTO ...` statement is a shorter syntax alternative to `INSERT INTO ... DO UPDATE SET c1 = EXCLUDED.c1, c2 = EXCLUDED.c2, ...`.\nThat is, it updates every column of the **existing** row to the new values of the **to-be-inserted** row.\nFor example, given the following input table:\n\n```sql\nCREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);\nINSERT INTO tbl\n VALUES (1, 42);\n```\n\nThese statements are equivalent:\n\n```sql\nINSERT OR REPLACE INTO tbl\n VALUES (1, 84);\nINSERT INTO tbl\n VALUES (1, 84)\n ON CONFLICT DO UPDATE SET j = EXCLUDED.j;\nINSERT INTO tbl (j, i)\n VALUES (84, 1)\n ON CONFLICT DO UPDATE SET j = EXCLUDED.j;\nINSERT INTO tbl BY NAME\n (SELECT 84 AS j, 1 AS i)\n ON CONFLICT DO UPDATE SET j = EXCLUDED.j;\n```", "position": 12, "token_count": 227, "has_code": true, "section_hierarchy": ["`INSERT OR REPLACE INTO`"], "metadata": {"chunk_id": "sql-statements-insert-012", "document_id": "sql-statements-insert", "position": 12, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`INSERT OR REPLACE INTO`"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#insert-or-replace-into"}}
{"chunk_id": "sql-statements-insert-013", "document_id": "sql-statements-insert", "content": "#### Limitations\n\nWhen the `ON CONFLICT ... DO UPDATE` clause is used and a conflict occurs, DuckDB internally assigns `NULL` values to the row's columns that are unaffected by the conflict, then re-assigns their values. If the affected columns use a `NOT NULL` constraint, this will trigger a `NOT NULL constraint failed` error. For example:\n\n```sql\nCREATE TABLE t1 (id INTEGER PRIMARY KEY, val1 DOUBLE, val2 DOUBLE NOT NULL);\nCREATE TABLE t2 (id INTEGER PRIMARY KEY, val1 DOUBLE);\nINSERT INTO t1\n VALUES (1, 2, 3);\nINSERT INTO t2\n VALUES (1, 5);\n\nINSERT INTO t1 BY NAME (SELECT id, val1 FROM t2)\n ON CONFLICT DO UPDATE\n SET val1 = EXCLUDED.val1;\n```\n\nThis fails with the following error:\n\n```console\nConstraint Error:\nNOT NULL constraint failed: t1.val2\n```", "position": 13, "token_count": 204, "has_code": true, "section_hierarchy": ["Limitations"], "metadata": {"chunk_id": "sql-statements-insert-013", "document_id": "sql-statements-insert", "position": 13, "token_count": 204, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Limitations"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#limitations"}}
{"chunk_id": "sql-statements-insert-014", "document_id": "sql-statements-insert", "content": "#### Composite Primary Key\n\nWhen multiple columns need to be part of the uniqueness constraint, use a single `PRIMARY KEY` clause including all relevant columns:\n\n```sql\nCREATE TABLE t1 (id1 INTEGER, id2 INTEGER, val1 DOUBLE, PRIMARY KEY(id1, id2));\nINSERT OR REPLACE INTO t1\n VALUES (1, 2, 3);\nINSERT OR REPLACE INTO t1\n VALUES (1, 2, 4);\n```", "position": 14, "token_count": 100, "has_code": true, "section_hierarchy": ["Composite Primary Key"], "metadata": {"chunk_id": "sql-statements-insert-014", "document_id": "sql-statements-insert", "position": 14, "token_count": 100, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Composite Primary Key"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#composite-primary-key"}}
{"chunk_id": "sql-statements-insert-015", "document_id": "sql-statements-insert", "content": "### Defining a Conflict Target\n\nA conflict target may be provided as `ON CONFLICT (conflict_target)`. This is a group of columns that an index or uniqueness/key constraint is defined on. If the conflict target is omitted, or `PRIMARY KEY` constraint(s) on the table are targeted.\n\nSpecifying a conflict target is optional unless using a [`DO UPDATE`](#do-update-clause-upsert) and there are multiple unique/primary key constraints on the table.\n\n```sql\nCREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER UNIQUE, k INTEGER);\nINSERT INTO tbl\n VALUES (1, 20, 300);\nSELECT * FROM tbl;\n```\n\n| i | j | k |\n|--:|---:|----:|\n| 1 | 20 | 300 |\n\n```sql\nINSERT INTO tbl\n VALUES (1, 40, 700)\n ON CONFLICT (i) DO UPDATE SET k = 2 * EXCLUDED.k;", "position": 15, "token_count": 213, "has_code": true, "section_hierarchy": ["Defining a Conflict Target"], "metadata": {"chunk_id": "sql-statements-insert-015", "document_id": "sql-statements-insert", "position": 15, "token_count": 213, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Defining a Conflict Target"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#defining-a-conflict-target"}}
{"chunk_id": "sql-statements-insert-016", "document_id": "sql-statements-insert", "content": "```\n\n| i | j | k |\n|--:|---:|-----:|\n| 1 | 20 | 1400 |\n\n```sql\nINSERT INTO tbl\n VALUES (1, 20, 900)\n ON CONFLICT (j) DO UPDATE SET k = 5 * EXCLUDED.k;\n```\n\n| i | j | k |\n|--:|---:|-----:|\n| 1 | 20 | 4500 |\n\nWhen a conflict target is provided, you can further filter this with a `WHERE` clause, that should be met by all conflicts.\n\n```sql\nINSERT INTO tbl\n VALUES (1, 40, 700)\n ON CONFLICT (i) DO UPDATE SET k = 2 * EXCLUDED.k WHERE k < 100;\n```", "position": 16, "token_count": 169, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-insert-016", "document_id": "sql-statements-insert", "position": 16, "token_count": 169, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert"}}
{"chunk_id": "sql-statements-insert-017", "document_id": "sql-statements-insert", "content": "## `RETURNING` Clause\n\nThe `RETURNING` clause may be used to return the contents of the rows that were inserted. This can be useful if some columns are calculated upon insert. For example, if the table contains an automatically incrementing primary key, then the `RETURNING` clause will include the automatically created primary key. This is also useful in the case of generated columns.\n\nSome or all columns can be explicitly chosen to be returned and they may optionally be renamed using aliases. Arbitrary non-aggregating expressions may also be returned instead of simply returning a column. All columns can be returned using the `*` expression, and columns or expressions can be returned in addition to all columns returned by the `*`.\n\nFor example:\n\n```sql\nCREATE TABLE t1 (i INTEGER);\nINSERT INTO t1\n SELECT 42\n RETURNING *;\n```\n\n| i |\n|---:|\n| 42 |\n\nA more complex example that includes an expression in the `RETURNING` clause:\n\n```sql\nCREATE TABLE t2 (i INTEGER, j INTEGER);\nINSERT INTO t2\n SELECT 2 AS i, 3 AS j\n RETURNING *, i * j AS i_times_j;", "position": 17, "token_count": 246, "has_code": true, "section_hierarchy": ["`RETURNING` Clause"], "metadata": {"chunk_id": "sql-statements-insert-017", "document_id": "sql-statements-insert", "position": 17, "token_count": 246, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`RETURNING` Clause"], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert#returning-clause"}}
{"chunk_id": "sql-statements-insert-018", "document_id": "sql-statements-insert", "content": "```\n\n| i | j | i_times_j |\n|--:|--:|----------:|\n| 2 | 3 | 6 |\n\nThe next example shows a situation where the `RETURNING` clause is more helpful. First, a table is created with a primary key column. Then a sequence is created to allow for that primary key to be incremented as new rows are inserted. When we insert into the table, we do not already know the values generated by the sequence, so it is valuable to return them. For additional information, see the [`CREATE SEQUENCE` page]({% link docs/stable/sql/statements/create_sequence.md %}).\n\n```sql\nCREATE TABLE t3 (i INTEGER PRIMARY KEY, j INTEGER);\nCREATE SEQUENCE 't3_key';\nINSERT INTO t3\n SELECT nextval('t3_key') AS i, 42 AS j\n UNION ALL\n SELECT nextval('t3_key') AS i, 43 AS j\n RETURNING *;", "position": 18, "token_count": 226, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-insert-018", "document_id": "sql-statements-insert", "position": 18, "token_count": 226, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert"}}
{"chunk_id": "sql-statements-insert-019", "document_id": "sql-statements-insert", "content": "```\n\n| i | j |\n|--:|---:|\n| 1 | 42 |\n| 2 | 43 |", "position": 19, "token_count": 30, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-statements-insert-019", "document_id": "sql-statements-insert", "position": 19, "token_count": 30, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/statements/insert.md", "url": "/sql/statements/insert", "title": "INSERT Statement", "category": null, "tags": [], "section_url": "/sql/statements/insert"}}

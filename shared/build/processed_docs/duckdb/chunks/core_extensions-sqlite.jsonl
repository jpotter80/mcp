{"chunk_id": "core_extensions-sqlite-000", "document_id": "core_extensions-sqlite", "content": "The SQLite extension allows DuckDB to directly read and write data from a SQLite database file. The data can be queried directly from the underlying SQLite tables. Data can be loaded from SQLite tables into DuckDB tables, or vice versa.\n\n## Installing and Loading\n\nThe `sqlite` extension will be transparently [autoloaded]({% link docs/stable/extensions/overview.md %}#autoloading-extensions) on first use from the official extension repository.\nIf you would like to install and load it manually, run:\n\n```sql\nINSTALL sqlite;\nLOAD sqlite;\n```", "position": 0, "token_count": 131, "has_code": true, "section_hierarchy": ["Installing and Loading"], "metadata": {"chunk_id": "core_extensions-sqlite-000", "document_id": "core_extensions-sqlite", "position": 0, "token_count": 131, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Installing and Loading"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#installing-and-loading"}}
{"chunk_id": "core_extensions-sqlite-001", "document_id": "core_extensions-sqlite", "content": "## Usage\n\nTo make a SQLite file accessible to DuckDB, use the `ATTACH` statement with the `sqlite` or `sqlite_scanner` type. Attached SQLite databases support both read and write operations.\n\nFor example, to attach to the [`sakila.db` file](https://github.com/duckdb/sqlite_scanner/raw/main/data/db/sakila.db), run:\n\n```sql\nATTACH 'sakila.db' (TYPE sqlite);\nUSE sakila;\n```\n\nThe tables in the file can be read as if they were normal DuckDB tables, but the underlying data is read directly from the SQLite tables in the file at query time.\n\n```sql\nSHOW TABLES;", "position": 1, "token_count": 170, "has_code": true, "section_hierarchy": ["Usage"], "metadata": {"chunk_id": "core_extensions-sqlite-001", "document_id": "core_extensions-sqlite", "position": 1, "token_count": 170, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Usage"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#usage"}}
{"chunk_id": "core_extensions-sqlite-002", "document_id": "core_extensions-sqlite", "content": "```\n\n| name |\n|------------------------|\n| actor |\n| address |\n| category |\n| city |\n| country |\n| customer |\n| customer_list |\n| film |\n| film_actor |\n| film_category |\n| film_list |\n| film_text |\n| inventory |\n| language |\n| payment |\n| rental |\n| sales_by_film_category |\n| sales_by_store |\n| staff |\n| staff_list |\n| store |\n\nYou can query the tables using SQL, e.g., using the example queries from [`sakila-examples.sql`](https://github.com/duckdb/sqlite_scanner/blob/main/data/sql/sakila-examples.sql):", "position": 2, "token_count": 187, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-002", "document_id": "core_extensions-sqlite", "position": 2, "token_count": 187, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-003", "document_id": "core_extensions-sqlite", "content": "```sql\nSELECT\n cat.name AS category_name,\n sum(ifnull(pay.amount, 0)) AS revenue\nFROM category cat\nLEFT JOIN film_category flm_cat\n ON cat.category_id = flm_cat.category_id\nLEFT JOIN film fil\n ON flm_cat.film_id = fil.film_id\nLEFT JOIN inventory inv\n ON fil.film_id = inv.film_id\nLEFT JOIN rental ren\n ON inv.inventory_id = ren.inventory_id\nLEFT JOIN payment pay\n ON ren.rental_id = pay.rental_id\nGROUP BY cat.name\nORDER BY revenue DESC\nLIMIT 5;", "position": 3, "token_count": 143, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-003", "document_id": "core_extensions-sqlite", "position": 3, "token_count": 143, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-004", "document_id": "core_extensions-sqlite", "content": "```", "position": 4, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-004", "document_id": "core_extensions-sqlite", "position": 4, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-005", "document_id": "core_extensions-sqlite", "content": "## Data Types\n\nSQLite is a [weakly typed database system](https://www.sqlite.org/datatype3.html). As such, when storing data in a SQLite table, types are not enforced. The following is valid SQL in SQLite:\n\n```sql\nCREATE TABLE numbers (i INTEGER);\nINSERT INTO numbers VALUES ('hello');", "position": 5, "token_count": 83, "has_code": true, "section_hierarchy": ["Data Types"], "metadata": {"chunk_id": "core_extensions-sqlite-005", "document_id": "core_extensions-sqlite", "position": 5, "token_count": 83, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Data Types"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#data-types"}}
{"chunk_id": "core_extensions-sqlite-006", "document_id": "core_extensions-sqlite", "content": "```\n\nDuckDB is a strongly typed database system, as such, it requires all columns to have defined types and the system rigorously checks data for correctness.\n\nWhen querying SQLite, DuckDB must deduce a specific column type mapping. DuckDB follows SQLite's [type affinity rules](https://www.sqlite.org/datatype3.html#type_affinity) with a few extensions.", "position": 6, "token_count": 93, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-006", "document_id": "core_extensions-sqlite", "position": 6, "token_count": 93, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-007", "document_id": "core_extensions-sqlite", "content": "1. If the declared type contains the string `INT` then it is translated into the type `BIGINT`\n2. If the declared type of the column contains any of the strings `CHAR`, `CLOB`, or `TEXT` then it is translated into `VARCHAR`.\n3. If the declared type for a column contains the string `BLOB` or if no type is specified then it is translated into `BLOB`.\n4. If the declared type for a column contains any of the strings `REAL`, `FLOA`, `DOUB`, `DEC` or `NUM` then it is translated into `DOUBLE`.\n5. If the declared type is `DATE`, then it is translated into `DATE`.\n6. If the declared type contains the string `TIME`, then it is translated into `TIMESTAMP`.\n7. If none of the above apply, then it is translated into `VARCHAR`.", "position": 7, "token_count": 206, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-007", "document_id": "core_extensions-sqlite", "position": 7, "token_count": 206, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-008", "document_id": "core_extensions-sqlite", "content": "As DuckDB enforces the corresponding columns to contain only correctly typed values, we cannot load the string “hello” into a column of type `BIGINT`. As such, an error is thrown when reading from the “numbers” table above:\n\n```console\nMismatch Type Error: Invalid type in column \"i\": column was declared as integer, found \"hello\" of type \"text\" instead.", "position": 8, "token_count": 87, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-008", "document_id": "core_extensions-sqlite", "position": 8, "token_count": 87, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-009", "document_id": "core_extensions-sqlite", "content": "```\n\nThis error can be avoided by setting the `sqlite_all_varchar` option:\n\n```sql\nSET GLOBAL sqlite_all_varchar = true;\n```\n\nWhen set, this option overrides the type conversion rules described above, and instead always converts the SQLite columns into a `VARCHAR` column. Note that this setting must be set *before* `sqlite_attach` is called.", "position": 9, "token_count": 96, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-009", "document_id": "core_extensions-sqlite", "position": 9, "token_count": 96, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-010", "document_id": "core_extensions-sqlite", "content": "## Opening SQLite Databases Directly\n\nSQLite databases can also be opened directly and can be used transparently instead of a DuckDB database file. In any client, when connecting, a path to a SQLite database file can be provided and the SQLite database will be opened instead.\n\nFor example, with the shell, a SQLite database can be opened as follows:\n\n```batch\nduckdb sakila.db\n```\n\n```sql\nSELECT first_name\nFROM actor\nLIMIT 3;\n```\n\n| first_name |\n|------------|\n| PENELOPE |\n| NICK |\n| ED |", "position": 10, "token_count": 134, "has_code": true, "section_hierarchy": ["Opening SQLite Databases Directly"], "metadata": {"chunk_id": "core_extensions-sqlite-010", "document_id": "core_extensions-sqlite", "position": 10, "token_count": 134, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Opening SQLite Databases Directly"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#opening-sqlite-databases-directly"}}
{"chunk_id": "core_extensions-sqlite-011", "document_id": "core_extensions-sqlite", "content": "## Writing Data to SQLite\n\nIn addition to reading data from SQLite, the extension also allows you to create new SQLite database files, create tables, ingest data into SQLite and make other modifications to SQLite database files using standard SQL queries.\n\nThis allows you to use DuckDB to, for example, export data that is stored in a SQLite database to Parquet, or read data from a Parquet file into SQLite.\n\nBelow is a brief example of how to create a new SQLite database and load data into it.\n\n```sql\nATTACH 'new_sqlite_database.db' AS sqlite_db (TYPE sqlite);\nCREATE TABLE sqlite_db.tbl (id INTEGER, name VARCHAR);\nINSERT INTO sqlite_db.tbl VALUES (42, 'DuckDB');\n```\n\nThe resulting SQLite database can then be read into from SQLite.\n\n```batch\nsqlite3 new_sqlite_database.db\n```\n\n```sql\nSQLite version 3.39.5 2022-10-14 20:58:05\nsqlite> SELECT * FROM tbl;", "position": 11, "token_count": 244, "has_code": true, "section_hierarchy": ["Writing Data to SQLite"], "metadata": {"chunk_id": "core_extensions-sqlite-011", "document_id": "core_extensions-sqlite", "position": 11, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Writing Data to SQLite"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#writing-data-to-sqlite"}}
{"chunk_id": "core_extensions-sqlite-012", "document_id": "core_extensions-sqlite", "content": "```\n\n```sql\nSQLite version 3.39.5 2022-10-14 20:58:05\nsqlite> SELECT * FROM tbl;\n```\n\n```text\nid name\n-- ------\n42 DuckDB\n```\n\nMany operations on SQLite tables are supported. All these operations directly modify the SQLite database, and the result of subsequent operations can then be read using SQLite.", "position": 12, "token_count": 93, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "core_extensions-sqlite-012", "document_id": "core_extensions-sqlite", "position": 12, "token_count": 93, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite"}}
{"chunk_id": "core_extensions-sqlite-013", "document_id": "core_extensions-sqlite", "content": "## Concurrency\n\nDuckDB can read or modify a SQLite database while DuckDB or SQLite reads or modifies the same database from a different thread or a separate process. More than one thread or process can read the SQLite database at the same time, but only a single thread or process can write to the database at one time. Database locking is handled by the SQLite library, not DuckDB. Within the same process, SQLite uses mutexes. When accessed from different processes, SQLite uses file system locks. The locking mechanisms also depend on SQLite configuration, like WAL mode. Refer to the [SQLite documentation on locking](https://www.sqlite.org/lockingv3.html) for more information.\n\n> Warning Linking multiple copies of the SQLite library into the same application can lead to application errors. See [sqlite_scanner Issue #82](https://github.com/duckdb/sqlite_scanner/issues/82) for more information.", "position": 13, "token_count": 211, "has_code": false, "section_hierarchy": ["Concurrency"], "metadata": {"chunk_id": "core_extensions-sqlite-013", "document_id": "core_extensions-sqlite", "position": 13, "token_count": 211, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Concurrency"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#concurrency"}}
{"chunk_id": "core_extensions-sqlite-014", "document_id": "core_extensions-sqlite", "content": "## Settings\n\nThe extension exposes the following configuration parameters.\n\n| Name | Description | Default |\n| --------------------------------- | ---------------------------------------------------------------------------- | ------- |\n| `sqlite_debug_show_queries` | DEBUG SETTING: print all queries sent to SQLite to stdout | `false` |", "position": 14, "token_count": 178, "has_code": false, "section_hierarchy": ["Settings"], "metadata": {"chunk_id": "core_extensions-sqlite-014", "document_id": "core_extensions-sqlite", "position": 14, "token_count": 178, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Settings"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#settings"}}
{"chunk_id": "core_extensions-sqlite-015", "document_id": "core_extensions-sqlite", "content": "## Supported Operations\n\nBelow is a list of supported operations.\n\n### `CREATE TABLE`\n\n```sql\nCREATE TABLE sqlite_db.tbl (id INTEGER, name VARCHAR);\n```\n\n### `INSERT INTO`\n\n```sql\nINSERT INTO sqlite_db.tbl VALUES (42, 'DuckDB');\n```\n\n### `SELECT`\n\n```sql\nSELECT * FROM sqlite_db.tbl;\n```\n\n| id | name |\n|---:|--------|\n| 42 | DuckDB |\n\n### `COPY`\n\n```sql\nCOPY sqlite_db.tbl TO 'data.parquet';\nCOPY sqlite_db.tbl FROM 'data.parquet';\n```\n\n### `UPDATE`\n\n```sql\nUPDATE sqlite_db.tbl SET name = 'Woohoo' WHERE id = 42;\n```", "position": 15, "token_count": 209, "has_code": true, "section_hierarchy": ["`UPDATE`"], "metadata": {"chunk_id": "core_extensions-sqlite-015", "document_id": "core_extensions-sqlite", "position": 15, "token_count": 209, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`UPDATE`"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#update"}}
{"chunk_id": "core_extensions-sqlite-016", "document_id": "core_extensions-sqlite", "content": "### `UPDATE`\n\n```sql\nUPDATE sqlite_db.tbl SET name = 'Woohoo' WHERE id = 42;\n```\n\n### `DELETE`\n\n```sql\nDELETE FROM sqlite_db.tbl WHERE id = 42;\n```\n\n### `ALTER TABLE`\n\n```sql\nALTER TABLE sqlite_db.tbl ADD COLUMN k INTEGER;\n```\n\n### `DROP TABLE`\n\n```sql\nDROP TABLE sqlite_db.tbl;\n```\n\n### `CREATE VIEW`\n\n```sql\nCREATE VIEW sqlite_db.v1 AS SELECT 42;\n```", "position": 16, "token_count": 144, "has_code": true, "section_hierarchy": ["`CREATE VIEW`"], "metadata": {"chunk_id": "core_extensions-sqlite-016", "document_id": "core_extensions-sqlite", "position": 16, "token_count": 144, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`CREATE VIEW`"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#create-view"}}
{"chunk_id": "core_extensions-sqlite-017", "document_id": "core_extensions-sqlite", "content": "### `CREATE VIEW`\n\n```sql\nCREATE VIEW sqlite_db.v1 AS SELECT 42;\n```\n\n### Transactions\n\n```sql\nCREATE TABLE sqlite_db.tmp (i INTEGER);\n```\n\n```sql\nBEGIN;\nINSERT INTO sqlite_db.tmp VALUES (42);\nSELECT * FROM sqlite_db.tmp;\n```\n\n| i |\n|---:|\n| 42 |\n\n```sql\nROLLBACK;\nSELECT * FROM sqlite_db.tmp;\n```\n\n| i |\n|--:|\n| |\n\n> Deprecated The old `sqlite_attach` function is deprecated. It is recommended to switch over to the new [`ATTACH` syntax]({% link docs/stable/sql/statements/attach.md %}).", "position": 17, "token_count": 184, "has_code": true, "section_hierarchy": ["Transactions"], "metadata": {"chunk_id": "core_extensions-sqlite-017", "document_id": "core_extensions-sqlite", "position": 17, "token_count": 184, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Transactions"], "file_path": "core_extensions/sqlite.md", "url": "/core_extensions/sqlite", "title": "SQLite Extension", "category": null, "tags": [], "section_url": "/core_extensions/sqlite#transactions"}}

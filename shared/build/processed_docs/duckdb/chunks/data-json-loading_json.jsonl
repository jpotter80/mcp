{"chunk_id": "data-json-loading_json-000", "document_id": "data-json-loading_json", "content": "The DuckDB JSON reader can automatically infer which configuration flags to use by analyzing the JSON file. This will work correctly in most situations, and should be the first option attempted. In rare situations where the JSON reader cannot figure out the correct configuration, it is possible to manually configure the JSON reader to correctly parse the JSON file.", "position": 0, "token_count": 77, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-000", "document_id": "data-json-loading_json", "position": 0, "token_count": 77, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-001", "document_id": "data-json-loading_json", "content": "## The `read_json` Function\n\nThe `read_json` is the simplest method of loading JSON files: it automatically attempts to figure out the correct configuration of the JSON reader. It also automatically deduces types of columns.\nIn the following example, we use the [`todos.json`]({% link data/json/todos.json %}) file,\n\n```sql\nSELECT *\nFROM read_json('todos.json')\nLIMIT 5;", "position": 1, "token_count": 113, "has_code": true, "section_hierarchy": ["The `read_json` Function"], "metadata": {"chunk_id": "data-json-loading_json-001", "document_id": "data-json-loading_json", "position": 1, "token_count": 113, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["The `read_json` Function"], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json#the-readjson-function"}}
{"chunk_id": "data-json-loading_json-002", "document_id": "data-json-loading_json", "content": "```\n\n| userId | id | title | completed |\n|-------:|---:|-----------------------------------------------------------------|-----------|\n| 1 | 1 | delectus aut autem | false |\n| 1 | 2 | quis ut nam facilis et officia qui | false |\n| 1 | 3 | fugiat veniam minus | false |\n| 1 | 4 | et porro tempora | true |\n| 1 | 5 | laboriosam mollitia et enim quasi adipisci quia provident illum | false |\n\nWe can use `read_json` to create a persistent table as well:\n\n```sql\nCREATE TABLE todos AS\n SELECT *\n FROM read_json('todos.json');\nDESCRIBE todos;", "position": 2, "token_count": 244, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-002", "document_id": "data-json-loading_json", "position": 2, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-003", "document_id": "data-json-loading_json", "content": "```\n\n| column_name | column_type | null | key | default | extra |\n|-------------|-------------|------|------|---------|-------|\n| userId | UBIGINT | YES | NULL | NULL | NULL |\n| id | UBIGINT | YES | NULL | NULL | NULL |\n| title | VARCHAR | YES | NULL | NULL | NULL |\n| completed | BOOLEAN | YES | NULL | NULL | NULL |\n\nIf we specify types for subset of columns, `read_json` excludes columns that we don't specify:\n\n```sql\nSELECT *\nFROM read_json(\n 'todos.json',\n columns = {userId: 'UBIGINT', completed: 'BOOLEAN'}\n )\nLIMIT 5;", "position": 3, "token_count": 214, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-003", "document_id": "data-json-loading_json", "position": 3, "token_count": 214, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-004", "document_id": "data-json-loading_json", "content": "```\n\nNote that only the `userId` and `completed` columns are shown:\n\n| userId | completed |\n|-------:|----------:|\n| 1 | false |\n| 1 | false |\n| 1 | false |\n| 1 | true |\n| 1 | false |\n\nMultiple files can be read at once by providing a glob or a list of files. Refer to the [multiple files section]({% link docs/stable/data/multiple_files/overview.md %}) for more information.", "position": 4, "token_count": 126, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-004", "document_id": "data-json-loading_json", "position": 4, "token_count": 126, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-005", "document_id": "data-json-loading_json", "content": "## Functions for Reading JSON Objects\n\nThe following table functions are used to read JSON:\n\n| Function | Description |\n|:---|:---|\n| `read_json_objects(filename)` | Read a JSON object from `filename`, where `filename` can also be a list of files or a glob pattern. |\n| `read_ndjson_objects(filename)` | Alias for `read_json_objects` with the parameter `format` set to `newline_delimited`. |\n| `read_json_objects_auto(filename)` | Alias for `read_json_objects` with the parameter `format` set to `auto` . |", "position": 5, "token_count": 165, "has_code": false, "section_hierarchy": ["Functions for Reading JSON Objects"], "metadata": {"chunk_id": "data-json-loading_json-005", "document_id": "data-json-loading_json", "position": 5, "token_count": 165, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Functions for Reading JSON Objects"], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json#functions-for-reading-json-objects"}}
{"chunk_id": "data-json-loading_json-006", "document_id": "data-json-loading_json", "content": "### Parameters\n\nThese functions have the following parameters:", "position": 6, "token_count": 13, "has_code": false, "section_hierarchy": ["Parameters"], "metadata": {"chunk_id": "data-json-loading_json-006", "document_id": "data-json-loading_json", "position": 6, "token_count": 13, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Parameters"], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json#parameters"}}
{"chunk_id": "data-json-loading_json-007", "document_id": "data-json-loading_json", "content": "| Name | Description | Type | Default |\n|:--|:-----|:-|:-|\n| `compression` | The compression type for the file. By default this will be detected automatically from the file extension (e.g., `t.json.gz` will use gzip, `t.json` will use none). Options are `none`, `gzip`, `zstd` and `auto_detect`. | `VARCHAR` | `auto_detect` |\n| `filename` | Whether or not an extra `filename` column should be included in the result. Since DuckDB v1.3.0, the `filename` column is added automatically as a virtual column and this option is only kept for compatibility reasons. | `BOOL` | `false` |\n| `format` | Can be one of `auto`, `unstructured`, `newline_delimited` and `array`. | `VARCHAR` | `array` |", "position": 7, "token_count": 230, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-007", "document_id": "data-json-loading_json", "position": 7, "token_count": 230, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-008", "document_id": "data-json-loading_json", "content": "| `format` | Can be one of `auto`, `unstructured`, `newline_delimited` and `array`. | `VARCHAR` | `array` |\n| `hive_partitioning` | Whether or not to interpret the path as a [Hive partitioned path]({% link docs/stable/data/partitioning/hive_partitioning.md %}). | `BOOL` | (auto-detected) |\n| `ignore_errors` | Whether to ignore parse errors (only possible when `format` is `newline_delimited`). | `BOOL` | `false` |\n| `maximum_sample_files` | The maximum number of JSON files sampled for auto-detection. | `BIGINT` | `32` |\n| `maximum_object_size` | The maximum size of a JSON object (in bytes). | `UINTEGER` | `16777216` |", "position": 8, "token_count": 214, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-008", "document_id": "data-json-loading_json", "position": 8, "token_count": 214, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-009", "document_id": "data-json-loading_json", "content": "The `format` parameter specifies how to read the JSON from a file.\nWith `unstructured`, the top-level JSON is read, e.g., for `birds.json`:\n\n```json\n{\n \"duck\": 42\n}\n{\n \"goose\": [1, 2, 3]\n}", "position": 9, "token_count": 72, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-009", "document_id": "data-json-loading_json", "position": 9, "token_count": 72, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-010", "document_id": "data-json-loading_json", "content": "```\n\n```sql\nFROM read_json_objects('birds.json', format = 'unstructured');\n```\n\nwill result in two objects being read:\n\n```text\n┌──────────────────────────────┐\n│ json │\n│ json │\n├──────────────────────────────┤\n│ {\\n \"duck\": 42\\n} │\n│ {\\n \"goose\": [1, 2, 3]\\n} │\n└──────────────────────────────┘\n```\n\nWith `newline_delimited`, [NDJSON](https://github.com/ndjson/ndjson-spec) is read, where each JSON is separated by a newline (`\\n`), e.g., for `birds-nd.json`:\n\n```json\n{\"duck\": 42}\n{\"goose\": [1, 2, 3]}\n```\n\n```sql\nFROM read_json_objects('birds-nd.json', format = 'newline_delimited');", "position": 10, "token_count": 231, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-010", "document_id": "data-json-loading_json", "position": 10, "token_count": 231, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-011", "document_id": "data-json-loading_json", "content": "```\n\n```sql\nFROM read_json_objects('birds-nd.json', format = 'newline_delimited');\n```\n\nwill also result in two objects being read:\n\n```text\n┌──────────────────────┐\n│ json │\n│ json │\n├──────────────────────┤\n│ {\"duck\": 42} │\n│ {\"goose\": [1, 2, 3]} │\n└──────────────────────┘\n```\n\nWith `array`, each array element is read, e.g., for `birds-array.json`:\n\n```json\n[\n {\n \"duck\": 42\n },\n {\n \"goose\": [1, 2, 3]\n }\n]\n```\n\n```sql\nFROM read_json_objects('birds-array.json', format = 'array');\n```\n\nwill again result in two objects being read:\n\n```text\n┌──────────────────────────────────────┐\n│ json │\n│ json │\n├──────────────────────────────────────┤\n│ {\\n \"duck\": 42\\n } │\n│ {\\n \"goose\": [1, 2, 3]\\n } │\n└──────────────────────────────────────┘", "position": 11, "token_count": 237, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-011", "document_id": "data-json-loading_json", "position": 11, "token_count": 237, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-012", "document_id": "data-json-loading_json", "content": "```", "position": 12, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-012", "document_id": "data-json-loading_json", "position": 12, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-013", "document_id": "data-json-loading_json", "content": "## Functions for Reading JSON as a Table\n\nDuckDB also supports reading JSON as a table, using the following functions:\n\n| Function | Description |\n|:---------|:----------------|\n| `read_json(filename)` | Read JSON from `filename`, where `filename` can also be a list of files, or a glob pattern. |\n| `read_json_auto(filename)` | Alias for `read_json`. |\n| `read_ndjson(filename)` | Alias for `read_json` with parameter `format` set to `newline_delimited`. |\n| `read_ndjson_auto(filename)` | Alias for `read_json` with parameter `format` set to `newline_delimited`. |", "position": 13, "token_count": 209, "has_code": false, "section_hierarchy": ["Functions for Reading JSON as a Table"], "metadata": {"chunk_id": "data-json-loading_json-013", "document_id": "data-json-loading_json", "position": 13, "token_count": 209, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Functions for Reading JSON as a Table"], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json#functions-for-reading-json-as-a-table"}}
{"chunk_id": "data-json-loading_json-014", "document_id": "data-json-loading_json", "content": "### Parameters\n\nBesides the `maximum_object_size`, `format`, `ignore_errors` and `compression`, these functions have additional parameters:", "position": 14, "token_count": 36, "has_code": false, "section_hierarchy": ["Parameters"], "metadata": {"chunk_id": "data-json-loading_json-014", "document_id": "data-json-loading_json", "position": 14, "token_count": 36, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Parameters"], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json#parameters"}}
{"chunk_id": "data-json-loading_json-015", "document_id": "data-json-loading_json", "content": "| Name | Description | Type | Default |\n|:--|:------|:-|:-|\n| `auto_detect` | Whether to auto-detect the names of the keys and data types of the values automatically | `BOOL` | `true` |\n| `columns` | A struct that specifies the key names and value types contained within the JSON file (e.g., `{key1: 'INTEGER', key2: 'VARCHAR'}`). If `auto_detect` is enabled these will be inferred | `STRUCT` | `(empty)` |\n| `dateformat` | Specifies the date format to use when parsing dates. See [Date Format]({% link docs/stable/sql/functions/dateformat.md %}) | `VARCHAR` | `iso` |", "position": 15, "token_count": 196, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-015", "document_id": "data-json-loading_json", "position": 15, "token_count": 196, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-016", "document_id": "data-json-loading_json", "content": "| `maximum_depth` | Maximum nesting depth to which the automatic schema detection detects types. Set to -1 to fully detect nested JSON types | `BIGINT` | `-1` |\n| `records` | Can be one of `auto`, `true`, `false` | `VARCHAR` | `auto` |\n| `sample_size` | Option to define number of sample objects for automatic JSON type detection. Set to -1 to scan the entire input file | `UBIGINT` | `20480` |\n| `timestampformat` | Specifies the date format to use when parsing timestamps. See [Date Format]({% link docs/stable/sql/functions/dateformat.md %}) | `VARCHAR` | `iso`|\n| `union_by_name` | Whether the schema's of multiple JSON files should be [unified]({% link docs/stable/data/multiple_files/combining_schemas.md %}) | `BOOL` | `false` |", "position": 16, "token_count": 240, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-016", "document_id": "data-json-loading_json", "position": 16, "token_count": 240, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-017", "document_id": "data-json-loading_json", "content": "| `map_inference_threshold` | Controls the threshold for number of columns whose schema will be auto-detected; if JSON schema auto-detection would infer a `STRUCT` type for a field that has _more_ than this threshold number of subfields, it infers a `MAP` type instead. Set to `-1` to disable `MAP` inference. | `BIGINT` | `200` |\n| `field_appearance_threshold` | The JSON reader divides the number of appearances of each JSON field by the auto-detection sample size. If the average over the fields of an object is less than this threshold, it will default to using a `MAP` type with value type of merged field types. | `DOUBLE` | `0.1` |", "position": 17, "token_count": 170, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-017", "document_id": "data-json-loading_json", "position": 17, "token_count": 170, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-018", "document_id": "data-json-loading_json", "content": "Note that DuckDB can convert JSON arrays directly to its internal `LIST` type, and missing keys become `NULL`:\n\n```sql\nSELECT *\nFROM read_json(\n ['birds1.json', 'birds2.json'],\n columns = {duck: 'INTEGER', goose: 'INTEGER[]', swan: 'DOUBLE'}\n);", "position": 18, "token_count": 83, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-018", "document_id": "data-json-loading_json", "position": 18, "token_count": 83, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-019", "document_id": "data-json-loading_json", "content": "```\n\n| duck | goose | swan |\n|-----:|-----------|-----:|\n| 42 | [1, 2, 3] | NULL |\n| 43 | [4, 5, 6] | 3.3 |\n\nDuckDB can automatically detect the types like so:\n\n```sql\nSELECT goose, duck FROM read_json('*.json.gz');\nSELECT goose, duck FROM '*.json.gz'; -- equivalent\n```\n\nDuckDB can read (and auto-detect) a variety of formats, specified with the `format` parameter.\nQuerying a JSON file that contains an `array`, e.g.:\n\n```json\n[\n {\n \"duck\": 42,\n \"goose\": 4.2\n },\n {\n \"duck\": 43,\n \"goose\": 4.3\n }\n]", "position": 19, "token_count": 202, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-019", "document_id": "data-json-loading_json", "position": 19, "token_count": 202, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-020", "document_id": "data-json-loading_json", "content": "```\n\nCan be queried exactly the same as a JSON file that contains `unstructured` JSON, e.g.:\n\n```json\n{\n \"duck\": 42,\n \"goose\": 4.2\n}\n{\n \"duck\": 43,\n \"goose\": 4.3\n}\n```\n\nBoth can be read as the table:\n\n```sql\nSELECT\nFROM read_json('birds.json');", "position": 20, "token_count": 97, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-020", "document_id": "data-json-loading_json", "position": 20, "token_count": 97, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-021", "document_id": "data-json-loading_json", "content": "```\n\nBoth can be read as the table:\n\n```sql\nSELECT\nFROM read_json('birds.json');\n```\n\n| duck | goose |\n|-----:|------:|\n| 42 | 4.2 |\n| 43 | 4.3 |\n\nIf your JSON file does not contain “records”, i.e., any other type of JSON than objects, DuckDB can still read it.\nThis is specified with the `records` parameter.\nThe `records` parameter specifies whether the JSON contains records that should be unpacked into individual columns.\nDuckDB also attempts to auto-detect this.\nFor example, take the following file, `birds-records.json`:\n\n```json\n{\"duck\": 42, \"goose\": [1, 2, 3]}\n{\"duck\": 43, \"goose\": [4, 5, 6]}\n```\n\n```sql\nSELECT *\nFROM read_json('birds-records.json');", "position": 21, "token_count": 230, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-021", "document_id": "data-json-loading_json", "position": 21, "token_count": 230, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-022", "document_id": "data-json-loading_json", "content": "```\n\n```sql\nSELECT *\nFROM read_json('birds-records.json');\n```\n\nThe query results in two columns:\n\n| duck | goose |\n|-----:|:--------|\n| 42 | [1,2,3] |\n| 43 | [4,5,6] |\n\nYou can read the same file with `records` set to `false`, to get a single column, which is a `STRUCT` containing the data:\n\n| json |\n|:-----|\n| {'duck': 42, 'goose': [1,2,3]} |\n| {'duck': 43, 'goose': [4,5,6]} |\n\nFor additional examples reading more complex data, please see the [“Shredding Deeply Nested JSON, One Vector at a Time” blog post]({% post_url 2023-03-03-json %}).", "position": 22, "token_count": 221, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-022", "document_id": "data-json-loading_json", "position": 22, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-023", "document_id": "data-json-loading_json", "content": "## Loading with the `COPY` Statement Using `FORMAT json`\n\nWhen the `json` extension is installed, `FORMAT json` is supported for `COPY FROM`, `IMPORT DATABASE`, as well as `COPY TO` and `EXPORT DATABASE`. See the [`COPY` statement]({% link docs/stable/sql/statements/copy.md %}) and the [`IMPORT` / `EXPORT` clauses]({% link docs/stable/sql/statements/export.md %}).\n\nBy default, `COPY` expects newline-delimited JSON. If you prefer copying data to/from a JSON array, you can specify `ARRAY true`, e.g.,\n\n```sql\nCOPY (SELECT * FROM range(5) r(i))\nTO 'numbers.json' (ARRAY true);\n```\n\nwill create the following file:\n\n```json\n[\n\t{\"i\":0},\n\t{\"i\":1},\n\t{\"i\":2},\n\t{\"i\":3},\n\t{\"i\":4}\n]", "position": 23, "token_count": 244, "has_code": true, "section_hierarchy": ["Loading with the `COPY` Statement Using `FORMAT json`"], "metadata": {"chunk_id": "data-json-loading_json-023", "document_id": "data-json-loading_json", "position": 23, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Loading with the `COPY` Statement Using `FORMAT json`"], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json#loading-with-the-copy-statement-using-format-json"}}
{"chunk_id": "data-json-loading_json-024", "document_id": "data-json-loading_json", "content": "```\n\nThis can be read back to DuckDB as follows:\n\n```sql\nCREATE TABLE numbers (i BIGINT);\nCOPY numbers FROM 'numbers.json' (ARRAY true);\n```\n\nThe format can be detected automatically the format like so:\n\n```sql\nCREATE TABLE numbers (i BIGINT);\nCOPY numbers FROM 'numbers.json' (AUTO_DETECT true);\n```\n\nWe can also create a table from the auto-detected schema:\n\n```sql\nCREATE TABLE numbers AS\n FROM 'numbers.json';\n```", "position": 24, "token_count": 122, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-024", "document_id": "data-json-loading_json", "position": 24, "token_count": 122, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-025", "document_id": "data-json-loading_json", "content": "### Parameters", "position": 25, "token_count": 6, "has_code": false, "section_hierarchy": ["Parameters"], "metadata": {"chunk_id": "data-json-loading_json-025", "document_id": "data-json-loading_json", "position": 25, "token_count": 6, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Parameters"], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json#parameters"}}
{"chunk_id": "data-json-loading_json-026", "document_id": "data-json-loading_json", "content": "| Name | Description | Type | Default |\n|:--|:-----|:-|:-|\n| `auto_detect` | Whether to auto-detect the names of the keys and data types of the values automatically | `BOOL` | `false` |\n| `columns` | A struct that specifies the key names and value types contained within the JSON file (e.g., `{key1: 'INTEGER', key2: 'VARCHAR'}`). If `auto_detect` is enabled these will be inferred | `STRUCT` | `(empty)` |\n| `compression` | The compression type for the file. By default this will be detected automatically from the file extension (e.g., `t.json.gz` will use gzip, `t.json` will use none). Options are `uncompressed`, `gzip`, `zstd` and `auto_detect`. | `VARCHAR` | `auto_detect` |", "position": 26, "token_count": 234, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-026", "document_id": "data-json-loading_json", "position": 26, "token_count": 234, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-027", "document_id": "data-json-loading_json", "content": "| `convert_strings_to_integers` | Whether strings representing integer values should be converted to a numerical type. | `BOOL` | `false` |\n| `dateformat` | Specifies the date format to use when parsing dates. See [Date Format]({% link docs/stable/sql/functions/dateformat.md %}) | `VARCHAR` | `iso` |\n| `filename` | Whether or not an extra `filename` column should be included in the result. | `BOOL` | `false` |\n| `format` | Can be one of `auto, unstructured, newline_delimited, array` | `VARCHAR` | `array` |\n| `hive_partitioning` | Whether or not to interpret the path as a [Hive partitioned path]({% link docs/stable/data/partitioning/hive_partitioning.md %}). | `BOOL` | `false` |", "position": 27, "token_count": 217, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-027", "document_id": "data-json-loading_json", "position": 27, "token_count": 217, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-028", "document_id": "data-json-loading_json", "content": "| `ignore_errors` | Whether to ignore parse errors (only possible when `format` is `newline_delimited`) | `BOOL` | `false` |\n| `maximum_depth` | Maximum nesting depth to which the automatic schema detection detects types. Set to -1 to fully detect nested JSON types | `BIGINT` | `-1` |\n| `maximum_object_size` | The maximum size of a JSON object (in bytes) | `UINTEGER` | `16777216` |\n| `records` | Can be one of `auto`, `true`, `false` | `VARCHAR` | `records` |\n| `sample_size` | Option to define number of sample objects for automatic JSON type detection. Set to -1 to scan the entire input file | `UBIGINT` | `20480` |", "position": 28, "token_count": 197, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-028", "document_id": "data-json-loading_json", "position": 28, "token_count": 197, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}
{"chunk_id": "data-json-loading_json-029", "document_id": "data-json-loading_json", "content": "| `sample_size` | Option to define number of sample objects for automatic JSON type detection. Set to -1 to scan the entire input file | `UBIGINT` | `20480` |\n| `timestampformat` | Specifies the date format to use when parsing timestamps. See [Date Format]({% link docs/stable/sql/functions/dateformat.md %}) | `VARCHAR` | `iso`|\n| `union_by_name` | Whether the schema's of multiple JSON files should be [unified]({% link docs/stable/data/multiple_files/combining_schemas.md %}). | `BOOL` | `false` |", "position": 29, "token_count": 166, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-loading_json-029", "document_id": "data-json-loading_json", "position": 29, "token_count": 166, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/loading_json.md", "url": "/data/json/loading_json", "title": "Loading JSON", "category": null, "tags": [], "section_url": "/data/json/loading_json"}}

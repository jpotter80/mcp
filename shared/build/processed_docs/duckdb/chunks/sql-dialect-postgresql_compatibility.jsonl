{"chunk_id": "sql-dialect-postgresql_compatibility-000", "document_id": "sql-dialect-postgresql_compatibility", "content": "DuckDB's SQL dialect closely follows the conventions of the PostgreSQL dialect.\nThe few exceptions to this are listed on this page.", "position": 0, "token_count": 32, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-000", "document_id": "sql-dialect-postgresql_compatibility", "position": 0, "token_count": 32, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-001", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Floating-Point Arithmetic\n\nDuckDB and PostgreSQL handle floating-point arithmetic differently for division by zero. DuckDB conforms to the [IEEE Standard for Floating-Point Arithmetic (IEEE 754)](https://en.wikipedia.org/wiki/IEEE_754) for both division by zero and operations involving infinity values. PostgreSQL returns an error for division by zero but aligns with IEEE 754 for handling infinity values. To show the differences, run the following SQL queries:\n\n```sql\nSELECT 1.0 / 0.0 AS x;\nSELECT 0.0 / 0.0 AS x;\nSELECT -1.0 / 0.0 AS x;\nSELECT 'Infinity'::FLOAT / 'Infinity'::FLOAT AS x;\nSELECT 1.0 / 'Infinity'::FLOAT AS x;\nSELECT 'Infinity'::FLOAT - 'Infinity'::FLOAT AS x;\nSELECT 'Infinity'::FLOAT - 1.0 AS x;", "position": 1, "token_count": 213, "has_code": true, "section_hierarchy": ["Floating-Point Arithmetic"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-001", "document_id": "sql-dialect-postgresql_compatibility", "position": 1, "token_count": 213, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Floating-Point Arithmetic"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#floating-point-arithmetic"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-002", "document_id": "sql-dialect-postgresql_compatibility", "content": "```\n\n| Expression | PostgreSQL | DuckDB | IEEE 754 |\n| :---------------------- | ---------: | --------: | --------: |\n| 1.0 / 0.0 | error | Infinity | Infinity |\n| 0.0 / 0.0 | error | NaN | NaN |\n| -1.0 / 0.0 | error | -Infinity | -Infinity |\n| 'Infinity' / 'Infinity' | NaN | NaN | NaN |\n| 1.0 / 'Infinity' | 0.0 | 0.0 | 0.0 |\n| 'Infinity' - 'Infinity' | NaN | NaN | NaN |\n| 'Infinity' - 1.0 | Infinity | Infinity | Infinity |", "position": 2, "token_count": 191, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-002", "document_id": "sql-dialect-postgresql_compatibility", "position": 2, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-003", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Division on Integers\n\nWhen computing division on integers, PostgreSQL performs integer division, while DuckDB performs float division:\n\n```sql\nSELECT 1 / 2 AS x;\n```\n\nPostgreSQL returns `0`, while DuckDB returns `0.5`.\n\nTo perform integer division in DuckDB, use the `//` operator:\n\n```sql\nSELECT 1 // 2 AS x;\n```\n\nThis returns `0`.\n\n## `UNION` of Boolean and Integer Values\n\nThe following query fails in PostgreSQL but successfully completes in DuckDB:\n\n```sql\nSELECT true AS x\nUNION\nSELECT 2;\n```\n\nPostgreSQL returns an error:\n\n```console\nERROR: UNION types boolean and integer cannot be matched\n```\n\nDuckDB performs an enforced cast, therefore, it completes the query and returns the following:\n\n| x |\n| ---: |\n| 1 |\n| 2 |", "position": 3, "token_count": 203, "has_code": true, "section_hierarchy": ["`UNION` of Boolean and Integer Values"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-003", "document_id": "sql-dialect-postgresql_compatibility", "position": 3, "token_count": 203, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`UNION` of Boolean and Integer Values"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#union-of-boolean-and-integer-values"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-004", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Implicit Casting on Equality Checks\n\nDuckDB performs implicit casting on equality checks, e.g., converting strings to numeric and boolean values.\nTherefore, there are several instances, where PostgreSQL throws an error while DuckDB successfully computes the result:\n\n| Expression | PostgreSQL | DuckDB |\n| :------------ | ---------- | ------ |\n| '1.1' = 1 | error | true |\n| '1.1' = 1.1 | true | true |\n| 1 = 1.1 | false | false |\n| true = 'true' | true | true |\n| true = 1 | error | true |\n| 'true' = 1 | error | error |", "position": 4, "token_count": 173, "has_code": false, "section_hierarchy": ["Implicit Casting on Equality Checks"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-004", "document_id": "sql-dialect-postgresql_compatibility", "position": 4, "token_count": 173, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Implicit Casting on Equality Checks"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#implicit-casting-on-equality-checks"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-005", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Case Sensitivity for Quoted Identifiers\n\nPostgreSQL is case-insensitive. The way PostgreSQL achieves case insensitivity is by lowercasing unquoted identifiers within SQL, whereas quoting preserves case, e.g., the following command creates a table named `mytable` but tries to query for `MyTaBLe` because quotes preserve the case.\n\n```sql\nCREATE TABLE MyTaBLe (x INTEGER);\nSELECT * FROM \"MyTaBLe\";\n```\n\n```console\nERROR: relation \"MyTaBLe\" does not exist\n```\n\nPostgreSQL does not only treat quoted identifiers as case-sensitive, PostgreSQL treats all identifiers as case-sensitive, e.g., this also does not work:\n\n```sql\nCREATE TABLE \"PreservedCase\" (x INTEGER);\nSELECT * FROM PreservedCase;\n```\n\n```console\nERROR: relation \"preservedcase\" does not exist", "position": 5, "token_count": 210, "has_code": true, "section_hierarchy": ["Case Sensitivity for Quoted Identifiers"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-005", "document_id": "sql-dialect-postgresql_compatibility", "position": 5, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Case Sensitivity for Quoted Identifiers"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#case-sensitivity-for-quoted-identifiers"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-006", "document_id": "sql-dialect-postgresql_compatibility", "content": "```\n\n```console\nERROR: relation \"preservedcase\" does not exist\n```\n\nTherefore, case-insensitivity in PostgreSQL only works if you never use quoted identifiers with different cases.\n\nFor DuckDB, this behavior was problematic when interfacing with other tools (e.g., Parquet, Pandas) that are case-sensitive by default – since all identifiers would be lowercased all the time.\nTherefore, DuckDB achieves case insensitivity by making identifiers fully case insensitive throughout the system but [_preserving their case_]({% link docs/stable/sql/dialect/keywords_and_identifiers.md %}#rules-for-case-sensitivity).\n\nIn DuckDB, the scripts above complete successfully:\n\n```sql\nCREATE TABLE MyTaBLe (x INTEGER);\nSELECT * FROM \"MyTaBLe\";\nCREATE TABLE \"PreservedCase\" (x INTEGER);\nSELECT * FROM PreservedCase;\nSELECT tbl FROM duckdb_tables();", "position": 6, "token_count": 224, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-006", "document_id": "sql-dialect-postgresql_compatibility", "position": 6, "token_count": 224, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-007", "document_id": "sql-dialect-postgresql_compatibility", "content": "```\n\n| tbl |\n| ------------- |\n| MyTaBLe |\n| PreservedCase |\n\nPostgreSQL's behavior of lowercasing identifiers is accessible using the [`preserve_identifier_case` option]({% link docs/stable/configuration/overview.md %}#local-configuration-options):\n\n```sql\nSET preserve_identifier_case = false;\nCREATE TABLE MyTaBLe (x INTEGER);\nSELECT tbl FROM duckdb_tables();\n```\n\n| tbl |\n| ---------- |\n| mytable |\n\nHowever, the case insensitive matching in the system for identifiers cannot be turned off.", "position": 7, "token_count": 165, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-007", "document_id": "sql-dialect-postgresql_compatibility", "position": 7, "token_count": 165, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-008", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Using Double Equality Sign for Comparison\n\nDuckDB supports both `=` and `==` for quality comparison, while PostgreSQL only supports `=`.\n\n```sql\nSELECT 1 == 1 AS t;\n```\n\nDuckDB returns `true`, while PostgreSQL returns:\n\n```console\npostgres=# SELECT 1 == 1 AS t;\nERROR: operator does not exist: integer == integer\nLINE 1: SELECT 1 == 1 AS t;\n```\n\nNote that the use of `==` is not encouraged due to its limited portability.\n\n## Vacuuming Tables\n\nIn PostgreSQL, the `VACUUM` statement garbage collects tables and analyzes tables.\nIn DuckDB, the [`VACUUM` statement]({% link docs/stable/sql/statements/vacuum.md %}) is only used to rebuild statistics.\nFor instruction on reclaiming space, refer to the [“Reclaiming space” page]({% link docs/stable/operations_manual/footprint_of_duckdb/reclaiming_space.md %}).", "position": 8, "token_count": 239, "has_code": true, "section_hierarchy": ["Vacuuming Tables"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-008", "document_id": "sql-dialect-postgresql_compatibility", "position": 8, "token_count": 239, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Vacuuming Tables"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#vacuuming-tables"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-009", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Strings\n\nSince version 1.3.0, DuckDB escapes characters such as `'` in strings serialized in nested data structures.\nPostgreSQL does not do this.\n\nFor an example, run:\n\n```sql\nSELECT ARRAY[''''];\n```\n\nPostgreSQL returns:\n\n```text\n{'}\n```\n\nDuckDB returns:\n\n```text\n['\\'']\n```", "position": 9, "token_count": 97, "has_code": true, "section_hierarchy": ["Strings"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-009", "document_id": "sql-dialect-postgresql_compatibility", "position": 9, "token_count": 97, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Strings"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#strings"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-010", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Functions\n\n### `regexp_extract` Function\n\nUnlike PostgreSQL's `regexp_substr` function, DuckDB's `regexp_extract` returns empty strings instead of `NULL`s when there is no match.\n\n### `to_date` Function\n\nDuckDB does not support the [`to_date` PostgreSQL date formatting function](https://www.postgresql.org/docs/17/functions-formatting.html).\nInstead, please use the [`strptime` function]({% link docs/stable/sql/functions/dateformat.md %}#strptime-examples).\n\n### `date_part` Function\n\nMost parts extracted by the [`date_part` function]({% link docs/stable/sql/functions/datepart.md %}) are returned as integers. Since there are no infinite integer values in DuckDB, `NULL`s are returned for infinite timestamps.", "position": 10, "token_count": 232, "has_code": false, "section_hierarchy": ["`date_part` Function"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-010", "document_id": "sql-dialect-postgresql_compatibility", "position": 10, "token_count": 232, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`date_part` Function"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#datepart-function"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-011", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Resolution of Type Names in the Schema\n\nFor [`CREATE TABLE` statements]({% link docs/stable/sql/statements/create_table.md %}), DuckDB attempts to resolve type names in the schema where a table is created. For example:\n\n```sql\nCREATE SCHEMA myschema;\nCREATE TYPE myschema.mytype AS ENUM ('as', 'df');\nCREATE TABLE myschema.mytable (v mytype);\n```\n\nPostgreSQL returns an error on the last statement:\n\n```console\nERROR: type \"mytype\" does not exist\nLINE 1: CREATE TABLE myschema.mytable (v mytype);\n```\n\nDuckDB runs the statement and creates the table successfully, confirmed by the following query:\n\n```sql\nDESCRIBE myschema.mytable;", "position": 11, "token_count": 188, "has_code": true, "section_hierarchy": ["Resolution of Type Names in the Schema"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-011", "document_id": "sql-dialect-postgresql_compatibility", "position": 11, "token_count": 188, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Resolution of Type Names in the Schema"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#resolution-of-type-names-in-the-schema"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-012", "document_id": "sql-dialect-postgresql_compatibility", "content": "```\n\nDuckDB runs the statement and creates the table successfully, confirmed by the following query:\n\n```sql\nDESCRIBE myschema.mytable;\n```\n\n| column_name | column_type | null | key | default | extra |\n| ----------- | ---------------- | ---- | ---- | ------- | ----- |\n| v | ENUM('as', 'df') | YES | NULL | NULL | NULL |", "position": 12, "token_count": 132, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-012", "document_id": "sql-dialect-postgresql_compatibility", "position": 12, "token_count": 132, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-013", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Exploiting Functional Dependencies for `GROUP BY`\n\nPostgreSQL can exploit functional dependencies, such as `i -> j` in the following query:\n\n```sql\nCREATE TABLE tbl (i INTEGER, j INTEGER, PRIMARY KEY (i));\nSELECT j\nFROM tbl\nGROUP BY i;\n```\n\nPostgreSQL runs the query.\n\nDuckDB fails:\n\n```console\nBinder Error:\ncolumn \"j\" must appear in the GROUP BY clause or must be part of an aggregate function.\nEither add it to the GROUP BY list, or use \"ANY_VALUE(j)\" if the exact value of \"j\" is not important.\n```\n\nTo work around this, add the other attributes or use the [`GROUP BY ALL` clause](https://duckdb.org/docs/sql/query_syntax/groupby#group-by-all).", "position": 13, "token_count": 196, "has_code": true, "section_hierarchy": ["Exploiting Functional Dependencies for `GROUP BY`"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-013", "document_id": "sql-dialect-postgresql_compatibility", "position": 13, "token_count": 196, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Exploiting Functional Dependencies for `GROUP BY`"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#exploiting-functional-dependencies-for-group-by"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-014", "document_id": "sql-dialect-postgresql_compatibility", "content": "## Behavior of Regular Expression Match Operators\n\nPostgreSQL supports the [POSIX regular expression matching operators]({% link docs/stable/sql/functions/pattern_matching.md %}) `~` (case-sensitive partial regex matching) and `~*` (case-insensitive partial regex matching) as well as their negated variants, `!~` and `!~*`, respectively.\n\nIn DuckDB, `~` is equivalent to [`regexp_full_match`]({% link docs/stable/sql/functions/text.md %}#regexp_full_matchstring-regex) and `!~` is equivalent to `NOT regexp_full_match`.\nThe operators `~*` and `!~*` are not supported.\n\nThe table below shows that the correspondence between these functions in PostgreSQL and DuckDB is almost non-existent.\nWe recommend avoiding the POSIX regular expression matching operators in DuckDB.", "position": 14, "token_count": 224, "has_code": false, "section_hierarchy": ["Behavior of Regular Expression Match Operators"], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-014", "document_id": "sql-dialect-postgresql_compatibility", "position": 14, "token_count": 224, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Behavior of Regular Expression Match Operators"], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility#behavior-of-regular-expression-match-operators"}}
{"chunk_id": "sql-dialect-postgresql_compatibility-015", "document_id": "sql-dialect-postgresql_compatibility", "content": "The table below shows that the correspondence between these functions in PostgreSQL and DuckDB is almost non-existent.\nWe recommend avoiding the POSIX regular expression matching operators in DuckDB.\n\n| Expression | PostgreSQL | DuckDB |\n| :------------------ | ---------- | ------ |\n| `'aaa' ~ '(a|b)'` | true | false |\n| `'AAA' ~* '(a|b)'` | true | error |\n| `'aaa' !~ '(a|b)'` | false | true |\n| `'AAA' !~* '(a|b)'` | false | error |", "position": 15, "token_count": 173, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-dialect-postgresql_compatibility-015", "document_id": "sql-dialect-postgresql_compatibility", "position": 15, "token_count": 173, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/dialect/postgresql_compatibility.md", "url": "/sql/dialect/postgresql_compatibility", "title": "PostgreSQL Compatibility", "category": null, "tags": [], "section_url": "/sql/dialect/postgresql_compatibility"}}

{"chunk_id": "data-appender-000", "document_id": "data-appender", "content": "The Appender can be used to load bulk data into a DuckDB database. It is currently available in the [C, C++, Go, Java, and Rust APIs](#appender-support-in-other-clients). The Appender is tied to a connection, and will use the transaction context of that connection when appending. An Appender always appends to a single table in the database file.\n\nIn the [C++ API]({% link docs/stable/clients/cpp.md %}), the Appender works as follows:\n\n```cpp\nDuckDB db;\nConnection con(db);\n// create the table\ncon.Query(\"CREATE TABLE people (id INTEGER, name VARCHAR)\");\n// initialize the appender\nAppender appender(con, \"people\");", "position": 0, "token_count": 193, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-appender-000", "document_id": "data-appender", "position": 0, "token_count": 193, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender"}}
{"chunk_id": "data-appender-001", "document_id": "data-appender", "content": "```\n\nThe `AppendRow` function is the easiest way of appending data. It uses recursive templates to allow you to put all the values of a single row within one function call, as follows:\n\n```cpp\nappender.AppendRow(1, \"Mark\");\n```\n\nRows can also be individually constructed using the `BeginRow`, `EndRow` and `Append` methods. This is done internally by `AppendRow`, and hence has the same performance characteristics.\n\n```cpp\nappender.BeginRow();\nappender.Append(2);\nappender.Append(\"Hannes\");\nappender.EndRow();", "position": 1, "token_count": 160, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-appender-001", "document_id": "data-appender", "position": 1, "token_count": 160, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender"}}
{"chunk_id": "data-appender-002", "document_id": "data-appender", "content": "```\n\nAny values added to the Appender are cached prior to being inserted into the database system\nfor performance reasons. That means that, while appending, the rows might not be immediately visible in the system. The cache is automatically flushed when the Appender goes out of scope or when `appender.Close()` is called. The cache can also be manually flushed using the `appender.Flush()` method. After either `Flush` or `Close` is called, all the data has been written to the database system.", "position": 2, "token_count": 118, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-appender-002", "document_id": "data-appender", "position": 2, "token_count": 118, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender"}}
{"chunk_id": "data-appender-003", "document_id": "data-appender", "content": "## Date, Time and Timestamps\n\nWhile numbers and strings are rather self-explanatory, dates, times and timestamps require some explanation. They can be directly appended using the methods provided by `duckdb::Date`, `duckdb::Time` or `duckdb::Timestamp`. They can also be appended using the internal `duckdb::Value` type, however, this adds some additional overheads and should be avoided if possible.\n\nBelow is a short example:\n\n```cpp\ncon.Query(\"CREATE TABLE dates (d DATE, t TIME, ts TIMESTAMP)\");\nAppender appender(con, \"dates\");", "position": 3, "token_count": 153, "has_code": true, "section_hierarchy": ["Date, Time and Timestamps"], "metadata": {"chunk_id": "data-appender-003", "document_id": "data-appender", "position": 3, "token_count": 153, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Date, Time and Timestamps"], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender#date-time-and-timestamps"}}
{"chunk_id": "data-appender-004", "document_id": "data-appender", "content": "```cpp\ncon.Query(\"CREATE TABLE dates (d DATE, t TIME, ts TIMESTAMP)\");\nAppender appender(con, \"dates\");\n\n// construct the values using the Date/Time/Timestamp types\n// (this is the most efficient approach)\nappender.AppendRow(\n Date::FromDate(1992, 1, 1),\n Time::FromTime(1, 1, 1, 0),\n Timestamp::FromDatetime(Date::FromDate(1992, 1, 1), Time::FromTime(1, 1, 1, 0))\n);\n// construct duckdb::Value objects\nappender.AppendRow(\n Value::DATE(1992, 1, 1),\n Value::TIME(1, 1, 1, 0),\n Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)\n);", "position": 4, "token_count": 210, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-appender-004", "document_id": "data-appender", "position": 4, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender"}}
{"chunk_id": "data-appender-005", "document_id": "data-appender", "content": "```", "position": 5, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-appender-005", "document_id": "data-appender", "position": 5, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender"}}
{"chunk_id": "data-appender-006", "document_id": "data-appender", "content": "## Commit Frequency\n\nBy default, the appender performs a commits every 204,800 rows.\nYou can change this by explicitly using [transactions]({% link docs/stable/sql/statements/transactions.md %}) and surrounding your batches of `AppendRow` calls by `BEGIN TRANSACTION` and `COMMIT` statements.\n\n## Handling Constraint Violations\n\nIf the Appender encounters a `PRIMARY KEY` conflict or a `UNIQUE` constraint violation, it fails and returns the following error:\n\n```console\nConstraint Error:\nPRIMARY KEY or UNIQUE constraint violated: duplicate key \"...\"\n```\n\nIn this case, the entire append operation fails and no rows are inserted.", "position": 6, "token_count": 147, "has_code": true, "section_hierarchy": ["Handling Constraint Violations"], "metadata": {"chunk_id": "data-appender-006", "document_id": "data-appender", "position": 6, "token_count": 147, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Handling Constraint Violations"], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender#handling-constraint-violations"}}
{"chunk_id": "data-appender-007", "document_id": "data-appender", "content": "## Appender Support in Other Clients\n\nThe Appender is also available in the following client APIs:\n\n* [C]({% link docs/stable/clients/c/appender.md %})\n* [Go]({% link docs/stable/clients/go.md %}#appender)\n* [Java (JDBC)]({% link docs/stable/clients/java.md %}#appender)\n* [Julia]({% link docs/stable/clients/julia.md %}#appender-api)\n* [Rust]({% link docs/stable/clients/rust.md %}#appender)", "position": 7, "token_count": 156, "has_code": false, "section_hierarchy": ["Appender Support in Other Clients"], "metadata": {"chunk_id": "data-appender-007", "document_id": "data-appender", "position": 7, "token_count": 156, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Appender Support in Other Clients"], "file_path": "data/appender.md", "url": "/data/appender", "title": "Appender", "category": null, "tags": [], "section_url": "/data/appender#appender-support-in-other-clients"}}

{"chunk_id": "clients-cpp-000", "document_id": "clients-cpp", "content": "> The latest stable version of the DuckDB C++ API is {{ site.current_duckdb_version }}.\n\n> Warning DuckDB's C++ API is internal.\n> It is not guaranteed to be stable and can change without notice.\n> If you would like to build an application on DuckDB, we recommend using the [C API]({% link docs/stable/clients/c/overview.md %}).\n\n## Installation\n\nThe DuckDB C++ API can be installed as part of the `libduckdb` packages. Please see the [installation page]({% link install/index.html %}?environment=cplusplus) for details.", "position": 0, "token_count": 152, "has_code": false, "section_hierarchy": ["Installation"], "metadata": {"chunk_id": "clients-cpp-000", "document_id": "clients-cpp", "position": 0, "token_count": 152, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Installation"], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp#installation"}}
{"chunk_id": "clients-cpp-001", "document_id": "clients-cpp", "content": "## Basic API Usage\n\nDuckDB implements a custom C++ API. This is built around the abstractions of a database instance (`DuckDB` class), multiple `Connection`s to the database instance and `QueryResult` instances as the result of queries. The header file for the C++ API is `duckdb.hpp`.", "position": 1, "token_count": 77, "has_code": false, "section_hierarchy": ["Basic API Usage"], "metadata": {"chunk_id": "clients-cpp-001", "document_id": "clients-cpp", "position": 1, "token_count": 77, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Basic API Usage"], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp#basic-api-usage"}}
{"chunk_id": "clients-cpp-002", "document_id": "clients-cpp", "content": "### Startup & Shutdown\n\nTo use DuckDB, you must first initialize a `DuckDB` instance using its constructor. `DuckDB()` takes as parameter the database file to read and write from. The special value `nullptr` can be used to create an **in-memory database**. Note that for an in-memory database no data is persisted to disk (i.e., all data is lost when you exit the process). The second parameter to the `DuckDB` constructor is an optional `DBConfig` object. In `DBConfig`, you can set various database parameters, for example the read/write mode or memory limits. The `DuckDB` constructor may throw exceptions, for example if the database file is not usable.\n\nWith the `DuckDB` instance, you can create one or many `Connection` instances using the `Connection()` constructor. While connections should be thread-safe, they will be locked during querying. It is therefore recommended that each thread uses its own connection if you are in a multithreaded environment.", "position": 2, "token_count": 237, "has_code": false, "section_hierarchy": ["Startup & Shutdown"], "metadata": {"chunk_id": "clients-cpp-002", "document_id": "clients-cpp", "position": 2, "token_count": 237, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Startup & Shutdown"], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp#startup--shutdown"}}
{"chunk_id": "clients-cpp-003", "document_id": "clients-cpp", "content": "```cpp\nDuckDB db(nullptr);\nConnection con(db);", "position": 3, "token_count": 22, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-003", "document_id": "clients-cpp", "position": 3, "token_count": 22, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-004", "document_id": "clients-cpp", "content": "```", "position": 4, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-004", "document_id": "clients-cpp", "position": 4, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-005", "document_id": "clients-cpp", "content": "### Querying\n\nConnections expose the `Query()` method to send a SQL query string to DuckDB from C++. `Query()` fully materializes the query result as a `MaterializedQueryResult` in memory before returning at which point the query result can be consumed. There is also a streaming API for queries, see further below.\n\n```cpp\n// create a table\ncon.Query(\"CREATE TABLE integers (i INTEGER, j INTEGER)\");\n\n// insert three rows into the table\ncon.Query(\"INSERT INTO integers VALUES (3, 4), (5, 6), (7, NULL)\");", "position": 5, "token_count": 143, "has_code": true, "section_hierarchy": ["Querying"], "metadata": {"chunk_id": "clients-cpp-005", "document_id": "clients-cpp", "position": 5, "token_count": 143, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Querying"], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp#querying"}}
{"chunk_id": "clients-cpp-006", "document_id": "clients-cpp", "content": "// insert three rows into the table\ncon.Query(\"INSERT INTO integers VALUES (3, 4), (5, 6), (7, NULL)\");\n\nauto result = con.Query(\"SELECT * FROM integers\");\nif (result->HasError()) {\n cerr GetError() ToString() HasError()) {\n auto errorType = result->GetErrorType();\n switch (errorType) {\n case duckdb::ExceptionType::CONSTRAINT: {\n // Example handling\n auto errorObject = result->GetErrorObject();\n errorObject.ConvertErrorToJSON();\n std::cout prepare = con.Prepare(\"SELECT count(*) FROM a WHERE i = $1\");\nstd::unique_ptr result = prepare->Execute(12);", "position": 6, "token_count": 196, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-006", "document_id": "clients-cpp", "position": 6, "token_count": 196, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-007", "document_id": "clients-cpp", "content": "```\n\n> Warning Do **not** use prepared statements to insert large amounts of data into DuckDB. See the [data import documentation]({% link docs/stable/data/overview.md %}) for better options.", "position": 7, "token_count": 54, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-007", "document_id": "clients-cpp", "position": 7, "token_count": 54, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-008", "document_id": "clients-cpp", "content": "### UDF API\n\nThe UDF API allows the definition of user-defined functions. It is exposed in `duckdb:Connection` through the methods: `CreateScalarFunction()`, `CreateVectorizedFunction()`, and variants.\nThese methods created UDFs into the temporary schema (`TEMP_SCHEMA`) of the owner connection that is the only one allowed to use and change them.", "position": 8, "token_count": 94, "has_code": false, "section_hierarchy": ["UDF API"], "metadata": {"chunk_id": "clients-cpp-008", "document_id": "clients-cpp", "position": 8, "token_count": 94, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["UDF API"], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp#udf-api"}}
{"chunk_id": "clients-cpp-009", "document_id": "clients-cpp", "content": "#### CreateScalarFunction\n\nThe user can code an ordinary scalar function and invoke the `CreateScalarFunction()` to register and afterward use the UDF in a `SELECT` statement, for instance:\n\n```cpp\nbool bigger_than_four(int value) {\n return value > 4;\n}\n\nconnection.CreateScalarFunction(\"bigger_than_four\", &bigger_than_four);\n\nconnection.Query(\"SELECT bigger_than_four(i) FROM (VALUES(3), (5)) tbl(i)\")->Print();\n```\n\nThe `CreateScalarFunction()` methods automatically creates vectorized scalar UDFs so they are as efficient as built-in functions, we have two variants of this method interface as follows:\n\n**1.**\n\n```cpp\ntemplate\nvoid CreateScalarFunction(string name, TR (*udf_func)(Args…))", "position": 9, "token_count": 218, "has_code": true, "section_hierarchy": ["CreateScalarFunction"], "metadata": {"chunk_id": "clients-cpp-009", "document_id": "clients-cpp", "position": 9, "token_count": 218, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["CreateScalarFunction"], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp#createscalarfunction"}}
{"chunk_id": "clients-cpp-010", "document_id": "clients-cpp", "content": "```\n\n- template parameters:\n - **TR** is the return type of the UDF function;\n - **Args** are the arguments up to 3 for the UDF function (this method only supports until ternary functions);\n- **name**: is the name to register the UDF function;\n- **udf_func**: is a pointer to the UDF function.\n\nThis method automatically discovers from the template typenames the corresponding LogicalTypes:\n\n- `bool` → `LogicalType::BOOLEAN`\n- `int8_t` → `LogicalType::TINYINT`\n- `int16_t` → `LogicalType::SMALLINT`\n- `int32_t` → `LogicalType::INTEGER`\n- `int64_t` →` LogicalType::BIGINT`\n- `float` → `LogicalType::FLOAT`\n- `double` → `LogicalType::DOUBLE`\n- `string_t` → `LogicalType::VARCHAR`", "position": 10, "token_count": 224, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-010", "document_id": "clients-cpp", "position": 10, "token_count": 224, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-011", "document_id": "clients-cpp", "content": "In DuckDB some primitive types, e.g., `int32_t`, are mapped to the same `LogicalType`: `INTEGER`, `TIME` and `DATE`, then for disambiguation the users can use the following overloaded method.\n\n**2.**\n\n```cpp\ntemplate\nvoid CreateScalarFunction(string name, vector args, LogicalType ret_type, TR (*udf_func)(Args…))", "position": 11, "token_count": 108, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-011", "document_id": "clients-cpp", "position": 11, "token_count": 108, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-012", "document_id": "clients-cpp", "content": "```\n\nAn example of use would be:\n\n```cpp\nint32_t udf_date(int32_t a) {\n return a;\n}\n\ncon.Query(\"CREATE TABLE dates (d DATE)\");\ncon.Query(\"INSERT INTO dates VALUES ('1992-01-01')\");\n\ncon.CreateScalarFunction(\"udf_date\", {LogicalType::DATE}, LogicalType::DATE, &udf_date);\n\ncon.Query(\"SELECT udf_date(d) FROM dates\")->Print();", "position": 12, "token_count": 132, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-012", "document_id": "clients-cpp", "position": 12, "token_count": 132, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-013", "document_id": "clients-cpp", "content": "```\n\n- template parameters:\n - **TR** is the return type of the UDF function;\n - **Args** are the arguments up to 3 for the UDF function (this method only supports until ternary functions);\n- **name**: is the name to register the UDF function;\n- **args**: are the LogicalType arguments that the function uses, which should match with the template Args types;\n- **ret_type**: is the LogicalType of return of the function, which should match with the template TR type;\n- **udf_func**: is a pointer to the UDF function.\n\nThis function checks the template types against the LogicalTypes passed as arguments and they must match as follow:", "position": 13, "token_count": 169, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-013", "document_id": "clients-cpp", "position": 13, "token_count": 169, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-014", "document_id": "clients-cpp", "content": "This function checks the template types against the LogicalTypes passed as arguments and they must match as follow:\n\n- LogicalTypeId::BOOLEAN → bool\n- LogicalTypeId::TINYINT → int8_t\n- LogicalTypeId::SMALLINT → int16_t\n- LogicalTypeId::DATE, LogicalTypeId::TIME, LogicalTypeId::INTEGER → int32_t\n- LogicalTypeId::BIGINT, LogicalTypeId::TIMESTAMP → int64_t\n- LogicalTypeId::FLOAT, LogicalTypeId::DOUBLE, LogicalTypeId::DECIMAL → double\n- LogicalTypeId::VARCHAR, LogicalTypeId::CHAR, LogicalTypeId::BLOB → string_t\n- LogicalTypeId::VARBINARY → blob_t", "position": 14, "token_count": 175, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-014", "document_id": "clients-cpp", "position": 14, "token_count": 175, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-015", "document_id": "clients-cpp", "content": "#### CreateVectorizedFunction\n\nThe `CreateVectorizedFunction()` methods register a vectorized UDF such as:\n\n```cpp\n/*\n* This vectorized function copies the input values to the result vector\n*/\ntemplate\nstatic void udf_vectorized(DataChunk &args, ExpressionState &state, Vector &result) {\n // set the result vector type\n result.vector_type = VectorType::FLAT_VECTOR;\n // get a raw array from the result\n auto result_data = FlatVector::GetData(result);\n\n // get the solely input vector\n auto &input = args.data[0];\n // now get an orrified vector\n VectorData vdata;\n input.Orrify(args.size(), vdata);\n\n // get a raw array from the orrified input\n auto input_data = (TYPE *)vdata.data;", "position": 15, "token_count": 205, "has_code": true, "section_hierarchy": ["CreateVectorizedFunction"], "metadata": {"chunk_id": "clients-cpp-015", "document_id": "clients-cpp", "position": 15, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["CreateVectorizedFunction"], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp#createvectorizedfunction"}}
{"chunk_id": "clients-cpp-016", "document_id": "clients-cpp", "content": "// get a raw array from the orrified input\n auto input_data = (TYPE *)vdata.data;\n\n // handling the data\n for (idx_t i = 0; i get_index(i);\n if ((*vdata.nullmask)[idx]) {\n continue;\n }\n result_data[i] = input_data[idx];\n }\n}\n\ncon.Query(\"CREATE TABLE integers (i INTEGER)\");\ncon.Query(\"INSERT INTO integers VALUES (1), (2), (3), (999)\");\n\ncon.CreateVectorizedFunction(\"udf_vectorized_int\", &&udf_vectorized);\n\ncon.Query(\"SELECT udf_vectorized_int(i) FROM integers\")->Print();", "position": 16, "token_count": 185, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-016", "document_id": "clients-cpp", "position": 16, "token_count": 185, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-017", "document_id": "clients-cpp", "content": "```\n\nThe Vectorized UDF is a pointer of the type _scalar_function_t_:\n\n```cpp\ntypedef std::function scalar_function_t;", "position": 17, "token_count": 44, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-017", "document_id": "clients-cpp", "position": 17, "token_count": 44, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-018", "document_id": "clients-cpp", "content": "```\n\n- **args** is a [DataChunk](https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/common/types/data_chunk.hpp) that holds a set of input vectors for the UDF that all have the same length;\n- **expr** is an [ExpressionState](https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/execution/expression_executor_state.hpp) that provides information to the query's expression state;\n- **result**: is a [Vector](https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/common/types/vector.hpp) to store the result values.", "position": 18, "token_count": 206, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-018", "document_id": "clients-cpp", "position": 18, "token_count": 206, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-019", "document_id": "clients-cpp", "content": "There are different vector types to handle in a Vectorized UDF:\n- ConstantVector;\n- DictionaryVector;\n- FlatVector;\n- ListVector;\n- StringVector;\n- StructVector;\n- SequenceVector.\n\nThe general API of the `CreateVectorizedFunction()` method is as follows:\n\n**1.**\n\n```cpp\ntemplate\nvoid CreateVectorizedFunction(string name, scalar_function_t udf_func, LogicalType varargs = LogicalType::INVALID)", "position": 19, "token_count": 120, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-019", "document_id": "clients-cpp", "position": 19, "token_count": 120, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-020", "document_id": "clients-cpp", "content": "```\n\n- template parameters:\n - **TR** is the return type of the UDF function;\n - **Args** are the arguments up to 3 for the UDF function.\n- **name** is the name to register the UDF function;\n- **udf_func** is a _vectorized_ UDF function;\n- **varargs** The type of varargs to support, or LogicalTypeId::INVALID (default value) if the function does not accept variable length arguments.\n\nThis method automatically discovers from the template typenames the corresponding LogicalTypes:\n\n- bool → LogicalType::BOOLEAN;\n- int8_t → LogicalType::TINYINT;\n- int16_t → LogicalType::SMALLINT\n- int32_t → LogicalType::INTEGER\n- int64_t → LogicalType::BIGINT\n- float → LogicalType::FLOAT\n- double → LogicalType::DOUBLE\n- string_t → LogicalType::VARCHAR\n\n**2.**", "position": 20, "token_count": 227, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-020", "document_id": "clients-cpp", "position": 20, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}
{"chunk_id": "clients-cpp-021", "document_id": "clients-cpp", "content": "**2.**\n\n```cpp\ntemplate\nvoid CreateVectorizedFunction(string name, vector args, LogicalType ret_type, scalar_function_t udf_func, LogicalType varargs = LogicalType::INVALID)\n```", "position": 21, "token_count": 63, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-cpp-021", "document_id": "clients-cpp", "position": 21, "token_count": 63, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/cpp.md", "url": "/clients/cpp", "title": "C++ API", "category": null, "tags": [], "section_url": "/clients/cpp"}}

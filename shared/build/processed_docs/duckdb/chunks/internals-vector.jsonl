{"chunk_id": "internals-vector-000", "document_id": "internals-vector", "content": "`Vector` is the container format used to store in-memory data during execution.\n`DataChunk` is a collection of Vectors, used for instance to represent a column list in a `PhysicalProjection` operator.\n\n## Data Flow\n\nDuckDB uses a vectorized query execution model.\nAll operators in DuckDB are optimized to work on Vectors of a fixed size.\n\nThis fixed size is commonly referred to in the code as `STANDARD_VECTOR_SIZE`.\nThe default `STANDARD_VECTOR_SIZE` is 2048 tuples.", "position": 0, "token_count": 114, "has_code": false, "section_hierarchy": ["Data Flow"], "metadata": {"chunk_id": "internals-vector-000", "document_id": "internals-vector", "position": 0, "token_count": 114, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Data Flow"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#data-flow"}}
{"chunk_id": "internals-vector-001", "document_id": "internals-vector", "content": "## Vector Format\n\nVectors logically represent arrays that contain data of a single type. DuckDB supports different *vector formats*, which allow the system to store the same logical data with a different *physical representation*. This allows for a more compressed representation, and potentially allows for compressed execution throughout the system. Below the list of supported vector formats is shown.\n\n### Flat Vectors\n\nFlat vectors are physically stored as a contiguous array, this is the standard uncompressed vector format.\nFor flat vectors the logical and physical representations are identical.", "position": 1, "token_count": 110, "has_code": false, "section_hierarchy": ["Flat Vectors"], "metadata": {"chunk_id": "internals-vector-001", "document_id": "internals-vector", "position": 1, "token_count": 110, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Flat Vectors"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#flat-vectors"}}
{"chunk_id": "internals-vector-002", "document_id": "internals-vector", "content": "### Flat Vectors\n\nFlat vectors are physically stored as a contiguous array, this is the standard uncompressed vector format.\nFor flat vectors the logical and physical representations are identical.\n\n### Constant Vectors\n\nConstant vectors are physically stored as a single constant value.\n\nConstant vectors are useful when data elements are repeated – for example, when representing the result of a constant expression in a function call, the constant vector allows us to only store the value once.\n\n```sql\nSELECT lst || 'duckdb'\nFROM range(1000) tbl(lst);\n```\n\nSince `duckdb` is a string literal, the value of the literal is the same for every row. In a flat vector, we would have to duplicate the literal 'duckdb' once for every row. The constant vector allows us to only store the literal once.\n\nConstant vectors are also emitted by the storage when decompressing from constant compression.", "position": 2, "token_count": 192, "has_code": true, "section_hierarchy": ["Constant Vectors"], "metadata": {"chunk_id": "internals-vector-002", "document_id": "internals-vector", "position": 2, "token_count": 192, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Constant Vectors"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#constant-vectors"}}
{"chunk_id": "internals-vector-003", "document_id": "internals-vector", "content": "### Dictionary Vectors\n\nDictionary vectors are physically stored as a child vector, and a selection vector that contains indexes into the child vector.\n\nDictionary vectors are emitted by the storage when decompressing from dictionary\n\nJust like constant vectors, dictionary vectors are also emitted by the storage.\nWhen deserializing a dictionary compressed column segment, we store this in a dictionary vector so we can keep the data compressed during query execution.\n\n### Sequence Vectors\n\nSequence vectors are physically stored as an offset and an increment value.\n\nSequence vectors are useful for efficiently storing incremental sequences. They are generally emitted for row identifiers.", "position": 3, "token_count": 129, "has_code": false, "section_hierarchy": ["Sequence Vectors"], "metadata": {"chunk_id": "internals-vector-003", "document_id": "internals-vector", "position": 3, "token_count": 129, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Sequence Vectors"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#sequence-vectors"}}
{"chunk_id": "internals-vector-004", "document_id": "internals-vector", "content": "### Sequence Vectors\n\nSequence vectors are physically stored as an offset and an increment value.\n\nSequence vectors are useful for efficiently storing incremental sequences. They are generally emitted for row identifiers.\n\n### Unified Vector Format\n\nThese properties of the different vector formats are great for optimization purposes, for example you can imagine the scenario where all the parameters to a function are constant, we can just compute the result once and emit a constant vector.\nBut writing specialized code for every combination of vector types for every function is unfeasible due to the combinatorial explosion of possibilities.\n\nInstead of doing this, whenever you want to generically use a vector regardless of the type, the UnifiedVectorFormat can be used.\nThis format essentially acts as a generic view over the contents of the Vector. Every type of Vector can convert to this format.", "position": 4, "token_count": 176, "has_code": false, "section_hierarchy": ["Unified Vector Format"], "metadata": {"chunk_id": "internals-vector-004", "document_id": "internals-vector", "position": 4, "token_count": 176, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Unified Vector Format"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#unified-vector-format"}}
{"chunk_id": "internals-vector-005", "document_id": "internals-vector", "content": "## Complex Types\n\n### String Vectors\n\nTo efficiently store strings, we make use of our `string_t` class.\n\n```cpp\nstruct string_t {\n union {\n struct {\n uint32_t length;\n char prefix[4];\n char *ptr;\n } pointer;\n struct {\n uint32_t length;\n char inlined[12];\n } inlined;\n } value;\n};\n```\n\nShort strings (`<= 12 bytes`) are inlined into the structure, while larger strings are stored with a pointer to the data in the auxiliary string buffer. The length is used throughout the functions to avoid having to call `strlen` and having to continuously check for null-pointers. The prefix is used for comparisons as an early out (when the prefix does not match, we know the strings are not equal and don't need to chase any pointers).", "position": 5, "token_count": 196, "has_code": true, "section_hierarchy": ["String Vectors"], "metadata": {"chunk_id": "internals-vector-005", "document_id": "internals-vector", "position": 5, "token_count": 196, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["String Vectors"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#string-vectors"}}
{"chunk_id": "internals-vector-006", "document_id": "internals-vector", "content": "### List Vectors\n\nList vectors are stored as a series of *list entries* together with a child Vector. The child vector contains the *values* that are present in the list, and the list entries specify how each individual list is constructed.\n\n```cpp\nstruct list_entry_t {\n idx_t offset;\n idx_t length;\n};\n```\n\nThe offset refers to the start row in the child Vector, the length keeps track of the size of the list of this row.\n\nList vectors can be stored recursively. For nested list vectors, the child of a list vector is again a list vector.\n\nFor example, consider this mock representation of a Vector of type `BIGINT[][]`:\n\n```json\n{\n \"type\": \"list\",\n \"data\": \"list_entry_t\",\n \"child\": {\n \"type\": \"list\",\n \"data\": \"list_entry_t\",\n \"child\": {\n \"type\": \"bigint\",\n \"data\": \"int64_t\"\n }\n }\n}\n```", "position": 6, "token_count": 238, "has_code": true, "section_hierarchy": ["List Vectors"], "metadata": {"chunk_id": "internals-vector-006", "document_id": "internals-vector", "position": 6, "token_count": 238, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["List Vectors"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#list-vectors"}}
{"chunk_id": "internals-vector-007", "document_id": "internals-vector", "content": "### Struct Vectors\n\nStruct vectors store a list of child vectors. The number and types of the child vectors is defined by the schema of the struct.\n\n### Map Vectors\n\nInternally map vectors are stored as a `LIST[STRUCT(key KEY_TYPE, value VALUE_TYPE)]`.\n\n### Union Vectors\n\nInternally `UNION` utilizes the same structure as a `STRUCT`.\nThe first “child” is always occupied by the Tag Vector of the `UNION`, which records for each row which of the `UNION`'s types apply to that row.", "position": 7, "token_count": 130, "has_code": false, "section_hierarchy": ["Union Vectors"], "metadata": {"chunk_id": "internals-vector-007", "document_id": "internals-vector", "position": 7, "token_count": 130, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Union Vectors"], "file_path": "internals/vector.md", "url": "/internals/vector", "title": "Execution Format", "category": null, "tags": [], "section_url": "/internals/vector#union-vectors"}}

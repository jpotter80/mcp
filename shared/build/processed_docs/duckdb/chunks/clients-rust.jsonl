{"chunk_id": "clients-rust-000", "document_id": "clients-rust", "content": "> The latest stable version of the DuckDB Rust client is {{ site.current_duckdb_rust_version }}.\n\n## Installation\n\nThe DuckDB Rust client can be installed from [crates.io](https://crates.io/crates/duckdb). Please see the [docs.rs](http://docs.rs/duckdb) for details.", "position": 0, "token_count": 86, "has_code": false, "section_hierarchy": ["Installation"], "metadata": {"chunk_id": "clients-rust-000", "document_id": "clients-rust", "position": 0, "token_count": 86, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Installation"], "file_path": "clients/rust.md", "url": "/clients/rust", "title": "Rust Client", "category": null, "tags": [], "section_url": "/clients/rust#installation"}}
{"chunk_id": "clients-rust-001", "document_id": "clients-rust", "content": "## Basic API Usage\n\nduckdb-rs is an ergonomic wrapper based on the [DuckDB C API](https://github.com/duckdb/duckdb/blob/main/src/include/duckdb.h), please refer to the [README](https://github.com/duckdb/duckdb-rs) for details.", "position": 1, "token_count": 91, "has_code": false, "section_hierarchy": ["Basic API Usage"], "metadata": {"chunk_id": "clients-rust-001", "document_id": "clients-rust", "position": 1, "token_count": 91, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Basic API Usage"], "file_path": "clients/rust.md", "url": "/clients/rust", "title": "Rust Client", "category": null, "tags": [], "section_url": "/clients/rust#basic-api-usage"}}
{"chunk_id": "clients-rust-002", "document_id": "clients-rust", "content": "### Startup & Shutdown\n\nTo use duckdb, you must first initialize a `Connection` handle using `Connection::open()`. `Connection::open()` takes as parameter the database file to read and write from. If the database file does not exist, it will be created (the file extension may be `.db`, `.duckdb`, or anything else). You can also use `Connection::open_in_memory()` to create an **in-memory database**. Note that for an in-memory database no data is persisted to disk (i.e., all data is lost when you exit the process).\n\n```rust\nuse duckdb::{params, Connection, Result};\nlet conn = Connection::open_in_memory()?;", "position": 2, "token_count": 181, "has_code": true, "section_hierarchy": ["Startup & Shutdown"], "metadata": {"chunk_id": "clients-rust-002", "document_id": "clients-rust", "position": 2, "token_count": 181, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Startup & Shutdown"], "file_path": "clients/rust.md", "url": "/clients/rust", "title": "Rust Client", "category": null, "tags": [], "section_url": "/clients/rust#startup--shutdown"}}
{"chunk_id": "clients-rust-003", "document_id": "clients-rust", "content": "```\n\nThe `Connection` will automatically close the underlying db connection for you when it goes out of scope (via `Drop`). You can also explicitly close the `Connection` with `conn.close()`. This is not much difference between these in the typical case, but in case there is an error, you'll have the chance to handle it with the explicit close.", "position": 3, "token_count": 84, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-rust-003", "document_id": "clients-rust", "position": 3, "token_count": 84, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/rust.md", "url": "/clients/rust", "title": "Rust Client", "category": null, "tags": [], "section_url": "/clients/rust"}}
{"chunk_id": "clients-rust-004", "document_id": "clients-rust", "content": "### Querying\n\nSQL queries can be sent to DuckDB using the `execute()` method of connections, or we can also prepare the statement and then query on that.\n\n```rust\n#[derive(Debug)]\nstruct Person {\n id: i32,\n name: String,\n data: Option>,\n}\n\nconn.execute(\n \"INSERT INTO person (name, data) VALUES (?, ?)\",\n params![me.name, me.data],\n)?;\n\nlet mut stmt = conn.prepare(\"SELECT id, name, data FROM person\")?;\nlet person_iter = stmt.query_map([], |row| {\n Ok(Person {\n id: row.get(0)?,\n name: row.get(1)?,\n data: row.get(2)?,\n })\n})?;\n\nfor person in person_iter {\n println!(\"Found person {:?}\", person.unwrap());\n}\n```", "position": 4, "token_count": 229, "has_code": true, "section_hierarchy": ["Querying"], "metadata": {"chunk_id": "clients-rust-004", "document_id": "clients-rust", "position": 4, "token_count": 229, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Querying"], "file_path": "clients/rust.md", "url": "/clients/rust", "title": "Rust Client", "category": null, "tags": [], "section_url": "/clients/rust#querying"}}
{"chunk_id": "clients-rust-005", "document_id": "clients-rust", "content": "## Appender\n\nThe Rust client supports the [DuckDB Appender API]({% link docs/stable/data/appender.md %}) for bulk inserts. For example:\n\n```rust\nfn insert_rows(conn: &Connection) -> Result {\n let mut app = conn.appender(\"foo\")?;\n app.append_rows([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])?;\n Ok(())\n}\n```", "position": 5, "token_count": 135, "has_code": true, "section_hierarchy": ["Appender"], "metadata": {"chunk_id": "clients-rust-005", "document_id": "clients-rust", "position": 5, "token_count": 135, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Appender"], "file_path": "clients/rust.md", "url": "/clients/rust", "title": "Rust Client", "category": null, "tags": [], "section_url": "/clients/rust#appender"}}

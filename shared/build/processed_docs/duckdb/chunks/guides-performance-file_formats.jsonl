{"chunk_id": "guides-performance-file_formats-000", "document_id": "guides-performance-file_formats", "content": "## Handling Parquet Files\n\nDuckDB has advanced support for Parquet files, which includes [directly querying Parquet files]({% post_url 2021-06-25-querying-parquet %}).\nWhen deciding on whether to query these files directly or to first load them to the database, you need to consider several factors.\n\n### Reasons for Querying Parquet Files\n\n**Availability of basic statistics:** Parquet files use a columnar storage format and contain basic statistics such as [zonemaps]({% link docs/stable/guides/performance/indexing.md %}#zonemaps). Thanks to these features, DuckDB can leverage optimizations such as projection and filter pushdown on Parquet files. Therefore, workloads that combine projection, filtering, and aggregation tend to perform quite well when run on Parquet files.\n\n**Storage considerations:** Loading the data from Parquet files will require approximately the same amount of space for the DuckDB database file. Therefore, if the available disk space is constrained, it is worth running the queries directly on Parquet files.", "position": 0, "token_count": 239, "has_code": false, "section_hierarchy": ["Reasons for Querying Parquet Files"], "metadata": {"chunk_id": "guides-performance-file_formats-000", "document_id": "guides-performance-file_formats", "position": 0, "token_count": 239, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Reasons for Querying Parquet Files"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#reasons-for-querying-parquet-files"}}
{"chunk_id": "guides-performance-file_formats-001", "document_id": "guides-performance-file_formats", "content": "### Reasons against Querying Parquet Files\n\n**Lack of advanced statistics:** The DuckDB database format has the [hyperloglog statistics](https://en.wikipedia.org/wiki/HyperLogLog) that Parquet files do not have. These improve the accuracy of cardinality estimates, and are especially important if the queries contain a large number of join operators.\n\n**Tip.** If you find that DuckDB produces a suboptimal join order on Parquet files, try loading the Parquet files to DuckDB tables. The improved statistics likely help obtain a better join order.\n\n**Repeated queries:** If you plan to run multiple queries on the same dataset, it is worth loading the data into DuckDB. The queries will always be somewhat faster, which over time amortizes the initial load time.", "position": 1, "token_count": 184, "has_code": false, "section_hierarchy": ["Reasons against Querying Parquet Files"], "metadata": {"chunk_id": "guides-performance-file_formats-001", "document_id": "guides-performance-file_formats", "position": 1, "token_count": 184, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Reasons against Querying Parquet Files"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#reasons-against-querying-parquet-files"}}
{"chunk_id": "guides-performance-file_formats-002", "document_id": "guides-performance-file_formats", "content": "**High decompression times:** Some Parquet files are compressed using heavyweight compression algorithms such as gzip. In these cases, querying the Parquet files will necessitate an expensive decompression time every time the file is accessed. Meanwhile, lightweight compression methods like Snappy, LZ4, and zstd, are faster to decompress. You may use the [`parquet_metadata` function]({% link docs/stable/data/parquet/metadata.md %}#parquet-metadata) to find out the compression algorithm used.", "position": 2, "token_count": 128, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "guides-performance-file_formats-002", "document_id": "guides-performance-file_formats", "position": 2, "token_count": 128, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats"}}
{"chunk_id": "guides-performance-file_formats-003", "document_id": "guides-performance-file_formats", "content": "#### Microbenchmark: Running TPC-H on a DuckDB Database vs. Parquet\n\nThe queries on the [TPC-H benchmark]({% link docs/stable/core_extensions/tpch.md %}) run approximately 1.1-5.0× slower on Parquet files than on a DuckDB database.\n\n> Bestpractice If you have the storage space available, and have a join-heavy workload and/or plan to run many queries on the same dataset, load the Parquet files into the database first. The compression algorithm and the row group sizes in the Parquet files have a large effect on performance: study these using the [`parquet_metadata` function]({% link docs/stable/data/parquet/metadata.md %}#parquet-metadata).", "position": 3, "token_count": 186, "has_code": false, "section_hierarchy": ["Microbenchmark: Running TPC-H on a DuckDB Database vs. Parquet"], "metadata": {"chunk_id": "guides-performance-file_formats-003", "document_id": "guides-performance-file_formats", "position": 3, "token_count": 186, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Microbenchmark: Running TPC-H on a DuckDB Database vs. Parquet"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#microbenchmark-running-tpc-h-on-a-duckdb-database-vs-parquet"}}
{"chunk_id": "guides-performance-file_formats-004", "document_id": "guides-performance-file_formats", "content": "### The Effect of Row Group Sizes\n\nDuckDB works best on Parquet files with row groups of 100K-1M rows each. The reason for this is that DuckDB can only [parallelize over row groups]({% link docs/stable/guides/performance/how_to_tune_workloads.md %}#parallelism-multi-core-processing) – so if a Parquet file has a single giant row group it can only be processed by a single thread. You can use the [`parquet_metadata` function]({% link docs/stable/data/parquet/metadata.md %}#parquet-metadata) to figure out how many row groups a Parquet file has. When writing Parquet files, use the [`row_group_size`]({% link docs/stable/sql/statements/copy.md %}#parquet-options) option.", "position": 4, "token_count": 201, "has_code": false, "section_hierarchy": ["The Effect of Row Group Sizes"], "metadata": {"chunk_id": "guides-performance-file_formats-004", "document_id": "guides-performance-file_formats", "position": 4, "token_count": 201, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["The Effect of Row Group Sizes"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#the-effect-of-row-group-sizes"}}
{"chunk_id": "guides-performance-file_formats-005", "document_id": "guides-performance-file_formats", "content": "#### Microbenchmark: Running Aggregation Query at Different Row Group Sizes\n\nWe run a simple aggregation query over Parquet files using different row group sizes, selected between 960 and 1,966,080. The results are as follows.\n\n| Row group size | Execution time |\n|---------------:|---------------:|\n| 960 | 8.77 s |\n| 1920 | 8.95 s |\n| 3840 | 4.33 s |\n| 7680 | 2.35 s |\n| 15360 | 1.58 s |\n| 30720 | 1.17 s |\n| 61440 | 0.94 s |\n| 122880 | 0.87 s |\n| 245760 | 0.93 s |\n| 491520 | 0.95 s |\n| 983040 | 0.97 s |\n| 1966080 | 0.88 s |\n\nThe results show that row group sizes Bestpractice The ideal range is between 100 MB and 10 GB per individual Parquet file.", "position": 5, "token_count": 235, "has_code": false, "section_hierarchy": ["Microbenchmark: Running Aggregation Query at Different Row Group Sizes"], "metadata": {"chunk_id": "guides-performance-file_formats-005", "document_id": "guides-performance-file_formats", "position": 5, "token_count": 235, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Microbenchmark: Running Aggregation Query at Different Row Group Sizes"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#microbenchmark-running-aggregation-query-at-different-row-group-sizes"}}
{"chunk_id": "guides-performance-file_formats-006", "document_id": "guides-performance-file_formats", "content": "### Hive Partitioning for Filter Pushdown\n\nWhen querying many files with filter conditions, performance can be improved by using a [Hive-format folder structure]({% link docs/stable/data/partitioning/hive_partitioning.md %}) to partition the data along the columns used in the filter condition. DuckDB will only need to read the folders and files that meet the filter criteria. This can be especially helpful when querying remote files.\n\n### More Tips on Reading and Writing Parquet Files\n\nFor tips on reading and writing Parquet files, see the [Parquet Tips page]({% link docs/stable/data/parquet/tips.md %}).", "position": 6, "token_count": 151, "has_code": false, "section_hierarchy": ["More Tips on Reading and Writing Parquet Files"], "metadata": {"chunk_id": "guides-performance-file_formats-006", "document_id": "guides-performance-file_formats", "position": 6, "token_count": 151, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["More Tips on Reading and Writing Parquet Files"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#more-tips-on-reading-and-writing-parquet-files"}}
{"chunk_id": "guides-performance-file_formats-007", "document_id": "guides-performance-file_formats", "content": "## Loading CSV Files\n\nCSV files are often distributed in compressed format such as GZIP archives (`.csv.gz`). DuckDB can decompress these files on the fly. In fact, this is typically faster than decompressing the files first and loading them due to reduced IO.\n\n| Schema | Load time |\n|---|--:|\n| Load from GZIP-compressed CSV files (`.csv.gz`) | 107.1 s |\n| Decompressing (using parallel `gunzip`) and loading from decompressed CSV files | 121.3 s |", "position": 7, "token_count": 141, "has_code": false, "section_hierarchy": ["Loading CSV Files"], "metadata": {"chunk_id": "guides-performance-file_formats-007", "document_id": "guides-performance-file_formats", "position": 7, "token_count": 141, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Loading CSV Files"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#loading-csv-files"}}
{"chunk_id": "guides-performance-file_formats-008", "document_id": "guides-performance-file_formats", "content": "### Loading Many Small CSV Files\n\nThe [CSV reader]({% link docs/stable/data/csv/overview.md %}) runs the [CSV sniffer]({% post_url 2023-10-27-csv-sniffer %}) on all files. For many small files, this may cause an unnecessarily high overhead.\nA potential optimization to speed this up is to turn the sniffer off. Assuming that all files have the same CSV dialect and column names/types, get the sniffer options as follows:\n\n```sql\n.mode line\nSELECT Prompt FROM sniff_csv('part-0001.csv');\n```\n\n```text\nPrompt = FROM read_csv('file_path.csv', auto_detect=false, delim=',', quote='\"', escape='\"', new_line='\\n', skip=0, header=true, columns={'hello': 'BIGINT', 'world': 'VARCHAR'});", "position": 8, "token_count": 243, "has_code": true, "section_hierarchy": ["Loading Many Small CSV Files"], "metadata": {"chunk_id": "guides-performance-file_formats-008", "document_id": "guides-performance-file_formats", "position": 8, "token_count": 243, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Loading Many Small CSV Files"], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats#loading-many-small-csv-files"}}
{"chunk_id": "guides-performance-file_formats-009", "document_id": "guides-performance-file_formats", "content": "```\n\nThen, you can adjust `read_csv` command, by e.g., applying [filename expansion (globbing)]({% link docs/stable/sql/functions/pattern_matching.md %}#globbing), and run with the rest of the options detected by the sniffer:\n\n```sql\nFROM read_csv('part-*.csv', auto_detect=false, delim=',', quote='\"', escape='\"', new_line='\\n', skip=0, header=true, columns={'hello': 'BIGINT', 'world': 'VARCHAR'});\n```", "position": 9, "token_count": 163, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "guides-performance-file_formats-009", "document_id": "guides-performance-file_formats", "position": 9, "token_count": 163, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "guides/performance/file_formats.md", "url": "/guides/performance/file_formats", "title": "File Formats", "category": null, "tags": [], "section_url": "/guides/performance/file_formats"}}

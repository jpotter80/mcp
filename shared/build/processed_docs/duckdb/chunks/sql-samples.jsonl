{"chunk_id": "sql-samples-000", "document_id": "sql-samples", "content": "Samples are used to randomly select a subset of a dataset.", "position": 0, "token_count": 15, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-samples-000", "document_id": "sql-samples", "position": 0, "token_count": 15, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples"}}
{"chunk_id": "sql-samples-001", "document_id": "sql-samples", "content": "## Examples\n\nSelect a sample of exactly 5 rows from `tbl` using `reservoir` sampling:\n\n```sql\nSELECT *\nFROM tbl\nUSING SAMPLE 5;\n```\n\nSelect a sample of *approximately* 10% of the table using `system` sampling:\n\n```sql\nSELECT *\nFROM tbl\nUSING SAMPLE 10%;", "position": 1, "token_count": 71, "has_code": true, "section_hierarchy": ["Examples"], "metadata": {"chunk_id": "sql-samples-001", "document_id": "sql-samples", "position": 1, "token_count": 71, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Examples"], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples#examples"}}
{"chunk_id": "sql-samples-002", "document_id": "sql-samples", "content": "```\n\nSelect a sample of *approximately* 10% of the table using `system` sampling:\n\n```sql\nSELECT *\nFROM tbl\nUSING SAMPLE 10%;\n```\n\n> Warning By default, when you specify a percentage, each [*vector*]({% link docs/stable/internals/vector.md %}) is included in the sample with that probability. If your table contains fewer than ~10k rows, it makes sense to specify the `bernoulli` sampling option instead, which applies the probability to each row independently. Even then, you'll sometimes get more and sometimes less than the specified percentage of the number of rows, but it is much less likely that you get no rows at all. To get exactly 10% of rows (up to rounding), you must use the `reservoir` sampling option.\n\nSelect a sample of *approximately* 10% of the table using `bernoulli` sampling:\n\n```sql\nSELECT *\nFROM tbl\nUSING SAMPLE 10 PERCENT (bernoulli);", "position": 2, "token_count": 217, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-samples-002", "document_id": "sql-samples", "position": 2, "token_count": 217, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples"}}
{"chunk_id": "sql-samples-003", "document_id": "sql-samples", "content": "```\n\nSelect a sample of *exactly* 10% (up to rounding) of the table using `reservoir` sampling:\n\n```sql\nSELECT *\nFROM tbl\nUSING SAMPLE 10 PERCENT (reservoir);\n```\n\nSelect a sample of *exactly* 50 rows of the table using reservoir sampling with a fixed seed (100):\n\n```sql\nSELECT *\nFROM tbl\nUSING SAMPLE reservoir(50 ROWS)\nREPEATABLE (100);\n```\n\nSelect a sample of *approximately* 20% of the table using `system` sampling with a fixed seed (377):\n\n```sql\nSELECT *\nFROM tbl\nUSING SAMPLE 20% (system, 377);\n```\n\nSelect a sample of *approximately* 20% of `tbl` **before** the join with `tbl2`:\n\n```sql\nSELECT *\nFROM tbl TABLESAMPLE reservoir(20%), tbl2\nWHERE tbl.i = tbl2.i;", "position": 3, "token_count": 206, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-samples-003", "document_id": "sql-samples", "position": 3, "token_count": 206, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples"}}
{"chunk_id": "sql-samples-004", "document_id": "sql-samples", "content": "```\n\nSelect a sample of *approximately* 20% of `tbl` **after** the join with `tbl2`:\n\n```sql\nSELECT *\nFROM tbl, tbl2\nWHERE tbl.i = tbl2.i\nUSING SAMPLE reservoir(20%);\n```", "position": 4, "token_count": 68, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-samples-004", "document_id": "sql-samples", "position": 4, "token_count": 68, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples"}}
{"chunk_id": "sql-samples-005", "document_id": "sql-samples", "content": "## Syntax\n\nSamples allow you to randomly extract a subset of a dataset. Samples are useful for exploring a dataset faster, as often you might not be interested in the exact answers to queries, but only in rough indications of what the data looks like and what is in the data. Samples allow you to get approximate answers to queries faster, as they reduce the amount of data that needs to pass through the query engine.\n\nDuckDB supports three different types of sampling methods: `reservoir`, `bernoulli` and `system`. By default, DuckDB uses `reservoir` sampling when an exact number of rows is sampled, and `system` sampling when a percentage is specified. The sampling methods are described in detail below.\n\nSamples require a *sample size*, which is an indication of how many elements will be sampled from the total population. Samples can either be given as a percentage (`10%` or `10 PERCENT`) or as a fixed number of rows (`10` or `10 ROWS`). All three sampling methods support sampling over a percentage, but **only** reservoir sampling supports sampling a fixed number of rows.", "position": 5, "token_count": 239, "has_code": false, "section_hierarchy": ["Syntax"], "metadata": {"chunk_id": "sql-samples-005", "document_id": "sql-samples", "position": 5, "token_count": 239, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Syntax"], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples#syntax"}}
{"chunk_id": "sql-samples-006", "document_id": "sql-samples", "content": "Samples are probabilistic, that is to say, samples can be different between runs *unless* the seed is specifically specified. Specifying the seed *only* guarantees that the sample is the same if multi-threading is not enabled (i.e., `SET threads = 1`). In the case of multiple threads running over a sample, samples are not necessarily consistent even with a fixed seed.", "position": 6, "token_count": 87, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-samples-006", "document_id": "sql-samples", "position": 6, "token_count": 87, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples"}}
{"chunk_id": "sql-samples-007", "document_id": "sql-samples", "content": "## Sampling Methods\n\n### `reservoir`\n\nReservoir sampling is a stream sampling technique that selects a random sample by keeping a *reservoir* of size equal to the sample size, and randomly replacing elements as more elements come in. Reservoir sampling allows us to specify *exactly* how many elements we want in the resulting sample (by selecting the size of the reservoir). As a result, reservoir sampling *always* outputs the same amount of elements, unlike system and bernoulli sampling.\n\nReservoir sampling is only recommended for small sample sizes, and is not recommended for use with percentages. That is because reservoir sampling needs to materialize the entire sample and randomly replace tuples within the materialized sample. The larger the sample size, the higher the performance hit incurred by this process.\n\nReservoir sampling also incurs an additional performance penalty when multi-processing is used, since the reservoir is to be shared amongst the different threads to ensure unbiased sampling. This is not a big problem when the reservoir is very small, but becomes costly when the sample is large.\n\n> Bestpractice Avoid using reservoir sampling with large sample sizes if possible.\n> Reservoir sampling requires the entire sample to be materialized in memory.", "position": 7, "token_count": 243, "has_code": false, "section_hierarchy": ["`reservoir`"], "metadata": {"chunk_id": "sql-samples-007", "document_id": "sql-samples", "position": 7, "token_count": 243, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`reservoir`"], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples#reservoir"}}
{"chunk_id": "sql-samples-008", "document_id": "sql-samples", "content": "### `bernoulli`\n\nBernoulli sampling can only be used when a sampling percentage is specified. It is rather straightforward: every row in the underlying table is included with a chance equal to the specified percentage. As a result, bernoulli sampling can return a different number of tuples even if the same percentage is specified. The *expected* number of rows is equal to the specified percentage of the table, but there will be some *variance*.\n\nBecause bernoulli sampling is completely independent (there is no shared state), there is no penalty for using bernoulli sampling together with multiple threads.", "position": 8, "token_count": 128, "has_code": false, "section_hierarchy": ["`bernoulli`"], "metadata": {"chunk_id": "sql-samples-008", "document_id": "sql-samples", "position": 8, "token_count": 128, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`bernoulli`"], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples#bernoulli"}}
{"chunk_id": "sql-samples-009", "document_id": "sql-samples", "content": "### `system`\n\nSystem sampling is a variant of bernoulli sampling with one crucial difference: every *vector* is included with a chance equal to the sampling percentage. This is a form of cluster sampling. System sampling is more efficient than bernoulli sampling, as no per-tuple selections have to be performed.\n\nThe *expected* number of rows is still equal to the specified percentage of the table, but the *variance* is `vectorSize` times higher. As such, system sampling is not suitable for datasets with fewer than ~10k rows, where it can happen that all rows will be filtered out, or all the data will be included, even when you ask for `50 PERCENT`.", "position": 9, "token_count": 150, "has_code": false, "section_hierarchy": ["`system`"], "metadata": {"chunk_id": "sql-samples-009", "document_id": "sql-samples", "position": 9, "token_count": 150, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["`system`"], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples#system"}}
{"chunk_id": "sql-samples-010", "document_id": "sql-samples", "content": "## Table Samples\n\nThe `TABLESAMPLE` and `USING SAMPLE` clauses are identical in terms of syntax and effect, with one important difference: tablesamples sample directly from the table for which they are specified, whereas the sample clause samples after the entire from clause has been resolved. This is relevant when there are joins present in the query plan.\n\nThe `TABLESAMPLE` clause is essentially equivalent to creating a subquery with the `USING SAMPLE` clause, i.e., the following two queries are identical:\n\nSample 20% of `tbl` **before** the join:\n\n```sql\nSELECT *\nFROM\n tbl TABLESAMPLE reservoir(20%),\n tbl2\nWHERE tbl.i = tbl2.i;\n```\n\nSample 20% of `tbl` **before** the join:\n\n```sql\nSELECT *\nFROM\n (SELECT * FROM tbl USING SAMPLE reservoir(20%)) tbl,\n tbl2\nWHERE tbl.i = tbl2.i;", "position": 10, "token_count": 217, "has_code": true, "section_hierarchy": ["Table Samples"], "metadata": {"chunk_id": "sql-samples-010", "document_id": "sql-samples", "position": 10, "token_count": 217, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Table Samples"], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples#table-samples"}}
{"chunk_id": "sql-samples-011", "document_id": "sql-samples", "content": "```\n\nSample 20% **after** the join (i.e., sample 20% of the join result):\n\n```sql\nSELECT *\nFROM tbl, tbl2\nWHERE tbl.i = tbl2.i\nUSING SAMPLE reservoir(20%);\n```", "position": 11, "token_count": 65, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-samples-011", "document_id": "sql-samples", "position": 11, "token_count": 65, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/samples.md", "url": "/sql/samples", "title": "Samples", "category": null, "tags": [], "section_url": "/sql/samples"}}

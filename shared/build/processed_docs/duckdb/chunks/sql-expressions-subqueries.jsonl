{"chunk_id": "sql-expressions-subqueries-000", "document_id": "sql-expressions-subqueries", "content": "Subqueries are parenthesized query expressions that appear as part of a larger, outer query. Subqueries are usually based on `SELECT ... FROM`, but in DuckDB other query constructs such as [`PIVOT`]({% link docs/stable/sql/statements/pivot.md %}) can also appear as a subquery.", "position": 0, "token_count": 82, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "sql-expressions-subqueries-000", "document_id": "sql-expressions-subqueries", "position": 0, "token_count": 82, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries"}}
{"chunk_id": "sql-expressions-subqueries-001", "document_id": "sql-expressions-subqueries", "content": "## Scalar Subquery\n\nScalar subqueries are subqueries that return a single value. They can be used anywhere where an expression can be used. If a scalar subquery returns more than a single value, an error is raised (unless `scalar_subquery_error_on_multiple_rows` is set to `false`, in which case a row is selected randomly).\n\nConsider the following table:", "position": 1, "token_count": 94, "has_code": false, "section_hierarchy": ["Scalar Subquery"], "metadata": {"chunk_id": "sql-expressions-subqueries-001", "document_id": "sql-expressions-subqueries", "position": 1, "token_count": 94, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Scalar Subquery"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#scalar-subquery"}}
{"chunk_id": "sql-expressions-subqueries-002", "document_id": "sql-expressions-subqueries", "content": "### Grades\n\n| grade | course |\n|---:|:---|\n| 7 | Math |\n| 9 | Math |\n| 8 | CS |\n\n```sql\nCREATE TABLE grades (grade INTEGER, course VARCHAR);\nINSERT INTO grades VALUES (7, 'Math'), (9, 'Math'), (8, 'CS');\n```\n\nWe can run the following query to obtain the minimum grade:\n\n```sql\nSELECT min(grade) FROM grades;\n```\n\n| min(grade) |\n|-----------:|\n| 7 |\n\nBy using a scalar subquery in the `WHERE` clause, we can figure out for which course this grade was obtained:\n\n```sql\nSELECT course FROM grades WHERE grade = (SELECT min(grade) FROM grades);\n```\n\n| course |\n|--------|\n| Math |", "position": 2, "token_count": 202, "has_code": true, "section_hierarchy": ["Grades"], "metadata": {"chunk_id": "sql-expressions-subqueries-002", "document_id": "sql-expressions-subqueries", "position": 2, "token_count": 202, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Grades"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#grades"}}
{"chunk_id": "sql-expressions-subqueries-003", "document_id": "sql-expressions-subqueries", "content": "## `ARRAY` Subqueries\n\nSubqueries that return multiple values can be wrapped with `ARRAY` to collect all results in a list.\n\n```sql\nSELECT ARRAY(SELECT grade FROM grades) AS all_grades;\n```\n\n| all_grades |\n|-----------:|\n| [7, 9, 8] |", "position": 3, "token_count": 80, "has_code": true, "section_hierarchy": ["`ARRAY` Subqueries"], "metadata": {"chunk_id": "sql-expressions-subqueries-003", "document_id": "sql-expressions-subqueries", "position": 3, "token_count": 80, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`ARRAY` Subqueries"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#array-subqueries"}}
{"chunk_id": "sql-expressions-subqueries-004", "document_id": "sql-expressions-subqueries", "content": "## Subquery Comparisons: `ALL`, `ANY` and `SOME`\n\nIn the section on [scalar subqueries](#scalar-subquery), a scalar expression was compared directly to a subquery using the equality [comparison operator]({% link docs/stable/sql/expressions/comparison_operators.md %}#comparison-operators) (`=`).\nSuch direct comparisons only make sense with scalar subqueries.\n\nScalar expressions can still be compared to single-column subqueries returning multiple rows by specifying a quantifier. Available quantifiers are `ALL`, `ANY` and `SOME`. The quantifiers `ANY` and `SOME` are equivalent.", "position": 4, "token_count": 163, "has_code": false, "section_hierarchy": ["Subquery Comparisons: `ALL`, `ANY` and `SOME`"], "metadata": {"chunk_id": "sql-expressions-subqueries-004", "document_id": "sql-expressions-subqueries", "position": 4, "token_count": 163, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Subquery Comparisons: `ALL`, `ANY` and `SOME`"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#subquery-comparisons-all-any-and-some"}}
{"chunk_id": "sql-expressions-subqueries-005", "document_id": "sql-expressions-subqueries", "content": "### `ALL`\n\nThe `ALL` quantifier specifies that the comparison as a whole evaluates to `true` when the individual comparison results of _the expression at the left hand side of the comparison operator_ with each of the values from _the subquery at the right hand side of the comparison operator_ **all** evaluate to `true`:\n\n```sql\nSELECT 6 = ALL (SELECT grade FROM grades) AS excellent;\n```\n\nreturns\n\n| excellent |\n|-----------|\n| false |\n\nbecause 8 is not greater than or equal to the subquery result 7. And thus, because not all comparisons evaluate `true`, `>= ALL` as a whole evaluates to `false`.", "position": 5, "token_count": 163, "has_code": true, "section_hierarchy": ["`ALL`"], "metadata": {"chunk_id": "sql-expressions-subqueries-005", "document_id": "sql-expressions-subqueries", "position": 5, "token_count": 163, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`ALL`"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#all"}}
{"chunk_id": "sql-expressions-subqueries-006", "document_id": "sql-expressions-subqueries", "content": "### `ANY`\n\nThe `ANY` quantifier specifies that the comparison as a whole evaluates to `true` when at least one of the individual comparison results evaluates to `true`.\nFor example:\n\n```sql\nSELECT 5 >= ANY (SELECT grade FROM grades) AS fail;\n```\n\nreturns\n\n| fail |\n|-------|\n| false |\n\nbecause no result of the subquery is less than or equal to 5.\n\nThe quantifier `SOME` maybe used instead of `ANY`: `ANY` and `SOME` are interchangeable.", "position": 6, "token_count": 128, "has_code": true, "section_hierarchy": ["`ANY`"], "metadata": {"chunk_id": "sql-expressions-subqueries-006", "document_id": "sql-expressions-subqueries", "position": 6, "token_count": 128, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`ANY`"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#any"}}
{"chunk_id": "sql-expressions-subqueries-007", "document_id": "sql-expressions-subqueries", "content": "## `EXISTS`\n\nThe `EXISTS` operator tests for the existence of any row inside the subquery. It returns either true when the subquery returns one or more records, and false otherwise. The `EXISTS` operator is generally the most useful as a *correlated* subquery to express semijoin operations. However, it can be used as an uncorrelated subquery as well.\n\nFor example, we can use it to figure out if there are any grades present for a given course:\n\n```sql\nSELECT EXISTS (FROM grades WHERE course = 'Math') AS math_grades_present;\n```\n\n| math_grades_present |\n|--------------------:|\n| true |\n\n```sql\nSELECT EXISTS (FROM grades WHERE course = 'History') AS history_grades_present;", "position": 7, "token_count": 190, "has_code": true, "section_hierarchy": ["`EXISTS`"], "metadata": {"chunk_id": "sql-expressions-subqueries-007", "document_id": "sql-expressions-subqueries", "position": 7, "token_count": 190, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`EXISTS`"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#exists"}}
{"chunk_id": "sql-expressions-subqueries-008", "document_id": "sql-expressions-subqueries", "content": "```\n\n| history_grades_present |\n|-----------------------:|\n| false |\n\n> The subqueries in the examples above make use of the fact that you can omit the `SELECT *` in DuckDB thanks to the [`FROM`-first syntax]({% link docs/stable/sql/query_syntax/from.md %}). The `SELECT` clause is required in subqueries by other SQL systems but cannot fulfil any purpose in `EXISTS` and `NOT EXISTS` subqueries.", "position": 8, "token_count": 136, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-expressions-subqueries-008", "document_id": "sql-expressions-subqueries", "position": 8, "token_count": 136, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries"}}
{"chunk_id": "sql-expressions-subqueries-009", "document_id": "sql-expressions-subqueries", "content": "### `NOT EXISTS`\n\nThe `NOT EXISTS` operator tests for the absence of any row inside the subquery. It returns either true when the subquery returns an empty result, and false otherwise. The `NOT EXISTS` operator is generally the most useful as a *correlated* subquery to express antijoin operations. For example, to find Person nodes without an interest:\n\n```sql\nCREATE TABLE Person (id BIGINT, name VARCHAR);\nCREATE TABLE interest (PersonId BIGINT, topic VARCHAR);\n\nINSERT INTO Person VALUES (1, 'Jane'), (2, 'Joe');\nINSERT INTO interest VALUES (2, 'Music');\n\nSELECT *\nFROM Person\nWHERE NOT EXISTS (FROM interest WHERE interest.PersonId = Person.id);\n```\n\n| id | name |\n|---:|------|\n| 1 | Jane |\n\n> DuckDB automatically detects when a `NOT EXISTS` query expresses an antijoin operation. There is no need to manually rewrite such queries to use `LEFT OUTER JOIN ... WHERE ... IS NULL`.", "position": 9, "token_count": 243, "has_code": true, "section_hierarchy": ["`NOT EXISTS`"], "metadata": {"chunk_id": "sql-expressions-subqueries-009", "document_id": "sql-expressions-subqueries", "position": 9, "token_count": 243, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`NOT EXISTS`"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#not-exists"}}
{"chunk_id": "sql-expressions-subqueries-010", "document_id": "sql-expressions-subqueries", "content": "## `IN` Operator\n\nThe `IN` operator checks containment of the left expression inside the result defined by the subquery or the set of expressions on the right hand side (RHS). The `IN` operator returns true if the expression is present in the RHS, false if the expression is not in the RHS and the RHS has no `NULL` values, or `NULL` if the expression is not in the RHS and the RHS has `NULL` values.\n\nWe can use the `IN` operator in a similar manner as we used the `EXISTS` operator:\n\n```sql\nSELECT 'Math' IN (SELECT course FROM grades) AS math_grades_present;\n```\n\n| math_grades_present |\n|--------------------:|\n| true |", "position": 10, "token_count": 183, "has_code": true, "section_hierarchy": ["`IN` Operator"], "metadata": {"chunk_id": "sql-expressions-subqueries-010", "document_id": "sql-expressions-subqueries", "position": 10, "token_count": 183, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`IN` Operator"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#in-operator"}}
{"chunk_id": "sql-expressions-subqueries-011", "document_id": "sql-expressions-subqueries", "content": "## Correlated Subqueries\n\nAll the subqueries presented here so far have been **uncorrelated** subqueries, where the subqueries themselves are entirely self-contained and can be run without the parent query. There exists a second type of subqueries called **correlated** subqueries. For correlated subqueries, the subquery uses values from the parent subquery.\n\nConceptually, the subqueries are run once for every single row in the parent query. Perhaps a simple way of envisioning this is that the correlated subquery is a **function** that is applied to every row in the source dataset.\n\nFor example, suppose that we want to find the minimum grade for every course. We could do that as follows:\n\n```sql\nSELECT *\nFROM grades grades_parent\nWHERE grade =\n (SELECT min(grade)\n FROM grades\n WHERE grades.course = grades_parent.course);", "position": 11, "token_count": 200, "has_code": true, "section_hierarchy": ["Correlated Subqueries"], "metadata": {"chunk_id": "sql-expressions-subqueries-011", "document_id": "sql-expressions-subqueries", "position": 11, "token_count": 200, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Correlated Subqueries"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#correlated-subqueries"}}
{"chunk_id": "sql-expressions-subqueries-012", "document_id": "sql-expressions-subqueries", "content": "```\n\n| grade | course |\n|------:|--------|\n| 7 | Math |\n| 8 | CS |\n\nThe subquery uses a column from the parent query (`grades_parent.course`). Conceptually, we can see the subquery as a function where the correlated column is a parameter to that function:\n\n```sql\nSELECT min(grade)\nFROM grades\nWHERE course = ?;\n```\n\nNow when we execute this function for each of the rows, we can see that for `Math` this will return `7`, and for `CS` it will return `8`. We then compare it against the grade for that actual row. As a result, the row `(Math, 9)` will be filtered out, as `9 <> 7`.", "position": 12, "token_count": 179, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "sql-expressions-subqueries-012", "document_id": "sql-expressions-subqueries", "position": 12, "token_count": 179, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries"}}
{"chunk_id": "sql-expressions-subqueries-013", "document_id": "sql-expressions-subqueries", "content": "## Returning Each Row of the Subquery as a Struct\n\nUsing the name of a subquery in the `SELECT` clause (without referring to a specific column) turns each row of the subquery into a struct whose fields correspond to the columns of the subquery. For example:\n\n```sql\nSELECT t\nFROM (SELECT unnest(generate_series(41, 43)) AS x, 'hello' AS y) t;\n```\n\n| t |\n|-----------------------|\n| {'x': 41, 'y': hello} |\n| {'x': 42, 'y': hello} |\n| {'x': 43, 'y': hello} |", "position": 13, "token_count": 176, "has_code": true, "section_hierarchy": ["Returning Each Row of the Subquery as a Struct"], "metadata": {"chunk_id": "sql-expressions-subqueries-013", "document_id": "sql-expressions-subqueries", "position": 13, "token_count": 176, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Returning Each Row of the Subquery as a Struct"], "file_path": "sql/expressions/subqueries.md", "url": "/sql/expressions/subqueries", "title": "Subqueries", "category": null, "tags": [], "section_url": "/sql/expressions/subqueries#returning-each-row-of-the-subquery-as-a-struct"}}

{"chunk_id": "clients-python-function-000", "document_id": "clients-python-function", "content": "You can create a DuckDB user-defined function (UDF) from a Python function so it can be used in SQL queries.\nSimilarly to regular [functions]({% link docs/stable/sql/functions/overview.md %}), they need to have a name, a return type and parameter types.\n\nHere is an example using a Python function that calls a third-party library.\n\n```python\nimport duckdb\nfrom duckdb.sqltypes import VARCHAR\nfrom faker import Faker\n\ndef generate_random_name():\n fake = Faker()\n return fake.name()\n\nduckdb.create_function(\"random_name\", generate_random_name, [], VARCHAR)\nres = duckdb.sql(\"SELECT random_name()\").fetchall()\nprint(res)\n```\n\n```text\n[('Gerald Ashley',)]\n```", "position": 0, "token_count": 201, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-000", "document_id": "clients-python-function", "position": 0, "token_count": 201, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-001", "document_id": "clients-python-function", "content": "## Creating Functions\n\nTo register a Python UDF, use the `create_function` method from a DuckDB connection. Here is the syntax:\n\n```python\nimport duckdb\ncon = duckdb.connect()\ncon.create_function(name, function, parameters, return_type)", "position": 1, "token_count": 63, "has_code": true, "section_hierarchy": ["Creating Functions"], "metadata": {"chunk_id": "clients-python-function-001", "document_id": "clients-python-function", "position": 1, "token_count": 63, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Creating Functions"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#creating-functions"}}
{"chunk_id": "clients-python-function-002", "document_id": "clients-python-function", "content": "```\n\nThe `create_function` method takes the following parameters:", "position": 2, "token_count": 17, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-002", "document_id": "clients-python-function", "position": 2, "token_count": 17, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-003", "document_id": "clients-python-function", "content": "1. `name` A string representing the unique name of the UDF within the connection catalog.\n2. `function` The Python function you wish to register as a UDF.\n3. `parameters` Scalar functions can operate on one or more columns. This parameter takes a list of column types used as input.\n4. `return_type` Scalar functions return one element per row. This parameter specifies the return type of the function.\n5. `type` (optional): DuckDB supports both native Python types and PyArrow Arrays. By default, `type = 'native'` is assumed, but you can specify `type = 'arrow'` to use PyArrow Arrays. In general, using an Arrow UDF will be much more efficient than native because it will be able to operate in batches.\n6. `null_handling` (optional): By default, `NULL` values are automatically handled as `NULL`-in `NULL`-out. Users can specify a desired behavior for `NULL` values by setting `null_handling = 'special'`.", "position": 3, "token_count": 228, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-003", "document_id": "clients-python-function", "position": 3, "token_count": 228, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-004", "document_id": "clients-python-function", "content": "7. `exception_handling` (optional): By default, when an exception is thrown from the Python function, it will be re-thrown in Python. Users can disable this behavior, and instead return `NULL`, by setting this parameter to `'return_null'`\n8. `side_effects` (optional): By default, functions are expected to produce the same result for the same input. If the result of a function is impacted by any type of randomness, `side_effects` must be set to `True`.", "position": 4, "token_count": 116, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-004", "document_id": "clients-python-function", "position": 4, "token_count": 116, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-005", "document_id": "clients-python-function", "content": "To unregister a UDF, you can call the `remove_function` method with the UDF name:\n\n```python\ncon.remove_function(name)", "position": 5, "token_count": 39, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-005", "document_id": "clients-python-function", "position": 5, "token_count": 39, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-006", "document_id": "clients-python-function", "content": "```", "position": 6, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-006", "document_id": "clients-python-function", "position": 6, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-007", "document_id": "clients-python-function", "content": "### Using Partial Functions\n\nDuckDB UDFs can also be created with [Python partial functions](https://docs.python.org/3/library/functools.html#functools.partial).\n\nIn the below example, we show how a custom logger will return the concatenation of the execution datetime in ISO format, always followed by\nargument passed at UDF creation and the input parameter provided to the function call:\n\n```python\nfrom datetime import datetime\nimport duckdb\nimport functools\n\ndef get_datetime_iso_format() -> str:\n return datetime.now().isoformat()\n\ndef logger_udf(func, arg1: str, arg2: int) -> str:\n return ' '.join([func(), arg1, str(arg2)])", "position": 7, "token_count": 199, "has_code": true, "section_hierarchy": ["Using Partial Functions"], "metadata": {"chunk_id": "clients-python-function-007", "document_id": "clients-python-function", "position": 7, "token_count": 199, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Using Partial Functions"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#using-partial-functions"}}
{"chunk_id": "clients-python-function-008", "document_id": "clients-python-function", "content": "with duckdb.connect() as con:\n con.sql(\"select * from range(10) tbl(id)\").to_table(\"example_table\")\n\n con.create_function(\n 'custom_logger',\n functools.partial(logger_udf, get_datetime_iso_format, 'logging data')\n )\n rel = con.sql(\"SELECT custom_logger(id) from example_table;\")\n rel.show()\n\n con.create_function(\n 'another_custom_logger',\n functools.partial(logger_udf, get_datetime_iso_format, ':')\n )\n rel = con.sql(\"SELECT another_custom_logger(id) from example_table;\")\n rel.show()", "position": 8, "token_count": 185, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-008", "document_id": "clients-python-function", "position": 8, "token_count": 185, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-009", "document_id": "clients-python-function", "content": "```\n\n```text\n┌───────────────────────────────────────────┐\n│ custom_logger(id) │\n│ varchar │\n├───────────────────────────────────────────┤\n│ 2025-03-27T12:07:56.811251 logging data 0 │\n│ 2025-03-27T12:07:56.811264 logging data 1 │\n│ 2025-03-27T12:07:56.811266 logging data 2 │\n│ 2025-03-27T12:07:56.811268 logging data 3 │\n│ 2025-03-27T12:07:56.811269 logging data 4 │\n│ 2025-03-27T12:07:56.811270 logging data 5 │\n│ 2025-03-27T12:07:56.811271 logging data 6 │\n│ 2025-03-27T12:07:56.811272 logging data 7 │\n│ 2025-03-27T12:07:56.811274 logging data 8 │\n│ 2025-03-27T12:07:56.811275 logging data 9 │\n├───────────────────────────────────────────┤\n│ 10 rows │\n└───────────────────────────────────────────┘", "position": 9, "token_count": 246, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-009", "document_id": "clients-python-function", "position": 9, "token_count": 246, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-010", "document_id": "clients-python-function", "content": "┌────────────────────────────────┐\n│ another_custom_logger(id) │\n│ varchar │\n├────────────────────────────────┤\n│ 2025-03-27T12:07:56.812106 : 0 │\n│ 2025-03-27T12:07:56.812116 : 1 │\n│ 2025-03-27T12:07:56.812118 : 2 │\n│ 2025-03-27T12:07:56.812119 : 3 │\n│ 2025-03-27T12:07:56.812121 : 4 │\n│ 2025-03-27T12:07:56.812122 : 5 │\n│ 2025-03-27T12:07:56.812123 : 6 │\n│ 2025-03-27T12:07:56.812124 : 7 │\n│ 2025-03-27T12:07:56.812126 : 8 │\n│ 2025-03-27T12:07:56.812127 : 9 │\n├────────────────────────────────┤\n│ 10 rows │\n└────────────────────────────────┘", "position": 10, "token_count": 227, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-010", "document_id": "clients-python-function", "position": 10, "token_count": 227, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-011", "document_id": "clients-python-function", "content": "```", "position": 11, "token_count": 5, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-011", "document_id": "clients-python-function", "position": 11, "token_count": 5, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-012", "document_id": "clients-python-function", "content": "## Type Annotation\n\nWhen the function has type annotation it's often possible to leave out all of the optional parameters.\nUsing `DuckDBPyType` we can implicitly convert many known types to DuckDBs type system.\nFor example:\n\n```python\nimport duckdb\n\ndef my_function(x: int) -> str:\n return x\n\nduckdb.create_function(\"my_func\", my_function)\nprint(duckdb.sql(\"SELECT my_func(42)\"))\n```\n\n```text\n┌─────────────┐\n│ my_func(42) │\n│ varchar │\n├─────────────┤\n│ 42 │\n└─────────────┘\n```\n\nIf only the parameter list types can be inferred, you'll need to pass in `None` as `parameters`.", "position": 12, "token_count": 172, "has_code": true, "section_hierarchy": ["Type Annotation"], "metadata": {"chunk_id": "clients-python-function-012", "document_id": "clients-python-function", "position": 12, "token_count": 172, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Type Annotation"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#type-annotation"}}
{"chunk_id": "clients-python-function-013", "document_id": "clients-python-function", "content": "## `NULL` Handling\n\nBy default when functions receive a `NULL` value, this instantly returns `NULL`, as part of the default `NULL`-handling.\nWhen this is not desired, you need to explicitly set this parameter to `\"special\"`.\n\n```python\nimport duckdb\nfrom duckdb.sqltypes import BIGINT\n\ndef dont_intercept_null(x):\n return 5\n\nduckdb.create_function(\"dont_intercept\", dont_intercept_null, [BIGINT], BIGINT)\nres = duckdb.sql(\"SELECT dont_intercept(NULL)\").fetchall()\nprint(res)\n```\n\n```text\n[(None,)]", "position": 13, "token_count": 156, "has_code": true, "section_hierarchy": ["`NULL` Handling"], "metadata": {"chunk_id": "clients-python-function-013", "document_id": "clients-python-function", "position": 13, "token_count": 156, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`NULL` Handling"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#null-handling"}}
{"chunk_id": "clients-python-function-014", "document_id": "clients-python-function", "content": "```\n\n```text\n[(None,)]\n```\n\nWith `null_handling=\"special\"`:\n\n```python\nimport duckdb\nfrom duckdb.sqltypes import BIGINT\n\ndef dont_intercept_null(x):\n return 5\n\nduckdb.create_function(\"dont_intercept\", dont_intercept_null, [BIGINT], BIGINT, null_handling=\"special\")\nres = duckdb.sql(\"SELECT dont_intercept(NULL)\").fetchall()\nprint(res)\n```\n\n```text\n[(5,)]", "position": 14, "token_count": 136, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-014", "document_id": "clients-python-function", "position": 14, "token_count": 136, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-015", "document_id": "clients-python-function", "content": "```\n\n```text\n[(5,)]\n```\n\n> Always use `null_handling=\"special\"` when the function can return NULL.\n\n```python\nimport duckdb\nfrom duckdb.sqltypes import VARCHAR\n\ndef return_str_or_none(x: str) -> str | None:\n if not x:\n return None\n\n return x\n\nduckdb.create_function(\n \"return_str_or_none\",\n return_str_or_none,\n [VARCHAR],\n VARCHAR,\n null_handling=\"special\"\n)\nres = duckdb.sql(\"SELECT return_str_or_none('')\").fetchall()\nprint(res)\n```\n\n```text\n[(None,)]\n```", "position": 15, "token_count": 178, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-015", "document_id": "clients-python-function", "position": 15, "token_count": 178, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-016", "document_id": "clients-python-function", "content": "## Exception Handling\n\nBy default, when an exception is thrown from the Python function, we'll forward (re-throw) the exception.\nIf you want to disable this behavior, and instead return `NULL`, you'll need to set this parameter to `\"return_null\"`.\n\n```python\nimport duckdb\nfrom duckdb.sqltypes import BIGINT\n\ndef will_throw():\n raise ValueError(\"ERROR\")\n\nduckdb.create_function(\"throws\", will_throw, [], BIGINT)\ntry:\n res = duckdb.sql(\"SELECT throws()\").fetchall()\nexcept duckdb.InvalidInputException as e:\n print(e)\n\nduckdb.create_function(\"doesnt_throw\", will_throw, [], BIGINT, exception_handling=\"return_null\")\nres = duckdb.sql(\"SELECT doesnt_throw()\").fetchall()\nprint(res)", "position": 16, "token_count": 215, "has_code": true, "section_hierarchy": ["Exception Handling"], "metadata": {"chunk_id": "clients-python-function-016", "document_id": "clients-python-function", "position": 16, "token_count": 215, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Exception Handling"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#exception-handling"}}
{"chunk_id": "clients-python-function-017", "document_id": "clients-python-function", "content": "```\n\n```console\nInvalid Input Error: Python exception occurred while executing the UDF: ValueError: ERROR\n\nAt:\n ...(5): will_throw\n ...(9):\n```\n\n```text\n[(None,)]\n```", "position": 17, "token_count": 62, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-017", "document_id": "clients-python-function", "position": 17, "token_count": 62, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-018", "document_id": "clients-python-function", "content": "## Side Effects\n\nBy default DuckDB will assume the created function is a *pure* function, meaning it will produce the same output when given the same input.\nIf your function does not follow that rule, for example when your function makes use of randomness, then you will need to mark this function as having `side_effects`.\n\nFor example, this function will produce a new count for every invocation.\n\n```python\ndef count() -> int:\n old = count.counter;\n count.counter += 1\n return old\n\ncount.counter = 0\n```\n\nIf we create this function without marking it as having side effects, the result will be the following:\n\n```python\ncon = duckdb.connect()\ncon.create_function(\"my_counter\", count, side_effects=False)\nres = con.sql(\"SELECT my_counter() FROM range(10)\").fetchall()\nprint(res)", "position": 18, "token_count": 201, "has_code": true, "section_hierarchy": ["Side Effects"], "metadata": {"chunk_id": "clients-python-function-018", "document_id": "clients-python-function", "position": 18, "token_count": 201, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Side Effects"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#side-effects"}}
{"chunk_id": "clients-python-function-019", "document_id": "clients-python-function", "content": "```\n\n```text\n[(0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,)]\n```\n\nWhich is obviously not the desired result, when we add `side_effects=True`, the result is as we would expect:\n\n```python\ncon.remove_function(\"my_counter\")\ncount.counter = 0\ncon.create_function(\"my_counter\", count, side_effects=True)\nres = con.sql(\"SELECT my_counter() FROM range(10)\").fetchall()\nprint(res)\n```\n\n```text\n[(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,)]\n```", "position": 19, "token_count": 221, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-019", "document_id": "clients-python-function", "position": 19, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-020", "document_id": "clients-python-function", "content": "## Python Function Types\n\nCurrently, two function types are supported, `native` (default) and `arrow`.", "position": 20, "token_count": 26, "has_code": false, "section_hierarchy": ["Python Function Types"], "metadata": {"chunk_id": "clients-python-function-020", "document_id": "clients-python-function", "position": 20, "token_count": 26, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Python Function Types"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#python-function-types"}}
{"chunk_id": "clients-python-function-021", "document_id": "clients-python-function", "content": "### Arrow\n\nIf the function is expected to receive arrow arrays, set the `type` parameter to `'arrow'`.\n\nThis will let the system know to provide arrow arrays of up to `STANDARD_VECTOR_SIZE` tuples to the function, and also expect an array of the same amount of tuples to be returned from the function.\n\nIn general, using an Arrow UDF will be much more efficient than native because it will be able to operate in batches.\n\n```python\nimport duckdb\nimport pyarrow as pa\nfrom duckdb.sqltypes import VARCHAR\nfrom pyarrow import compute as pc\n\ndef mirror(strings: pa.Array, sep: pa.Array) -> pa.Array:\n assert isinstance(strings, pa.ChunkedArray)\n assert isinstance(sep, pa.ChunkedArray)\n return pc.binary_join_element_wise(strings, pc.ascii_reverse(strings), sep)", "position": 21, "token_count": 207, "has_code": true, "section_hierarchy": ["Arrow"], "metadata": {"chunk_id": "clients-python-function-021", "document_id": "clients-python-function", "position": 21, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Arrow"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#arrow"}}
{"chunk_id": "clients-python-function-022", "document_id": "clients-python-function", "content": "duckdb.create_function(\n \"mirror\",\n mirror,\n [VARCHAR, VARCHAR],\n return_type=VARCHAR,\n type=\"arrow\",\n)\n\nduckdb.sql(\n \"CREATE OR REPLACE TABLE strings AS SELECT 'hello' AS str UNION ALL SELECT 'world' AS str;\"\n)\nprint(duckdb.sql(\"SELECT mirror(str, '|') FROM strings;\").fetchall())", "position": 22, "token_count": 100, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-022", "document_id": "clients-python-function", "position": 22, "token_count": 100, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-023", "document_id": "clients-python-function", "content": "```\n\n```text\n[('hello|olleh',), ('world|dlrow',)]\n```", "position": 23, "token_count": 34, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "clients-python-function-023", "document_id": "clients-python-function", "position": 23, "token_count": 34, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function"}}
{"chunk_id": "clients-python-function-024", "document_id": "clients-python-function", "content": "### Native\n\nWhen the function type is set to `native` the function will be provided with a single tuple at a time, and expect only a single value to be returned.\nThis can be useful to interact with Python libraries that don't operate on Arrow, such as `faker`:\n\n```python\nimport duckdb\n\nfrom duckdb.sqltypes import DATE\nfrom faker import Faker\n\ndef random_date():\n fake = Faker()\n return fake.date_between()\n\nduckdb.create_function(\n \"random_date\",\n random_date,\n parameters=[],\n return_type=DATE,\n type=\"native\",\n)\nres = duckdb.sql(\"SELECT random_date()\").fetchall()\nprint(res)\n```\n\n```text\n[(datetime.date(2019, 5, 15),)]\n```", "position": 24, "token_count": 193, "has_code": true, "section_hierarchy": ["Native"], "metadata": {"chunk_id": "clients-python-function-024", "document_id": "clients-python-function", "position": 24, "token_count": 193, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Native"], "file_path": "clients/python/function.md", "url": "/clients/python/function", "title": "Python Function API", "category": null, "tags": [], "section_url": "/clients/python/function#native"}}

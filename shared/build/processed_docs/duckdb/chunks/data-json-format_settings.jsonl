{"chunk_id": "data-json-format_settings-000", "document_id": "data-json-format_settings", "content": "The JSON extension can attempt to determine the format of a JSON file when setting `format` to `auto`.\nHere are some example JSON files and the corresponding `format` settings that should be used.\n\nIn each of the below cases, the `format` setting was not needed, as DuckDB was able to infer it correctly, but it is included for illustrative purposes.\nA query of this shape would work in each case:\n\n```sql\nSELECT *\nFROM filename.json;\n```", "position": 0, "token_count": 110, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-format_settings-000", "document_id": "data-json-format_settings", "position": 0, "token_count": 110, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "data/json/format_settings.md", "url": "/data/json/format_settings", "title": "JSON Format Settings", "category": null, "tags": [], "section_url": "/data/json/format_settings"}}
{"chunk_id": "data-json-format_settings-001", "document_id": "data-json-format_settings", "content": "## Format: `newline_delimited`\n\nWith `format = 'newline_delimited'` newline-delimited JSON can be parsed.\nEach line is a JSON.\n\nWe use the example file [`records.json`]({% link data/records.json %}) with the following content:\n\n```json\n{\"key1\":\"value1\", \"key2\": \"value1\"}\n{\"key1\":\"value2\", \"key2\": \"value2\"}\n{\"key1\":\"value3\", \"key2\": \"value3\"}\n```\n\n```sql\nSELECT *\nFROM read_json('records.json', format = 'newline_delimited');\n```\n\n| key1 | key2 |\n|--------|--------|\n| value1 | value1 |\n| value2 | value2 |\n| value3 | value3 |", "position": 1, "token_count": 230, "has_code": true, "section_hierarchy": ["Format: `newline_delimited`"], "metadata": {"chunk_id": "data-json-format_settings-001", "document_id": "data-json-format_settings", "position": 1, "token_count": 230, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Format: `newline_delimited`"], "file_path": "data/json/format_settings.md", "url": "/data/json/format_settings", "title": "JSON Format Settings", "category": null, "tags": [], "section_url": "/data/json/format_settings#format-newlinedelimited"}}
{"chunk_id": "data-json-format_settings-002", "document_id": "data-json-format_settings", "content": "## Format: `array`\n\nIf the JSON file contains a JSON array of objects (pretty-printed or not), `array_of_objects` may be used.\nTo demonstrate its use, we use the example file [`records-in-array.json`]({% link data/records-in-array.json %}):\n\n```json\n[\n {\"key1\":\"value1\", \"key2\": \"value1\"},\n {\"key1\":\"value2\", \"key2\": \"value2\"},\n {\"key1\":\"value3\", \"key2\": \"value3\"}\n]\n```\n\n```sql\nSELECT *\nFROM read_json('records-in-array.json', format = 'array');\n```\n\n| key1 | key2 |\n|--------|--------|\n| value1 | value1 |\n| value2 | value2 |\n| value3 | value3 |", "position": 2, "token_count": 235, "has_code": true, "section_hierarchy": ["Format: `array`"], "metadata": {"chunk_id": "data-json-format_settings-002", "document_id": "data-json-format_settings", "position": 2, "token_count": 235, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Format: `array`"], "file_path": "data/json/format_settings.md", "url": "/data/json/format_settings", "title": "JSON Format Settings", "category": null, "tags": [], "section_url": "/data/json/format_settings#format-array"}}
{"chunk_id": "data-json-format_settings-003", "document_id": "data-json-format_settings", "content": "## Format: `unstructured`\n\nIf the JSON file contains JSON that is not newline-delimited or an array, `unstructured` may be used.\nTo demonstrate its use, we use the example file [`unstructured.json`]({% link data/unstructured.json %}):\n\n```json\n{\n \"key1\":\"value1\",\n \"key2\":\"value1\"\n}\n{\n \"key1\":\"value2\",\n \"key2\":\"value2\"\n}\n{\n \"key1\":\"value3\",\n \"key2\":\"value3\"\n}\n```\n\n```sql\nSELECT *\nFROM read_json('unstructured.json', format = 'unstructured');\n```\n\n| key1 | key2 |\n|--------|--------|\n| value1 | value1 |\n| value2 | value2 |\n| value3 | value3 |", "position": 3, "token_count": 228, "has_code": true, "section_hierarchy": ["Format: `unstructured`"], "metadata": {"chunk_id": "data-json-format_settings-003", "document_id": "data-json-format_settings", "position": 3, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Format: `unstructured`"], "file_path": "data/json/format_settings.md", "url": "/data/json/format_settings", "title": "JSON Format Settings", "category": null, "tags": [], "section_url": "/data/json/format_settings#format-unstructured"}}
{"chunk_id": "data-json-format_settings-004", "document_id": "data-json-format_settings", "content": "## `records` Options\n\nThe JSON extension can attempt to determine whether a JSON file contains records when setting `records = auto`.\nWhen `records = true`, the JSON extension expects JSON objects, and will unpack the fields of JSON objects into individual columns.\n\nContinuing with the same example file, [`records.json`]({% link data/records.json %}):\n\n```json\n{\"key1\":\"value1\", \"key2\": \"value1\"}\n{\"key1\":\"value2\", \"key2\": \"value2\"}\n{\"key1\":\"value3\", \"key2\": \"value3\"}\n```\n\n```sql\nSELECT *\nFROM read_json('records.json', records = true);", "position": 4, "token_count": 185, "has_code": true, "section_hierarchy": ["`records` Options"], "metadata": {"chunk_id": "data-json-format_settings-004", "document_id": "data-json-format_settings", "position": 4, "token_count": 185, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`records` Options"], "file_path": "data/json/format_settings.md", "url": "/data/json/format_settings", "title": "JSON Format Settings", "category": null, "tags": [], "section_url": "/data/json/format_settings#records-options"}}
{"chunk_id": "data-json-format_settings-005", "document_id": "data-json-format_settings", "content": "```\n\n```sql\nSELECT *\nFROM read_json('records.json', records = true);\n```\n\n| key1 | key2 |\n|--------|--------|\n| value1 | value1 |\n| value2 | value2 |\n| value3 | value3 |\n\nWhen `records = false`, the JSON extension will not unpack the top-level objects, and create `STRUCT`s instead:\n\n```sql\nSELECT *\nFROM read_json('records.json', records = false);", "position": 5, "token_count": 134, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-format_settings-005", "document_id": "data-json-format_settings", "position": 5, "token_count": 134, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/format_settings.md", "url": "/data/json/format_settings", "title": "JSON Format Settings", "category": null, "tags": [], "section_url": "/data/json/format_settings"}}
{"chunk_id": "data-json-format_settings-006", "document_id": "data-json-format_settings", "content": "```\n\n| json |\n|----------------------------------|\n| {'key1': value1, 'key2': value1} |\n| {'key1': value2, 'key2': value2} |\n| {'key1': value3, 'key2': value3} |\n\nThis is especially useful if we have non-object JSON, for example, [`arrays.json`]({% link data/arrays.json %}):\n\n```json\n[1, 2, 3]\n[4, 5, 6]\n[7, 8, 9]\n```\n\n```sql\nSELECT *\nFROM read_json('arrays.json', records = false);\n```\n\n| json |\n|-----------|\n| [1, 2, 3] |\n| [4, 5, 6] |\n| [7, 8, 9] |", "position": 6, "token_count": 240, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "data-json-format_settings-006", "document_id": "data-json-format_settings", "position": 6, "token_count": 240, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "data/json/format_settings.md", "url": "/data/json/format_settings", "title": "JSON Format Settings", "category": null, "tags": [], "section_url": "/data/json/format_settings"}}

{"chunk_id": "values-ownership-000", "document_id": "values-ownership", "content": "A challenge you might face when using some programming languages is that you\nmust manually allocate and deallocate memory. When multiple parts of the\nprogram need access to the same memory, it becomes difficult to keep track of\nwho \"owns\" a value and determine when is the right time to deallocate it. If\nyou make a mistake, it can result in a \"use-after-free\" error, a \"double free\"\nerror, or a \"leaked memory\" error, any one of which can be catastrophic.\n\nMojo helps avoid these errors by ensuring there is only one variable that owns\neach value at a time, while still allowing you to share references with other\nfunctions. When the life span of the owner ends, Mojo [destroys the\nvalue](/mojo/manual/lifecycle/death). Programmers are still responsible for\nmaking sure any type that allocates resources (including memory) also\ndeallocates those resources in its destructor. Mojo's ownership system ensures\nthat destructors are called promptly.\n\nOn this page, we'll explain the rules that govern this ownership model, and how\nto specify different argument conventions that define how values are passed into\nfunctions.", "position": 0, "token_count": 240, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "values-ownership-000", "document_id": "values-ownership", "position": 0, "token_count": 240, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership"}}
{"chunk_id": "values-ownership-001", "document_id": "values-ownership", "content": "## Ownership summary\n\nThe fundamental rules that make Mojo's ownership model work are the following:\n\n* Every value has only one owner at a time.\n* When the lifetime of the owner ends, Mojo destroys the value.\n* If there are existing references to a value, Mojo extends the lifetime of\n the owner.\n\n#", "position": 1, "token_count": 63, "has_code": false, "section_hierarchy": ["Ownership summary"], "metadata": {"chunk_id": "values-ownership-001", "document_id": "values-ownership", "position": 1, "token_count": 63, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Ownership summary"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#ownership-summary"}}
{"chunk_id": "values-ownership-002", "document_id": "values-ownership", "content": "## Variables and references\n\nA variable *owns* its value. A struct owns its fields.\n\nA *reference* allows you to access a value owned by another variable. A\nreference can have either mutable access or immutable access to that value.\n\nMojo references are created when you call a function: function arguments can be\npassed as mutable or immutable references. A function can also return a\nreference instead of returning a value. To capture a returned reference, you\ncan use a reference binding:\n\n```mojo\nref value_ref = list[0]\n```\n\n#", "position": 2, "token_count": 115, "has_code": true, "section_hierarchy": ["Ownership summary", "Variables and references"], "metadata": {"chunk_id": "values-ownership-002", "document_id": "values-ownership", "position": 2, "token_count": 115, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Ownership summary", "Variables and references"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#variables-and-references"}}
{"chunk_id": "values-ownership-003", "document_id": "values-ownership", "content": "# Argument conventions\n\nIn all programming languages, code quality and performance is heavily dependent\nupon how functions treat argument values. That is, whether a value received by\na function is a unique value or a reference, and whether it's mutable or\nimmutable, has a series of consequences that define the readability,\nperformance, and safety of the language.\n\nIn Mojo, we want to provide full [value\nsemantics](/mojo/manual/values/value-semantics) by default, which provides\nconsistent and predictable behavior. But as a systems programming language, we\nalso need to offer full control over memory optimizations, which generally\nrequires reference semantics. The trick is to introduce reference semantics in\na way that ensures all code is memory safe by tracking the lifetime of every\nvalue and destroying each one at the right time (and only once). All of this is\nmade possible in Mojo through the use of argument conventions that ensure every\nvalue has only one owner at a time.\n\nAn argument convention specifies whether an argument is mutable or immutable,\nand whether the function owns the value. Each convention is defined by a\nkeyword at the beginning of an argument declaration:", "position": 3, "token_count": 233, "has_code": false, "section_hierarchy": ["Argument conventions"], "metadata": {"chunk_id": "values-ownership-003", "document_id": "values-ownership", "position": 3, "token_count": 233, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Argument conventions"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#argument-conventions"}}
{"chunk_id": "values-ownership-004", "document_id": "values-ownership", "content": "An argument convention specifies whether an argument is mutable or immutable,\nand whether the function owns the value. Each convention is defined by a\nkeyword at the beginning of an argument declaration:\n\n* `read`: The function receives an **immutable reference**. This means the\n function can read the original value (it is *not* a copy), but it cannot\n mutate (modify) it.\n\n* `mut`: The function receives a **mutable reference**. This means the\n function can read and mutate the original value (it is *not* a copy).\n\n* `var`: The function takes **ownership** of a value. This means the function\n has exclusive ownership of the argument. The caller might choose to transfer\n ownership of an existing value to this function, but that's not always what\n happens. The callee might receive a newly-created value, or a copy of an\n existing value.", "position": 4, "token_count": 181, "has_code": false, "section_hierarchy": ["Argument conventions"], "metadata": {"chunk_id": "values-ownership-004", "document_id": "values-ownership", "position": 4, "token_count": 181, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Argument conventions"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#argument-conventions"}}
{"chunk_id": "values-ownership-005", "document_id": "values-ownership", "content": "* `ref`: The function gets a reference with a parametric mutability: that is,\n the reference can be either mutable or immutable. You can think of `ref`\n arguments as a generalization of the `read` and `mut` conventions.\n `ref` arguments are an advanced topic, and they're described in more detail in\n [Lifetimes, origins, and references](/mojo/manual/values/lifetimes).\n\n* `out`: A special convention used for the `self` argument in\n [constructors](/mojo/manual/lifecycle/life#constructor) and for\n [named results](/mojo/manual/functions#named-results). An `out`\n argument is uninitialized at the beginning of the function, and must be\n initialized before the function returns. Although `out` arguments show up in\n the argument list, they're never passed in by the caller.\n\n* `deinit`: A special convention used in the destructor and consuming-move\n lifecycle methods. A `deinit` argument is initialized at the beginning of the\n function, and uninitialized when the function returns.\n\nFor example, this function has one argument that's a mutable\nreference and one that's immutable:", "position": 5, "token_count": 243, "has_code": false, "section_hierarchy": ["Argument conventions"], "metadata": {"chunk_id": "values-ownership-005", "document_id": "values-ownership", "position": 5, "token_count": 243, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Argument conventions"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#argument-conventions"}}
{"chunk_id": "values-ownership-006", "document_id": "values-ownership", "content": "For example, this function has one argument that's a mutable\nreference and one that's immutable:\n\n```mojo\nfn add(mut x: Int, read y: Int):\n x += y\n\nfn main():\n var a = 1\n var b = 2\n add(a, b)\n print(a)\n```\n\n```output\n3\n```\n\nYou've probably already seen some function arguments that don't declare a\nconvention. By default, all arguments are `read`.\nIn the following sections, we'll explain each of these argument conventions in\nmore detail.\n\n## Immutable arguments (`read`)\n\nT", "position": 6, "token_count": 124, "has_code": true, "section_hierarchy": ["Argument conventions"], "metadata": {"chunk_id": "values-ownership-006", "document_id": "values-ownership", "position": 6, "token_count": 124, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Argument conventions"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#argument-conventions"}}
{"chunk_id": "values-ownership-007", "document_id": "values-ownership", "content": "he `read` convention is the default for all arguments. The callee receives an\nimmutable reference to the argument value.\n\nFor example:\n\n```mojo\ndef print_list(list: List[Int]):\n print(list.__str__())\n\ndef main():\n var values = [1, 2, 3, 4]\n print_list(values)\n```\n\n```output\n[1, 2, 3, 4]\n```\n\nHere the `print_list()` function can read from the `list` argument, but not\nmutate it. `list` is a reference to `values` in the `main()` function, not a\ncopy.\n\nIn general, passing an immutable reference is much more efficient\nwhen handling large or expensive-to-copy values, because the copy constructor\nand destructor are not invoked for a `read` argument.\n\n### Compared to C++ and Rust\n\nMojo's read a", "position": 7, "token_count": 182, "has_code": true, "section_hierarchy": ["Immutable arguments (`read`)"], "metadata": {"chunk_id": "values-ownership-007", "document_id": "values-ownership", "position": 7, "token_count": 182, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Immutable arguments (`read`)"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#immutable-arguments-read"}}
{"chunk_id": "values-ownership-008", "document_id": "values-ownership", "content": "rgument convention is similar in some ways to passing an\nargument by `const&` in C++, which also avoids a copy of the value and disables\nmutability in the callee. However, the read convention differs from\n`const&` in C++ in two important ways:\n\n* The Mojo compiler implements a lifetime checker that ensures that values are\n not destroyed when there are outstanding references to those values.\n\n* Small values like `Int`, `Float`, and `SIMD` are always passed in machine\n registers—instead of through an extra indirection or optimized at every call\n site—because these types are declared with the\n [`@register_passable`](/mojo/manual/decorators/register-passable) decorator.\n This is a significant performance enhancement compared to languages\n like C++ and Rust.\n\nThe major difference between Rust and Mojo is that Mojo does not require a sigil\non the caller side to pass by immutable reference. Also, Mojo is more efficient\nwhen passing small values, and Rust defaults to moving values instead of passing\nthem around by borrow. These policy and syntax decisions allow Mojo to provide\nan easier-to-use programming model.\n\n## Mutable arguments (`mut`)\n\nIf you'd like your", "position": 8, "token_count": 247, "has_code": false, "section_hierarchy": ["Immutable arguments (`read`)", "Compared to C++ and Rust"], "metadata": {"chunk_id": "values-ownership-008", "document_id": "values-ownership", "position": 8, "token_count": 247, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Immutable arguments (`read`)", "Compared to C++ and Rust"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#compared-to-c-and-rust"}}
{"chunk_id": "values-ownership-009", "document_id": "values-ownership", "content": "function to receive a **mutable reference**, add the `mut`\nkeyword in front of the argument name. You can think of `mut` like this: it\nmeans any changes to the value *in*side the function are visible *out*side the\nfunction.\n\nFor example, this `mutate()` function updates the original `list` value:\n\n```mojo\ndef print_list(list: List[Int]):\n print(list.__str__())\n\ndef mutate(mut l: List[Int]):\n l.append(5)\n\ndef main():\n var values = [1, 2, 3, 4]\n\n mutate(values)\n print_list(values)\n```\n\n```output\n[1, 2, 3, 4, 5]\n```\n\nThat behaves like an optimized replacement for this:\n\n```mojo\ndef print_list(list: List[Int]):\n print(list.__str__())\n\ndef mutate_copy(l: List[Int]) -> List[Int]:\n # def creates an implicit copy of the list because it's mutated\n l.append(5)\n return l\n\ndef main():\n var values = [1, 2, 3, 4]\n\n values = mutate_copy(values)\n print_list(values)\n```\n\n```output\n[1, 2, 3, 4, 5]\n```", "position": 9, "token_count": 260, "has_code": true, "section_hierarchy": ["Mutable arguments (`mut`)"], "metadata": {"chunk_id": "values-ownership-009", "document_id": "values-ownership", "position": 9, "token_count": 260, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Mutable arguments (`mut`)"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#mutable-arguments-mut"}}
{"chunk_id": "values-ownership-010", "document_id": "values-ownership", "content": "def main():\n var values = [1, 2, 3, 4]\n\n values = mutate_copy(values)\n print_list(values)\n```\n\n```output\n[1, 2, 3, 4, 5]\n```\n\nAlthough the code using `mut` isn't that much shorter, it's more memory\nefficient because it does not make a copy of the value.\n\nHowever, remember that the values passed as `mut` must already be mutable.\nFor example, if you try to take a `read` value and pass it to another\nfunction as `mut`, you'll get a compiler error because Mojo can't form a\nmutable reference from an immutable reference.\n\n[note]\nYou cannot define [default\nvalues](/mojo/manual/functions#optional-arguments) for `mut`\narguments.\n\n### Argument exclusivity\n\nMojo enforces *argument exclusivity* for mutable references. This", "position": 10, "token_count": 186, "has_code": true, "section_hierarchy": ["Mutable arguments (`mut`)"], "metadata": {"chunk_id": "values-ownership-010", "document_id": "values-ownership", "position": 10, "token_count": 186, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Mutable arguments (`mut`)"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#mutable-arguments-mut"}}
{"chunk_id": "values-ownership-011", "document_id": "values-ownership", "content": "means that if\na function receives a mutable reference to a value (such as an `mut` argument),\nit can't receive any other references to the same value—mutable or immutable.\nThat is, a mutable reference can't have any other references that *alias* it.\n\nFor example, consider the following code example:\n\n```mojo\nfn append_twice(mut s: String, other: String):\n # Mojo knows 's' and 'other' cannot be the same string.\n s += other\n s += other\n\nfn invalid_access():\n var my_string = \"o\" # Create a run-time String value\n\n # error: passing `my_string` mut is invalid since it is also passed\n # read.\n append_twice(my_string, my_string)\n print(my_string)\n```\n\nThis code is confusing because the user might expect the output to be `ooo`,\nbut since the first addition mutates both `s` and `other`, the actual output\nwould be `oooo`. Enforcing exclusivity of mutable references not only prevents\ncoding errors, it also allows the Mojo compiler to optimize code in some cases.", "position": 11, "token_count": 227, "has_code": true, "section_hierarchy": ["Mutable arguments (`mut`)", "Argument exclusivity"], "metadata": {"chunk_id": "values-ownership-011", "document_id": "values-ownership", "position": 11, "token_count": 227, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Mutable arguments (`mut`)", "Argument exclusivity"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#argument-exclusivity"}}
{"chunk_id": "values-ownership-012", "document_id": "values-ownership", "content": "One way to avoid this issue when you do need both a mutable and an immutable\nreference (or need to pass the same value to two arguments) is to make a copy:\n\n```mojo\nfn valid_access():\n var my_string = \"o\" # Create a run-time String value\n var other_string = my_string # Create a copy of the String value\n append_twice(my_string, other_string)\n print(my_string)\n```\n\nNote that argument exclusivity isn't enforced for register-passable trivial\ntypes (like `Int` and `Bool`), because they are always passed by copy. When\npassing the same value into two `Int` arguments, the callee will receive two\ncopies of the value.\n\n## Transfer arguments (`var` and `^`)\n\nAnd finally, if you'd like your function to receive value **ownership**, add the", "position": 12, "token_count": 175, "has_code": true, "section_hierarchy": ["Mutable arguments (`mut`)", "Argument exclusivity"], "metadata": {"chunk_id": "values-ownership-012", "document_id": "values-ownership", "position": 12, "token_count": 175, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Mutable arguments (`mut`)", "Argument exclusivity"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#argument-exclusivity"}}
{"chunk_id": "values-ownership-013", "document_id": "values-ownership", "content": "`var` keyword in front of the argument name.\n\nThis convention is often combined with use of the postfixed `^` \"transfer\"\nsigil on the variable that is passed into the function, which ends the\nlifetime of that variable.\n\nTechnically, the `var` keyword does not guarantee that the received value is\n*the original value*—it guarantees only that the function\ngets unique ownership of a value. This happens in one of\nthree ways:\n\n* The caller passes the argument with the `^` transfer sigil, which ends the\n lifetime of that variable (the variable becomes uninitialized) and ownership\n is transferred into the function.\n\n* The caller **does not** use the `^` transfer sigil, in which case, Mojo copies\n the value. If the type isn't copyable, this is a compile-time error.\n\n* The caller passes in a newly-created \"owned\" value, such as a value returned\n from a function. In this case, no variable owns the value and it can be\n transferred directly to the callee. For example:\n\n ```mojo\n def take(var s: String):\n pass\n\n def main():\n take(\"A brand-new String!\")\n ```", "position": 13, "token_count": 244, "has_code": true, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "metadata": {"chunk_id": "values-ownership-013", "document_id": "values-ownership", "position": 13, "token_count": 244, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#transfer-arguments-var-and-"}}
{"chunk_id": "values-ownership-014", "document_id": "values-ownership", "content": " ```mojo\n def take(var s: String):\n pass\n\n def main():\n take(\"A brand-new String!\")\n ```\n\nThe following code works by making a copy of the string, because `take_text()`\nuses the `var` convention, and the caller does not include the transfer sigil:\n\n```mojo\nfn take_text(var text: String):\n text += \"!\"\n print(text)\n\nfn main():\n var message = \"Hello\" # Create a run-time String value\n take_text(message)\n print(message)\n```\n\n```output\nHello!\nHello\n```\n\nHowever, if you add the `^` transfer sigil when calling `take_text()`, the\ncompiler complains about `print(message)`, because at that point, the `message`\nvariable is no longer initialized. That is, this version does not compile:\n\n```mojo\nfn main():\n var message = \"Hello\" # Create a run-time String value\n take_text(message^)\n print(message) # error: use of uninitialized value 'message'\n```", "position": 14, "token_count": 208, "has_code": true, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "metadata": {"chunk_id": "values-ownership-014", "document_id": "values-ownership", "position": 14, "token_count": 208, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#transfer-arguments-var-and-"}}
{"chunk_id": "values-ownership-015", "document_id": "values-ownership", "content": "```mojo\nfn main():\n var message = \"Hello\" # Create a run-time String value\n take_text(message^)\n print(message) # error: use of uninitialized value 'message'\n```\n\nThis is a critical feature of Mojo's lifetime checker, because it ensures that no\ntwo variables can have ownership of the same value. To fix the error, you must\nnot use the `message` variable after you end its lifetime with the `^` transfer\nsigil. So here is the corrected code:\n\n```mojo\nfn take_text(var text: String):\n text += \"!\"\n print(text)\n\nfn main():\n var message = \"Hello\" # Create a run-time String value\n take_text(message^)\n```\n\n```output\nHello!\n```\n\nRegardless of how it receives the value, when the function declares an argument\nas `var`, it can be certain that it has unique mutable access to that value.\nBecause the value is owned, the value is destroyed when the function\nexits—unless the function transfers the value elsewhere.", "position": 15, "token_count": 213, "has_code": true, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "metadata": {"chunk_id": "values-ownership-015", "document_id": "values-ownership", "position": 15, "token_count": 213, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#transfer-arguments-var-and-"}}
{"chunk_id": "values-ownership-016", "document_id": "values-ownership", "content": "For example, in the following example, `add_to_list()` takes a string and\nappends it to the list. Ownership of the string is transferred to the list, so\nit's not destroyed when the function exits. On the other hand,\n`consume_string()` doesn't transfer its `var` value out, so the value is\ndestroyed at the end of the function.\n\n```mojo\ndef add_to_list(var name: String, mut list: List[String]):\n list.append(name^)\n # name is uninitialized, nothing to destroy\n\ndef consume_string(var s: String):\n print(s)\n # s is destroyed here\n```\n\n### Transfer implementation details\n\nIn Mojo, you shouldn't conflate \"ownership transfer\" with a \"move\noperation\"—these are not strictly the same thing.\n\nThere are multiple ways that Mojo ca", "position": 16, "token_count": 170, "has_code": true, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "metadata": {"chunk_id": "values-ownership-016", "document_id": "values-ownership", "position": 16, "token_count": 170, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Transfer arguments (`var` and `^`)"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#transfer-arguments-var-and-"}}
{"chunk_id": "values-ownership-017", "document_id": "values-ownership", "content": "n transfer ownership of a value:\n\n* If a type implements the [move\n constructor](/mojo/manual/lifecycle/life#move-constructor),\n `__moveinit__()`, Mojo may invoke this method *if* a value of that type is\n transferred into a function as a `var` argument, *and* the original\n variable's lifetime ends at the same point (with or without use of the `^`\n transfer sigil).\n\n* If a type implements the [copy\n constructor](/mojo/manual/lifecycle/life#move-constructor), `__copyinit__()`\n and not `__moveinit__()`, Mojo may copy the value and destroy the old value.\n\n* In some cases, Mojo can optimize away the move operation entirely, leaving the\n value in the same memory location but updating its ownership. In these cases,\n a value can be transferred without invoking either the `__copyinit__()` or\n `__moveinit__()` constructors.\n\nIn order for the `var` convention to work *without* the transfer\nsigil, the value type must be copyable (via `__copyinit__()`).", "position": 17, "token_count": 232, "has_code": false, "section_hierarchy": ["Transfer arguments (`var` and `^`)", "Transfer implementation details"], "metadata": {"chunk_id": "values-ownership-017", "document_id": "values-ownership", "position": 17, "token_count": 232, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Transfer arguments (`var` and `^`)", "Transfer implementation details"], "file_path": "values/ownership.mdx", "url": "https://docs.modular.com/mojo/manual/values/ownership", "title": "Ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/ownership#transfer-implementation-details"}}

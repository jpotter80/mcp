{"chunk_id": "basics-000", "document_id": "basics", "content": "This page provides an overview of the Mojo language.\n\nIf you know Python, then a lot of Mojo code will look familiar. However, Mojo\nincorporates features like static type checking, memory safety, next-generation\ncompiler technologies, and more. As such, Mojo also has a lot in common with\nlanguages like C++ and Rust.\n\nIf you prefer to learn by doing, follow the [Get started with\nMojo](/mojo/manual/get-started) tutorial.\n\nOn this page, we'll introduce the essential Mojo syntax, so you can start\ncoding quickly and understand other Mojo code you encounter. Subsequent\nsections in the Mojo Manual dive deeper into these topics, and links are\nprovided below as appropriate.\n\nLet's get started! ðŸ”¥\n\n[note]\nMojo is a young language and there are many [features still\nmissing](/mojo/roadmap). As such, Mojo is currently **not** meant for\nbeginners. Even this basics section assumes some programming experience.\nHowever, throughout the Mojo Manual, we try not to assume experience with any\nparticular language.\n\n## Hell", "position": 0, "token_count": 227, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "basics-000", "document_id": "basics", "position": 0, "token_count": 227, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics"}}
{"chunk_id": "basics-001", "document_id": "basics", "content": "o world\n\nHere's the traditional \"Hello world\" program in Mojo:\n\n```mojo\ndef main():\n print(\"Hello, world!\")\n```\n\nEvery Mojo program must include a function named `main()` as the entry point.\nWe'll talk more about functions soon, but for now it's enough to know that\nyou can write `def main():` followed by an indented function body.\n\nThe `print()` statement does what you'd expect, printing its arguments to\nthe standard output.\n\n## Variabl", "position": 1, "token_count": 103, "has_code": true, "section_hierarchy": ["Hello world"], "metadata": {"chunk_id": "basics-001", "document_id": "basics", "position": 1, "token_count": 103, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Hello world"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#hello-world"}}
{"chunk_id": "basics-002", "document_id": "basics", "content": "es\n\nIn Mojo, you can declare a variable by simply assigning a value to\na new named variable:\n\n```mojo\ndef main():\n x = 10\n y = x * x\n print(y)\n```\n\nYou can also _explicitly_ declare variables with the `var` keyword:\n\n```mojo\nvar x = 10\n```\n\nWhen declaring a variable with `var`, you can also declare a variable type, with\nor without an assignment:\n\n```mojo\ndef main():\n var x: Int = 10\n var sum: Int\n sum = x + x\n```\n\nBoth implicitly declared and explicitly declared variables are statically typed:\nthat is, the type is set at compile time, and doesn't change at runtime.\nIf you don't specify a type, Mojo uses the type of the first value assigned to\nthe variable.\n\n```mojo\nx = 10\nx = \"Foo\" # Error: Cannot convert \"StringLiteral\" value to \"Int\"\n```\n\nFor more details, see the page about\n[variables](/mojo/manual/variables).\n\n## Blocks and statements\n\nCod", "position": 2, "token_count": 230, "has_code": true, "section_hierarchy": ["Variables"], "metadata": {"chunk_id": "basics-002", "document_id": "basics", "position": 2, "token_count": 230, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Variables"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#variables"}}
{"chunk_id": "basics-003", "document_id": "basics", "content": "e blocks such as functions, conditions, and loops are defined\nwith a colon followed by indented lines. For example:\n\n```mojo\ndef loop():\n for x in range(5):\n if x % 2 == 0:\n print(x)\n```\n\nYou can use any number of spaces or tabs for your indentation (we prefer 4\nspaces).\n\nAll code statements in Mojo end with a newline. However, statements can span\nmultiple lines if you indent the following lines. For example, this long string\nspans two lines:\n\n```mojo\ndef print_line():\n long_text = \"This is a long line of text that is a lot easier to read if\"\n \" it is broken up across two lines instead of one long line.\"\n print(long_text)\n```\n\nAnd you can chain function calls across lines:\n\n```mojo\ndef print_hello():\n text = \",\".join(\"Hello\", \" world!\")\n print(text)\n```\n\nFor more information on loops and conditional statements, see\n[Control flow](/mojo/manual/control-flow).\n\n## Functions\n\nYou can define a Mojo function using either the `def` or `fn` k", "position": 3, "token_count": 233, "has_code": true, "section_hierarchy": ["Blocks and statements"], "metadata": {"chunk_id": "basics-003", "document_id": "basics", "position": 3, "token_count": 233, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Blocks and statements"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#blocks-and-statements"}}
{"chunk_id": "basics-004", "document_id": "basics", "content": "eyword. For\nexample, the following uses the `def` keyword to define a function named\n`greet` that requires a single `String` argument and returns a `String`:\n\n```mojo\ndef greet(name: String) -> String:\n return \"Hello, \" + name + \"!\"\n```\n\nWhere `def` and `fn` differ is error handling and argument mutability defaults.\nRefer to the [Functions](/mojo/manual/functions) page for more details on\ndefining and calling functions.\n\n## Code comments\n\nYou can create a one-line comment using the hash `#` symbol:", "position": 4, "token_count": 126, "has_code": true, "section_hierarchy": ["Functions"], "metadata": {"chunk_id": "basics-004", "document_id": "basics", "position": 4, "token_count": 126, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Functions"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#functions"}}
{"chunk_id": "basics-005", "document_id": "basics", "content": "```mojo\n# This is a comment. The Mojo compiler ignores this line.\n```\n\nComments may also", "position": 5, "token_count": 22, "has_code": true, "section_hierarchy": ["Code comments"], "metadata": {"chunk_id": "basics-005", "document_id": "basics", "position": 5, "token_count": 22, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Code comments"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#code-comments"}}
{"chunk_id": "basics-006", "document_id": "basics", "content": "follow some code:\n\n```mojo\nvar message = \"Hello, World!\" # This is also a valid comment\n```\n\nAPI documentation comments are enclosed in triple quotes. For example:\n\n```mojo\nfn print(x: String):\n \"\"\"Prints a string.\n\n Args:\n x: The string to print.\n \"\"\"\n ...\n```\n\nDocumenting your code with these kinds of comments (known as \"docstrings\")\nis a topic we've yet to fully specify, but you can generate an API reference\nfrom docstrings using the [`mojo doc` command](/mojo/cli/doc).\n\n[note]\nTechnically, docstrings aren't _comments_, they're a special use of Mojo's\nsyntax for multi-line string literals. For details, see\n[String literals](/mojo/manual/types#string-literals) in the page on\n[Types](/mojo/manual/types).\n\n## Structs\n\nYou can build high-level abstractions for types (or \"objects\") as a `struct`.\n\nA `struct` in M", "position": 6, "token_count": 209, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line."], "metadata": {"chunk_id": "basics-006", "document_id": "basics", "position": 6, "token_count": 209, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line."], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#this-is-a-comment-the-mojo-compiler-ignores-this-line"}}
{"chunk_id": "basics-007", "document_id": "basics", "content": "ojo is similar to a `class` in Python: they both support\nmethods, fields, operator overloading, decorators for metaprogramming, and so\non. However, Mojo structs are completely staticâ€”they are bound at compile-time,\nso they do not allow dynamic dispatch or any runtime changes to the structure.\n(Mojo will also support Python-style classes in the future.)\n\nFor example, here's a basic struct:\n\n```mojo\nstruct MyPair(Copyable):\n var first: Int\n var second: Int\n\n fn __init__(out self, first: Int, second: Int):\n self.first = first\n self.second = second\n\n fn __copyinit__(out self, existing: Self):\n self.first = existing.first\n self.second = existing.second\n\n def dump(self):\n print(self.first, self.second)\n```\n\nAnd here's how you can use it:\n\n```mojo\ndef use_mypair():\n var mine = MyPair(2, 4)\n mine.dump()\n```\n\nNote that some functions are declared with `fn` function, while the `dump()`\nfunction is declared with `def`. In general, you can use either form in a\nstruct.", "position": 7, "token_count": 243, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs"], "metadata": {"chunk_id": "basics-007", "document_id": "basics", "position": 7, "token_count": 243, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#structs"}}
{"chunk_id": "basics-008", "document_id": "basics", "content": "Note that some functions are declared with `fn` function, while the `dump()`\nfunction is declared with `def`. In general, you can use either form in a\nstruct.\n\nThe `MyPair` struct contains two special methods, `__init__()`, the constructor,\nand `__copyinit__()`, the copy constructor. _Lifecycle methods_ like this\ncontrol how a struct is created, copied, moved, and destroyed.\n\nFor most simple types, you don't need to write the lifecycle methods. You can\nuse the `@fieldwise_init` decorator to generate the boilerplate field-wise\ninitializer for you, and Mojo will synthesize copy and move constructors if you\nask for them with trait conformance. So the\n`MyPair` struct can be simplified to this:\n\n```mojo\n@fieldwise_init\nstruct MyPair(Copyable, Movable):\n var first: Int\n var second: Int\n\n def dump(self):\n print(self.first, self.second)\n```\n\nFor more details, see the page about\n[structs](/mojo/manual/structs).\n\n### Traits", "position": 8, "token_count": 227, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs"], "metadata": {"chunk_id": "basics-008", "document_id": "basics", "position": 8, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#structs"}}
{"chunk_id": "basics-009", "document_id": "basics", "content": "teristic (such as each method). Each characteristic in a trait is a\n\"requirement\" for the struct, and when your struct implements all of the\nrequirements, it's said to \"conform\" to the trait.\n\nUsing traits allows you to write generic functions that can accept any type\nthat conforms to a trait, rather than accept only specific types.\n\nFor example, here's how you can create a trait:\n\n```mojo\ntrait SomeTrait:\n fn required_method(self, x: Int): ...\n```\n\nThe three dots following the method signature are Mojo syntax indicating that\nthe method is not implemented.\n\nHere's a struct that conforms to `SomeTrait`:\n\n```mojo\n@fieldwise_init\nstruct SomeStruct(SomeTrait):\n fn required_method(self, x: Int):\n print(\"hello traits\", x)\n```\n\nThen, here's a function that uses the trait as an argument type (instead of the\nstruct type):\n\n```mojo\nfn fun_with_traits[T: SomeTrait](x: T):\n x.required_method(42)\n\nfn use_trait_function():\n var thing = SomeStruct()\n fun_with_traits(thing)\n```", "position": 9, "token_count": 232, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs", "Traits"], "metadata": {"chunk_id": "basics-009", "document_id": "basics", "position": 9, "token_count": 232, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs", "Traits"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#traits"}}
{"chunk_id": "basics-010", "document_id": "basics", "content": "```mojo\nfn fun_with_traits[T: SomeTrait](x: T):\n x.required_method(42)\n\nfn use_trait_function():\n var thing = SomeStruct()\n fun_with_traits(thing)\n```\n\nYou'll see traits used in a lot of APIs provided by Mojo's standard library. For\nexample, Mojo's collection types like `List` and `Dict` can store any type that\nconforms to the `Copyable` and `Movable` traits. You can specify the type when\nyou create a collection:\n\n```mojo\nmy_list = List[Float64]()\n```\n\n[note]\nYou're probably wondering about the square brackets on `fun_with_traits()`.\nThese aren't function *arguments* (which go in parentheses); these are function\n*parameters*, which we'll explain next.", "position": 10, "token_count": 165, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs", "Traits"], "metadata": {"chunk_id": "basics-010", "document_id": "basics", "position": 10, "token_count": 165, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs", "Traits"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#traits"}}
{"chunk_id": "basics-011", "document_id": "basics", "content": "[note]\nYou're probably wondering about the square brackets on `fun_with_traits()`.\nThese aren't function *arguments* (which go in parentheses); these are function\n*parameters*, which we'll explain next.\n\nWithout traits, the `x` argument in `fun_with_traits()` would have to declare a\nspecific type that implements `required_method()`, such as `SomeStruct`\n(but then the function would accept only that type). With traits, the function\ncan accept any type for `x` as long as it conforms to (it \"implements\")\n`SomeTrait`. Thus, `fun_with_traits()` is known as a \"generic function\" because\nit accepts a *generalized* type instead of a specific type.\n\nFor more details, see the page about [traits](/mojo/manual/traits).\n\n## Parameterization\n\nIn Mojo, a parameter is a compile-time variable that becomes a runtime\nconstant, and it's declared in square brackets on a function or struct.\nParameters allow for compile-time metaprogr", "position": 11, "token_count": 210, "has_code": false, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs", "Traits"], "metadata": {"chunk_id": "basics-011", "document_id": "basics", "position": 11, "token_count": 210, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Structs", "Traits"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#traits"}}
{"chunk_id": "basics-012", "document_id": "basics", "content": "amming, which means you can generate\nor modify code at compile time.\n\nMany other languages use \"parameter\" and \"argument\" interchangeably, so be\naware that when we say things like \"parameter\" and \"parametric function,\" we're\ntalking about these compile-time parameters. Whereas, a function \"argument\" is\na runtime value that's declared in parentheses.\n\nParameterization is a complex topic that's covered in much more detail in the\n[Metaprogramming](/mojo/manual/parameters/) section, but we want to break the\nice just a little bit here. To get you started, let's look at a parametric\nfunction:\n\n```mojo\ndef repeat[count: Int](msg: String):\n @parameter # evaluate the following for loop at compile time\n for i in range(count):\n print(msg)\n```\n\nThis function has one parameter of type `Int` and one argument of type\n`String`. To call the function, you need to specify both the parameter and the\nargument:\n\n```mojo\ndef call_repeat():\n repeat[3](\"Hello\")\n # Prints \"Hello\" 3 times\n```", "position": 12, "token_count": 235, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Parameterization"], "metadata": {"chunk_id": "basics-012", "document_id": "basics", "position": 12, "token_count": 235, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Parameterization"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#parameterization"}}
{"chunk_id": "basics-013", "document_id": "basics", "content": "```mojo\ndef call_repeat():\n repeat[3](\"Hello\")\n # Prints \"Hello\" 3 times\n```\n\nBy specifying `count` as a parameter, the Mojo compiler is able to optimize the\nfunction because this value is guaranteed to not change at runtime. And the\n`@parameter` decorator in the code tells the compiler to evaluate the `for` loop\nat compile time, not runtime.\n\nThe compiler effectively generates a unique version of the `repeat()` function\nthat repeats the message only 3 times. This makes the code more performant\nbecause there's less to compute at runtime.\n\nSimilarly, you can define a struct with parameters, which effectively allows\nyou to define variants of that type at compile-time, depending on the parameter\nvalues.\n\nFor more detail on parameters, see the section on\n[Metaprogramming](/mojo/manual/parameters/).\n\n## Python integration\n\nMojo supports the ability to import Python modules as-is, so you can leverage existing Python code right away.\n\nFor example, here's how you can import and use NumPy:\n\n```mojo\nfrom python import Python\n\nd", "position": 13, "token_count": 231, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Parameterization"], "metadata": {"chunk_id": "basics-013", "document_id": "basics", "position": 13, "token_count": 231, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Parameterization"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#parameterization"}}
{"chunk_id": "basics-014", "document_id": "basics", "content": "ef main():\n var np = Python.import_module(\"numpy\")\n var ar = np.arange(15).reshape(3, 5)\n print(ar)\n print(ar.shape)\n```\n\nYou must have the Python module (such as `numpy`) installed in the environment\nwhere you're using Mojo.\n\nFor more details, see the page on\n[Python integration](/mojo/manual/python/).\n\n## Next steps\n\nHopefully this page has given you enough information to start experimenting with\nMojo, but this is only touching the surface of what's available in Mojo.\n\nIf you're in the mood to read more, continue through each page of th", "position": 14, "token_count": 129, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Python integration"], "metadata": {"chunk_id": "basics-014", "document_id": "basics", "position": 14, "token_count": 129, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Python integration"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#python-integration"}}
{"chunk_id": "basics-015", "document_id": "basics", "content": "is\nMojo Manualâ€”the next page from here is [Functions](/mojo/manual/functions).\n\nOtherwise, here are some other resources to check out:\n\n* See [Get started with Mojo](/mojo/manual/get-started) for a hands-on\n tutorial that will get you up and running with Mojo.\n\n* If you want to experiment with some code, clone [our GitHub\n repo](https://github.com/modular/modular/) to try our code examples:\n\n ```sh\n git clone https://github.com/modular/modular.git\n ```\n\n ```sh\n cd max/examples/mojo\n ```\n\n* To see all the available Mojo APIs, check out the [Mojo standard library\n reference](/mojo/lib).", "position": 15, "token_count": 149, "has_code": true, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Next steps"], "metadata": {"chunk_id": "basics-015", "document_id": "basics", "position": 15, "token_count": 149, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This is a comment. The Mojo compiler ignores this line.", "Next steps"], "file_path": "basics.mdx", "url": "https://docs.modular.com/mojo/manual/basics", "title": "Mojo language basics", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/basics#next-steps"}}

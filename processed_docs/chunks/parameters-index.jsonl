{"chunk_id": "parameters-index-000", "document_id": "parameters-index", "content": "Many languages have facilities for *metaprogramming*: that is, for writing code that\ngenerates or modifies code. Python has facilities for dynamic metaprogramming: features\nlike decorators, metaclasses, and many more. These features make Python very flexible\nand productive, but since they're dynamic, they come with runtime overhead. Other\nlanguages have static or compile-time metaprogramming features, like C preprocessor\nmacros and C++ templates. These can be limiting and hard to use.\n\nTo support Modular's work in AI, Mojo aims to provide powerful, easy-to-use\nmetaprogramming with zero runtime cost. This compile-time metaprogramming uses the same\nlanguage as runtime programs, so you don't have to learn a new languageâ€”just a few new\nfeatures.", "position": 0, "token_count": 178, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-000", "document_id": "parameters-index", "position": 0, "token_count": 178, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-001", "document_id": "parameters-index", "content": "The main new feature is *parameters*. You can think of a parameter as a\ncompile-time variable that becomes a runtime constant. This usage of \"parameter\"\nis probably different from what you're used to from other languages, where\n\"parameter\" and \"argument\" are often used interchangeably. In Mojo, \"parameter\"\nand \"parameter expression\" refer to compile-time values, and \"argument\" and\n\"expression\" refer to runtime values.\n\nIn Mojo, you can add parameters to a struct or function. You can also define\nnamed parameter expressionsâ€”aliasesâ€”that you can use as runtime constants.", "position": 1, "token_count": 134, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-001", "document_id": "parameters-index", "position": 1, "token_count": 134, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-002", "document_id": "parameters-index", "content": "## Parameterized functions\n\nTo define a *parameterized function*, add parameters in square brackets ahead\nof the argument list. Each parameter is formatted just like an argument: a\nparameter name, followed by a colon and a type (which is required). In the\nfollowing example, the function has a single parameter, `count` of type `Int`.\n\n```mojo\nfn repeat[count: Int](msg: String):\n @parameter\n for i in range(count):\n print(msg)\n```\n\nThe [`@parameter`](/mojo/manual/decorators/parameter) decorator shown here\ncauses the `for` loop to be evaluated at compile time. The decorator only works\nif the loop limits are compile-time constants. Since `count` is a parameter,\n`range(count)` can be calculated at compile time.\n\nCalling a parameterized function, you provide values for the parameters, just\nlike function arguments:\n\n```mojo\nrepeat[3](\"Hello\")\n```\n\n```output\nHello\nHello\nHello", "position": 2, "token_count": 228, "has_code": true, "section_hierarchy": ["Parameterized functions"], "metadata": {"chunk_id": "parameters-index-002", "document_id": "parameters-index", "position": 2, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parameterized functions"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#parameterized-functions"}}
{"chunk_id": "parameters-index-003", "document_id": "parameters-index", "content": "```\n\n```output\nHello\nHello\nHello\n```\n\nThe compiler resolves the parameter values during compilation, and creates a\nconcrete version of the `repeat[]()` function for each unique parameter value.\nAfter resolving the parameter values and unrolling the loop, the `repeat[3]()`\nfunction would be roughly equivalent to this:\n\n```mojo\nfn repeat_3(msg: String):\n print(msg)\n print(msg)\n print(msg)\n```\n\n[note]\nThis doesn't represent actual code generated by the compiler. By the\ntime parameters are resolved, Mojo code has already been transformed to an\nintermediate representation in [MLIR](https://mlir.llvm.org/).\n\nIf the compiler can't resolve all parameter values to constant values,\ncompilation fails.", "position": 3, "token_count": 179, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-003", "document_id": "parameters-index", "position": 3, "token_count": 179, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-004", "document_id": "parameters-index", "content": "## Anatomy of a parameter list\n\nParameters to a function or struct appear in square brackets after a function\nor struct name. Parameters always require type annotations.\n\nWhen you're looking at a function or struct definition, you may\nsee some special characters such as `/` and `*` in the parameter list.\nHere's an example:\n\n```mojo\ndef my_sort[\n # infer-only parameters\n dtype: DType,\n width: Int,\n //,\n # positional-only parameter\n values: SIMD[dtype, width],\n /,\n # positional-or-keyword parameter\n compare: fn (Scalar[dtype], Scalar[dtype]) -> Int,\n *,\n # keyword-only parameter\n reverse: Bool = False,\n]() -> SIMD[dtype, width]:", "position": 4, "token_count": 186, "has_code": true, "section_hierarchy": ["Anatomy of a parameter list"], "metadata": {"chunk_id": "parameters-index-004", "document_id": "parameters-index", "position": 4, "token_count": 186, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Anatomy of a parameter list"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#anatomy-of-a-parameter-list"}}
{"chunk_id": "parameters-index-005", "document_id": "parameters-index", "content": "```\n\nHere's a quick overview of the special characters in the parameter list:\n\n- Double slash (`//`): parameters declared before the double slash are\n [infer-only parameters](#infer-only-parameters).\n- Slash (`/`): parameters declared before a slash are positional-only parameters. Positional-only\n and keyword-only parameters follow the same rules as\n [positional-only and keyword-only\n arguments](/mojo/manual/functions#positional-only-and-keyword-only-arguments).\n- A parameter name prefixed with a star, like `*Types` identifies a\n [variadic parameter](#variadic-parameters) (not shown in the example above).\n Any parameters following the variadic parameter are keyword-only.\n- Star (`*`): in a parameter list with no variadic parameter, a star by itself\n indicates that the following parameters are keyword-only parameters.\n- An equals sign (`=`) introduces a default value for an\n [optional parameter](#optional-parameters-and-keyword-parameters).", "position": 5, "token_count": 246, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-005", "document_id": "parameters-index", "position": 5, "token_count": 246, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-006", "document_id": "parameters-index", "content": "## Parameters and generics\n\n\"Generics\" refers to functions that can act on multiple types of values, or\ncontainers that can hold multiple types of values. For example,\n[`List`](/mojo/stdlib/collections/list/List), can hold\ndifferent types of values, so you can have a list of `Int` values, or\na list of `String` values).\n\nIn Mojo, generics use parameters to specify types. For example, `List`\ntakes a type parameter, so a vector of integers is written `List[Int]`.\nSo all generics use parameters, but **not** everything that uses parameters is a\ngeneric.", "position": 6, "token_count": 143, "has_code": false, "section_hierarchy": ["Parameters and generics"], "metadata": {"chunk_id": "parameters-index-006", "document_id": "parameters-index", "position": 6, "token_count": 143, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Parameters and generics"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#parameters-and-generics"}}
{"chunk_id": "parameters-index-007", "document_id": "parameters-index", "content": "For example, the `repeat[]()` function in the previous section includes\nparameter of type `Int`, and an argument of type `String`. It's parameterized,\nbut not generic. A generic function or struct is parameterized on *type*. For\nexample, we could rewrite `repeat[]()` to take any type of argument that\nconforms to the [`Stringable`](/mojo/stdlib/builtin/str/Stringable) trait:\n\n```mojo\nfn repeat[MsgType: Stringable, //, count: Int](msg: MsgType):\n @parameter\n for i in range(count):\n print(String(msg))\n\ndef main():\n # MsgType is always inferred, so first positional keyword `2` is\n # passed to `count`\n repeat[2](42)", "position": 7, "token_count": 197, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-007", "document_id": "parameters-index", "position": 7, "token_count": 197, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-008", "document_id": "parameters-index", "content": "```\n\n```output\n42\n42\n```\n\nThis updated function takes any `Stringable` type, so you can pass it an `Int`,\n`String`, or `Bool` value.\n\nNote that there's a double-slash (`//`) in the parameter list after `MsgType`,\nto specify that it's an [infer-only parameter](#infer-only-parameters), so you\ndon't need to specify it explicitly. Instead, the compiler sees that the `msg`\nargument is an `Int` and *infers* the type from the value.\n\nMojo's support for generics is still early. You can write generic functions like\nthis using traits and parameters. You can also write generic collections like\n`List` and `Dict`. If you're interested in learning how these types work, you\ncan find the source code for the standard library collection types\n[on GitHub](https://github.com/modular/modular/blob/main/mojo/stdlib/stdlib/collections/).", "position": 8, "token_count": 239, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-008", "document_id": "parameters-index", "position": 8, "token_count": 239, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-009", "document_id": "parameters-index", "content": "## Parameterized structs\n\nYou can also add parameters to structs. You can use parameterized structs to\nbuild generic collections. For example, a generic array type might include code\nlike this:\n\n```mojo\nstruct GenericArray[ElementType: Copyable & Movable]:\n var data: UnsafePointer[ElementType]\n var size: Int\n\n fn __init__(out self, var *elements: ElementType):\n self.size = len(elements)\n self.data = UnsafePointer[ElementType].alloc(self.size)\n for i in range(self.size):\n (self.data + i).init_pointee_move(elements[i].copy())\n\n fn __del__(deinit self):\n for i in range(self.size):\n (self.data + i).destroy_pointee()\n self.data.free()", "position": 9, "token_count": 207, "has_code": true, "section_hierarchy": ["Parameterized structs"], "metadata": {"chunk_id": "parameters-index-009", "document_id": "parameters-index", "position": 9, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parameterized structs"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#parameterized-structs"}}
{"chunk_id": "parameters-index-010", "document_id": "parameters-index", "content": "fn __del__(deinit self):\n for i in range(self.size):\n (self.data + i).destroy_pointee()\n self.data.free()\n\n fn __getitem__(self, i: Int) raises -> ref [self] ElementType:\n if i < self.size:\n return self.data[i]\n else:\n raise Error(\"Out of bounds\")", "position": 10, "token_count": 98, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-010", "document_id": "parameters-index", "position": 10, "token_count": 98, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-011", "document_id": "parameters-index", "content": "```\n\nThis struct has a single parameter, `ElementType`, which is a placeholder for\nthe data type you want to store in the array, sometimes called a *type\nparameter*. `ElementType` conforms to the\n[`Copyable`](/mojo/stdlib/builtin/value/Copyable) and\n[`Movable`](/mojo/stdlib/builtin/value/Movable) traits.\n\nAs with parameterized functions, you need to pass in parameter values when you\nuse a parameterized struct. In this case, when you create an instance of\n`GenericArray`, you need to specify the type you want to store, like `Int`, or\n`Float64`. (This is a little confusing, because the *parameter value* you're\npassing in this case is a *type*. That's OK: a Mojo type is a valid compile-time\nvalue.)", "position": 11, "token_count": 204, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-011", "document_id": "parameters-index", "position": 11, "token_count": 204, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-012", "document_id": "parameters-index", "content": "You'll see that `ElementType` is used throughout the struct where you'd usually\nsee a type name. For example, as the formal type for the `elements` in the\nconstructor, and the return type of the `__getitem__()` method.\n\nHere's an example of using `GenericArray`:\n\n```mojo\nvar array = GenericArray(1, 2, 3, 4)\nfor i in range(array.size):\n end = \", \" if i < array.size - 1 else \"\\n\"\n print(array[i], end=end)", "position": 12, "token_count": 135, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-012", "document_id": "parameters-index", "position": 12, "token_count": 135, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-013", "document_id": "parameters-index", "content": "```\n\n```output\n1, 2, 3, 4\n```\n\nA parameterized struct can use the `Self` type to represent a concrete instance\nof the struct (that is, with all its parameters specified). For example, you\ncould add a static factory method to `GenericArray` with the following\nsignature:\n\n```mojo\nstruct GenericArray[ElementType: Copyable & Movable]:\n ...\n\n @staticmethod\n fn splat(count: Int, value: ElementType) -> Self:\n # Create a new array with count instances of the given value\n```\n\nHere, `Self` is equivalent to writing `GenericArray[ElementType]`. That is, you\ncan call the `splat()` method like this:\n\n```mojo\nGenericArray[Float64].splat(8, 0)\n```\n\nThe method returns an instance of `GenericArray[Float64]`.", "position": 13, "token_count": 210, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-013", "document_id": "parameters-index", "position": 13, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-014", "document_id": "parameters-index", "content": "### Conditional conformance\n\nWhen creating a generic struct, you might want to define some methods that\nrequire extra features. For example, consider a collection like `GenericArray`\nthat holds instances of a type that conforms to the\n[`Copyable`](/mojo/stdlib/builtin/value/Copyable) and\n[`Movable`](/mojo/stdlib/builtin/value/Movable) traits. This imposes a lot\nof limitations: you can't implement a `sort()` method because you can't\nguarantee that the stored type supports the comparison operators; you can't\nwrite a useful `__str__()` or `__repr__()` dunder method because you can't\nguarantee that the stored type supports conversion to a string.\n\nThe answer to these issues is *conditional conformance*, which lets you define a\nmethod that requires additional features. You do this by defining the `self`\nvalue that has a more specific bound on one or more of its parameters.", "position": 14, "token_count": 227, "has_code": false, "section_hierarchy": ["Conditional conformance"], "metadata": {"chunk_id": "parameters-index-014", "document_id": "parameters-index", "position": 14, "token_count": 227, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Conditional conformance"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#conditional-conformance"}}
{"chunk_id": "parameters-index-015", "document_id": "parameters-index", "content": "The answer to these issues is *conditional conformance*, which lets you define a\nmethod that requires additional features. You do this by defining the `self`\nvalue that has a more specific bound on one or more of its parameters.\n\nFor example, the following code defines a `Container` type that holds an\ninstance of a type conforming to `Movable`. It also defines a\n`__str__()` method that can only be called if the stored `ElementType` conforms\nto `Writable` as well as `Movable`:\n\n```mojo\n@fieldwise_init\nstruct Container[ElementType: Movable]:\n var element: ElementType\n\n def __str__[\n StrElementType: Writable & Movable, //\n ](self: Container[StrElementType]) -> String:\n return String(self.element)", "position": 15, "token_count": 189, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-015", "document_id": "parameters-index", "position": 15, "token_count": 189, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-016", "document_id": "parameters-index", "content": "def __str__[\n StrElementType: Writable & Movable, //\n ](self: Container[StrElementType]) -> String:\n return String(self.element)\n\ndef main():\n float_container = Container(5.0)\n string_container = Container(\"Hello\")\n print(float_container.__str__())\n print(string_container.__str__())", "position": 16, "token_count": 101, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-016", "document_id": "parameters-index", "position": 16, "token_count": 101, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-017", "document_id": "parameters-index", "content": "```\n\n```output\n5.0\nHello\n```\n\nNote the signature of the `__str__()` method, which declares the `self` argument\nwith a more specific type. Specifically, it declares that it takes a `Container`\nwith an `ElementType` that conforms to the `Writable` and `Movable`\ntraits.\n\n```mojo\ndef __str__[StrElementType: Writable & Movable, //](\n self: Container[StrElementType]) -> String:", "position": 17, "token_count": 120, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-017", "document_id": "parameters-index", "position": 17, "token_count": 120, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-018", "document_id": "parameters-index", "content": "```\n\nThe trait bound on `StrElementType` must include `ElementType`'s original trait\n(`Movable` in this case), either by composition or by inheritance. The trait\ncomposition `Writable & Movable` includes the original trait. You could also use\na trait that inherits from `Movable`.\n\nNote that the `main()` function calls the `__str__()` method directly,\nrather than calling `String(float_container)`. One current limitation of\nconditional conformance is that Mojo can't recognize the struct\n`Container[Int]` as conforming to `Stringable`, even though the `__str__()`\nmethod is implemented for any `ElementType` that's also `Stringable`.", "position": 18, "token_count": 172, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-018", "document_id": "parameters-index", "position": 18, "token_count": 172, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-019", "document_id": "parameters-index", "content": "### Case study: the SIMD type\n\nFor a real-world example of a parameterized type, let's look at the\n[`SIMD`](/mojo/stdlib/builtin/simd/SIMD) type from Mojo's standard library.\n\n[Single instruction, multiple data (SIMD)](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data) is a parallel processing technology built into many modern CPUs,\nGPUs, and custom accelerators. SIMD allows you to perform a single operation on\nmultiple pieces of data at once. For example, if you want to take the square\nroot of each element in an array, you can use SIMD to parallelize the work.", "position": 19, "token_count": 161, "has_code": false, "section_hierarchy": ["Case study: the SIMD type"], "metadata": {"chunk_id": "parameters-index-019", "document_id": "parameters-index", "position": 19, "token_count": 161, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Case study: the SIMD type"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#case-study-the-simd-type"}}
{"chunk_id": "parameters-index-020", "document_id": "parameters-index", "content": "Processors implement SIMD using low-level vector registers in hardware that hold\nmultiple instances of a scalar data type. In order to use the SIMD instructions\non these processors, the data must be shaped into the proper SIMD width\n(data type) and length (vector size). Processors may support 512-bit or\nlonger SIMD vectors, and support many data types from 8-bit integers to 64-bit\nfloating point numbers, so it's not practical to define all of the possible SIMD\nvariations.\n\nMojo's [`SIMD`](/mojo/stdlib/builtin/simd/SIMD) type (defined as a struct)\nexposes the common SIMD operations through its methods, and makes the SIMD data\ntype and size values parametric. This allows you to directly map your data to\nthe SIMD vectors on any hardware.\n\nHere's a cut-down (non-functional) version of Mojo's `SIMD` type definition:\n\n```mojo\nstruct SIMD[type: DType, size: Int]:\n var value: â€¦ # Some low-level MLIR stuff here", "position": 20, "token_count": 238, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-020", "document_id": "parameters-index", "position": 20, "token_count": 238, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-021", "document_id": "parameters-index", "content": "```mojo\nstruct SIMD[type: DType, size: Int]:\n var value: â€¦ # Some low-level MLIR stuff here\n\n # Create a new SIMD from a number of scalars\n fn __init__(out self, *elems: SIMD[type, 1]): ...\n\n # Fill a SIMD with a duplicated scalar value.\n @staticmethod\n fn splat(x: SIMD[type, 1]) -> SIMD[type, size]: ...\n\n # Cast the elements of the SIMD to a different elt type.\n fn cast[target: DType](self) -> SIMD[target, size]: ...\n\n # Many standard operators are supported.\n fn __add__(self, rhs: Self) -> Self: ...", "position": 21, "token_count": 191, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-021", "document_id": "parameters-index", "position": 21, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-022", "document_id": "parameters-index", "content": "```\n\nSo you can create and use a SIMD vector like this:\n\n```mojo\nvar vector = SIMD[DType.int16, 4](1, 2, 3, 4)\nvector = vector * vector\nfor i in range(4):\n print(vector[i], end=\" \")\n```\n\n```output\n1 4 9 16", "position": 22, "token_count": 81, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-022", "document_id": "parameters-index", "position": 22, "token_count": 81, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-023", "document_id": "parameters-index", "content": "```\n\n```output\n1 4 9 16\n```\n\nAs you can see, a simple arithmetic operator like `*` applied to a pair of\n`SIMD` vector operates on the corresponding elements in each vector.\n\nDefining each SIMD variant with parameters is great for code reuse because the\n`SIMD` type can express all the different vector variants statically, instead of\nrequiring the language to pre-define every variant.\n\nBecause `SIMD` is a parameterized type, the `self` argument in its functions\ncarries those parametersâ€”the full type name is `SIMD[type, size]`. Although\nit's valid to write this out (as shown in the return type of `splat()`), this\ncan be verbose, so we recommend using the `Self` type (from\n[PEP673](https://peps.python.org/pep-0673/)) like the `__add__` example does.", "position": 23, "token_count": 208, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-023", "document_id": "parameters-index", "position": 23, "token_count": 208, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-024", "document_id": "parameters-index", "content": "## Overloading on parameters\n\nFunctions and methods can be overloaded on their parameter signatures. For\ninformation on overload resolution, see\n[Overloaded functions](/mojo/manual/functions#overloaded-functions).", "position": 24, "token_count": 47, "has_code": false, "section_hierarchy": ["Overloading on parameters"], "metadata": {"chunk_id": "parameters-index-024", "document_id": "parameters-index", "position": 24, "token_count": 47, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Overloading on parameters"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#overloading-on-parameters"}}
{"chunk_id": "parameters-index-025", "document_id": "parameters-index", "content": "## Using parameterized types and functions\n\nYou can use parametric types and functions by passing values to the\nparameters in square brackets. For example, for the `SIMD` type above, `type`\nspecifies the data type and `size` specifies the length of the SIMD vector (it\nmust be a power of 2):\n\n```mojo\ndef main():\n # Make a vector of 4 floats.\n var small_vec = SIMD[DType.float32, 4](1.0, 2.0, 3.0, 4.0)\n\n # Make a big vector containing 1.0 in float16 format.\n var big_vec = SIMD[DType.float16, 32](1.0)\n\n # Do some math and convert the elements to float32.\n var bigger_vec = (big_vec + big_vec).cast[DType.float32]()\n\n # You can write types out explicitly if you want of course.\n var bigger_vec2: SIMD[DType.float32, 32] = bigger_vec", "position": 25, "token_count": 232, "has_code": true, "section_hierarchy": ["Using parameterized types and functions"], "metadata": {"chunk_id": "parameters-index-025", "document_id": "parameters-index", "position": 25, "token_count": 232, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Using parameterized types and functions"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#using-parameterized-types-and-functions"}}
{"chunk_id": "parameters-index-026", "document_id": "parameters-index", "content": "# You can write types out explicitly if you want of course.\n var bigger_vec2: SIMD[DType.float32, 32] = bigger_vec\n\n print(\"small_vec DType:\", small_vec.dtype, \"size:\", small_vec.size)\n print(\n \"bigger_vec2 DType:\",\n bigger_vec2.dtype,\n \"size:\",\n bigger_vec2.size,\n )", "position": 26, "token_count": 106, "has_code": false, "section_hierarchy": ["You can write types out explicitly if you want of course."], "metadata": {"chunk_id": "parameters-index-026", "document_id": "parameters-index", "position": 26, "token_count": 106, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["You can write types out explicitly if you want of course."], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#you-can-write-types-out-explicitly-if-you-want-of-course"}}
{"chunk_id": "parameters-index-027", "document_id": "parameters-index", "content": "```\n\n```output\nsmall_vec type: float32 length: 4\nbigger_vec2 type: float32 length: 32", "position": 27, "token_count": 32, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-027", "document_id": "parameters-index", "position": 27, "token_count": 32, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-028", "document_id": "parameters-index", "content": "```\n\nNote that the `cast()` method also needs a parameter to specify the type you\nwant from the cast (the method definition above expects a `target` parametric\nvalue). Thus, just as the `SIMD` struct is a generic type definition, the\n`cast()` method is a generic method definition. At compile time, the compiler\ncreates a concrete version of the `cast()` method with the target parameter\nbound to `DType.float32`.\n\nThe code above shows the use of concrete types (that is, the parameters are all\nbound to known values). But the major power of parameters comes from the\nability to define parametric algorithms and types (code that uses the parameter\nvalues). For example, here's how to define a parametric algorithm with `SIMD`\nthat is type- and width-agnostic:\n\n```mojo\nfrom math import sqrt\n\nfn rsqrt[dt: DType, width: Int](x: SIMD[dt, width]) -> SIMD[dt, width]:\n return 1 / sqrt(x)", "position": 28, "token_count": 236, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-028", "document_id": "parameters-index", "position": 28, "token_count": 236, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-029", "document_id": "parameters-index", "content": "fn rsqrt[dt: DType, width: Int](x: SIMD[dt, width]) -> SIMD[dt, width]:\n return 1 / sqrt(x)\n\ndef main():\n var v = SIMD[DType.float16, 4](42)\n print(rsqrt(v))", "position": 29, "token_count": 77, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-029", "document_id": "parameters-index", "position": 29, "token_count": 77, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-030", "document_id": "parameters-index", "content": "```\n\n```output\n[0.154296875, 0.154296875, 0.154296875, 0.154296875]\n```\n\nNotice that the `x` argument is actually a `SIMD` type based on the function\nparameters. The runtime program can use the value of the parameters, because the\nparameters are resolved at compile-time before they are needed by the runtime\nprogram (but compile-time parameter expressions cannot use runtime values).", "position": 30, "token_count": 112, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-030", "document_id": "parameters-index", "position": 30, "token_count": 112, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-031", "document_id": "parameters-index", "content": "### Parameter inference\n\nThe Mojo compiler can often *infer* parameter values, so you don't always have\nto specify them. For example, you can call the `rsqrt()` function defined above\nwithout any parameters:\n\n```mojo\nvar v = SIMD[DType.float16, 4](33)\nprint(rsqrt(v))\n```\n\n```output\n[0.174072265625, 0.174072265625, 0.174072265625, 0.174072265625]", "position": 31, "token_count": 125, "has_code": true, "section_hierarchy": ["Parameter inference"], "metadata": {"chunk_id": "parameters-index-031", "document_id": "parameters-index", "position": 31, "token_count": 125, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parameter inference"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#parameter-inference"}}
{"chunk_id": "parameters-index-032", "document_id": "parameters-index", "content": "```\n\n```output\n[0.174072265625, 0.174072265625, 0.174072265625, 0.174072265625]\n```\n\nThe compiler infers its parameters based on the parametric `v`\nvalue passed into it, as if you wrote `rsqrt[DType.float16, 4](v)` explicitly.\n\nMojo can also infer the values of struct parameters from the arguments passed to\na constructor or static method.\n\nFor example, consider the following struct:\n\n```mojo\nstruct One[Type: Writable & Copyable & Movable]:\n var value: Type\n\n fn __init__(out self, value: Type):\n self.value = value.copy()\n\ndef use_one():\n s1 = One(123)\n s2 = One(\"Hello\")", "position": 32, "token_count": 199, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-032", "document_id": "parameters-index", "position": 32, "token_count": 199, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-033", "document_id": "parameters-index", "content": "```\n\nNote that you can create an instance of `One` without specifying the `Type`\nparameterâ€”Mojo can infer it from the `value` argument.\n\nYou can also infer parameters from a parameterized type passed to a constructor\nor static method:\n\n```mojo\nstruct Two[Type: Writable & Copyable & Movable]:\n var val1: Type\n var val2: Type\n\n fn __init__(out self, one: One[Type], another: One[Type]):\n self.val1 = one.value.copy()\n self.val2 = another.value.copy()\n print(String(self.val1), String(self.val2))\n\n @staticmethod\n fn fire(thing1: One[Type], thing2: One[Type]):\n print(\"ðŸ”¥\", String(thing1.value), String(thing2.value))", "position": 33, "token_count": 205, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-033", "document_id": "parameters-index", "position": 33, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-034", "document_id": "parameters-index", "content": "@staticmethod\n fn fire(thing1: One[Type], thing2: One[Type]):\n print(\"ðŸ”¥\", String(thing1.value), String(thing2.value))\n\ndef use_two():\n s3 = Two(One(\"infer\"), One(\"me\"))\n Two.fire(One(1), One(2))\n # Two.fire(One(\"mixed\"), One(0)) # Error: parameter inferred to two\n # different values\n\nuse_two()", "position": 34, "token_count": 125, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-034", "document_id": "parameters-index", "position": 34, "token_count": 125, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-035", "document_id": "parameters-index", "content": "```\n\n```output\ninfer me\nðŸ”¥ 1 2\n```\n\n`Two` takes a `Type` parameter, and its constructor takes values of type\n`One[Type]`. When constructing an instance of `Two`, you don't need to specify\nthe `Type` parameter, since it can be inferred from the arguments.\n\nSimilarly, the static `fire()` method takes values of type `One[Type]`, so Mojo\ncan infer the `Type` value at compile time. Note that passing two instances of\n`One` with different types doesn't work.\n\n[note]\nIf you're familiar with C++, you may recognize this as similar to Class Template\nArgument Deduction (CTAD).", "position": 35, "token_count": 159, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-035", "document_id": "parameters-index", "position": 35, "token_count": 159, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-036", "document_id": "parameters-index", "content": "## Optional parameters and keyword parameters\n\nJust as you can specify [optional\narguments](/mojo/manual/functions#optional-arguments) in function signatures,\nyou can also define an optional *parameter* by giving it a default value.\n\nYou can also pass parameters by keyword, just like you can use\n[keyword arguments](/mojo/manual/functions#keyword-arguments).\nFor a function or struct with multiple optional parameters, using keywords\nallows you to pass only the parameters you want to specify, regardless of\ntheir position in the function signature.\n\nFor example, here's a function with two parameters, each with a default value:\n\n```mojo\nfn speak[a: Int = 3, msg: String = \"woof\"]():\n print(msg, a)\n\nfn use_defaults():\n speak() # prints 'woof 3'\n speak[5]() # prints 'woof 5'\n speak[7, \"meow\"]() # prints 'meow 7'\n speak[msg=\"baaa\"]() # prints 'baaa 3'", "position": 36, "token_count": 241, "has_code": true, "section_hierarchy": ["Optional parameters and keyword parameters"], "metadata": {"chunk_id": "parameters-index-036", "document_id": "parameters-index", "position": 36, "token_count": 241, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Optional parameters and keyword parameters"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#optional-parameters-and-keyword-parameters"}}
{"chunk_id": "parameters-index-037", "document_id": "parameters-index", "content": "```\n\nRecall that when a parametric function is called, Mojo can\n[infer the parameter values](#parameter-inference). That is, it can determine\nits parameter values from the parameters attached to an argument. If the\nparametric function also has a default value defined, then the inferred\nparameter value takes precedence.\n\nFor example, in the following code, we update the parametric `speak[]()` function\nto take an argument with a parametric type. Although the function has a default\nparameter value for `a`, Mojo instead uses the inferred `a` parameter value\nfrom the `bar` argument (as written, the default `a` value can never be used,\nbut this is just for demonstration purposes):\n\n```mojo\n@fieldwise_init\nstruct Bar[v: Int]:\n pass\n\nfn speak[a: Int = 3, msg: String = \"woof\"](bar: Bar[a]):\n print(msg, a)\n\nfn use_inferred():\n speak(Bar[9]()) # prints 'woof 9'", "position": 37, "token_count": 239, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-037", "document_id": "parameters-index", "position": 37, "token_count": 239, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-038", "document_id": "parameters-index", "content": "```\n\nAs mentioned above, you can also use optional parameters and keyword\nparameters in a struct:\n\n```mojo\nstruct KwParamStruct[greeting: String = \"Hello\", name: String = \"ðŸ”¥mojoðŸ”¥\"]:\n fn __init__(out self):\n print(greeting, name)\n\nfn use_kw_params():\n var a = KwParamStruct[]() # prints 'Hello ðŸ”¥mojoðŸ”¥'\n var b = KwParamStruct[name=\"World\"]() # prints 'Hello World'\n var c = KwParamStruct[greeting=\"Hola\"]() # prints 'Hola ðŸ”¥mojoðŸ”¥'\n```\n\n[note]\nMojo supports positional-only and keyword-only parameters, following the same\nrules as [positional-only and keyword-only\narguments](/mojo/manual/functions#positional-only-and-keyword-only-arguments).", "position": 38, "token_count": 206, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-038", "document_id": "parameters-index", "position": 38, "token_count": 206, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-039", "document_id": "parameters-index", "content": "## Infer-only parameters\n\nSometimes you need to declare functions where parameters depend on other\nparameters. Because the signature is processed left to right, a parameter can\nonly *depend* on a parameter earlier in the parameter list. For example:\n\n```mojo\nfn dependent_type[dtype: DType, value: Scalar[dtype]]():\n print(\"Value: \", value)\n print(\"Value is floating-point: \", dtype.is_floating_point())\n\ndependent_type[DType.float64, Float64(2.2)]()\n```\n\n```output\nValue: 2.2000000000000002\nValue is floating-point: True\n```\n\nYou can't reverse the position of the `dtype` and `value` parameters, because\n`value` depends on `dtype`. However, because `dtype` is a required parameter,\nyou can't leave it out of the parameter list and let Mojo infer it from `value`:\n\n```mojo\ndependent_type[Float64(2.2)]() # Error!", "position": 39, "token_count": 243, "has_code": true, "section_hierarchy": ["Infer-only parameters"], "metadata": {"chunk_id": "parameters-index-039", "document_id": "parameters-index", "position": 39, "token_count": 243, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Infer-only parameters"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#infer-only-parameters"}}
{"chunk_id": "parameters-index-040", "document_id": "parameters-index", "content": "```\n\nInfer-only parameters are a special class of parameters that are **always** either\ninferred from context or specified by keyword. Infer-only parameters are placed at the\n**beginning** of the parameter list, set off from other parameters by the `//` sigil:\n\n```mojo\nfn example[type: Copyable & Movable, //, list: List[type]]()\n```\n\nTransforming `dtype` into an infer-only parameter solves this problem:\n\n```mojo\nfn dependent_type[dtype: DType, //, value: Scalar[dtype]]():\n print(\"Value: \", value)\n print(\"Value is floating-point: \", dtype.is_floating_point())\n\ndependent_type[Float64(2.2)]()\n```\n\n```output\nValue: 2.2000000000000002\nValue is floating-point: True", "position": 40, "token_count": 218, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-040", "document_id": "parameters-index", "position": 40, "token_count": 218, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-041", "document_id": "parameters-index", "content": "```\n\n```output\nValue: 2.2000000000000002\nValue is floating-point: True\n```\n\nBecause infer-only parameters are declared at the beginning of the parameter\nlist, other parameters can depend on them, and the compiler will always attempt\nto infer the infer-only values from bound parameters or arguments.\n\nThere are sometimes cases where it's useful to specify an infer-only parameter\nby keyword. For example, the\n[`Span`](/mojo/stdlib/memory/span/Span/) type\nis parametric on [origin](/mojo/manual/values/lifetimes):\n\n```mojo\nstruct Span[mut: Bool, //, T: Copyable & Movable, origin: Origin[mut], ...]:\n ...", "position": 41, "token_count": 182, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-041", "document_id": "parameters-index", "position": 41, "token_count": 182, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-042", "document_id": "parameters-index", "content": "```\n\nHere, the `mut` parameter is infer-only. The value is usually inferred when you\ncreate an instance of `Span`. Binding the `mut` parameter by keyword lets you\ndefine a `Span` that requires a mutable origin.\n\n```mojo\ndef mutate_span(span: Span[mut=True, Byte]):\n for i in range(0, len(span), 2):\n if i + 1 < len(span):\n span.swap_elements(UInt(i), UInt(i + 1))\n```\n\nIf the compiler can't infer the value of an infer-only parameter, and it's not\nspecified by keyword, compilation fails.", "position": 42, "token_count": 162, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-042", "document_id": "parameters-index", "position": 42, "token_count": 162, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-043", "document_id": "parameters-index", "content": "## Variadic parameters\n\nMojo also supports variadic parameters, similar to\n[Variadic arguments](/mojo/manual/functions#variadic-arguments):\n\n```mojo\nstruct MyTensor[*dimensions: Int]:\n pass\n```\n\nVariadic parameters currently have some limitations that variadic arguments don't have:\n\n* Variadic parameters must be homogeneousâ€”that is, all the values must be the\n same type.\n\n* The parameter type must be register-passable.\n\n* The parameter values aren't automatically projected into a `VariadicList`, so you\n need to construct the list explicitly:\n\n```mojo\nfn sum_params[*values: Int]() -> Int:\n alias list = VariadicList(values)\n var sum = 0\n for v in list:\n sum += v\n return sum\n```\n\nVariadic keyword parameters (for example, `**kwparams`) are\nnot supported yet.", "position": 43, "token_count": 210, "has_code": true, "section_hierarchy": ["Variadic parameters"], "metadata": {"chunk_id": "parameters-index-043", "document_id": "parameters-index", "position": 43, "token_count": 210, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Variadic parameters"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#variadic-parameters"}}
{"chunk_id": "parameters-index-044", "document_id": "parameters-index", "content": "## Parameter expressions are just Mojo code\n\nA parameter expression is any code expression (such as `a+b`) that occurs where\na parameter is expected. Parameter expressions support operators and function\ncalls, just like runtime code, and all parameter types use the same type\nsystem as the runtime program (such as `Int` and `DType`).\n\nBecause parameter expressions use the same grammar and types as runtime\nMojo code, you can use many\n[\"dependent type\"](https://en.wikipedia.org/wiki/Dependent_type) features. For\nexample, you might want to define a helper function to concatenate two SIMD\nvectors:\n\n```mojo\nfn concat[\n dtype: DType, ls_size: Int, rh_size: Int, //\n](lhs: SIMD[dtype, ls_size], rhs: SIMD[dtype, rh_size]) -> SIMD[\n dtype, ls_size + rh_size\n]:\n var result = SIMD[dtype, ls_size + rh_size]()", "position": 44, "token_count": 244, "has_code": true, "section_hierarchy": ["Parameter expressions are just Mojo code"], "metadata": {"chunk_id": "parameters-index-044", "document_id": "parameters-index", "position": 44, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parameter expressions are just Mojo code"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#parameter-expressions-are-just-mojo-code"}}
{"chunk_id": "parameters-index-045", "document_id": "parameters-index", "content": "@parameter\n for i in range(ls_size):\n result[i] = lhs[i]\n\n @parameter\n for j in range(rh_size):\n result[ls_size + j] = rhs[j]\n return result", "position": 45, "token_count": 55, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-045", "document_id": "parameters-index", "position": 45, "token_count": 55, "has_code": false, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-046", "document_id": "parameters-index", "content": "```\n\n```output\nresult type: float32 length: 4\n```\n\nNote that the resulting length is the sum of the input vector lengths, and this\nis expressed with a simple `+` operation.", "position": 46, "token_count": 46, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-046", "document_id": "parameters-index", "position": 46, "token_count": 46, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-047", "document_id": "parameters-index", "content": "### Powerful compile-time programming\n\nWhile simple expressions are useful, sometimes you want to write imperative\ncompile-time logic with control flow. You can even do compile-time recursion.\nFor instance, here is an example \"tree reduction\" algorithm that sums all\nelements of a vector recursively into a scalar:\n\n```mojo\nfn slice[\n dtype: DType, size: Int, //\n](x: SIMD[dtype, size], offset: Int) -> SIMD[dtype, size // 2]:\n alias new_size = size // 2\n var result = SIMD[dtype, new_size]()\n for i in range(new_size):\n result[i] = SIMD[dtype, 1](x[i + offset])\n return result\n\nfn reduce_add(x: SIMD) -> Int:\n @parameter\n if x.size == 1:\n return Int(x[0])\n elif x.size == 2:\n return Int(x[0]) + Int(x[1])", "position": 47, "token_count": 237, "has_code": true, "section_hierarchy": ["Powerful compile-time programming"], "metadata": {"chunk_id": "parameters-index-047", "document_id": "parameters-index", "position": 47, "token_count": 237, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Powerful compile-time programming"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#powerful-compile-time-programming"}}
{"chunk_id": "parameters-index-048", "document_id": "parameters-index", "content": "# Extract the top/bottom halves, add them, sum the elements.\n alias half_size = x.size // 2\n var lhs = slice(x, 0)\n var rhs = slice(x, half_size)\n return reduce_add(lhs + rhs)\n\ndef main():\n var x = SIMD[DType.int, 4](1, 2, 3, 4)\n print(x)\n print(\"Elements sum:\", reduce_add(x))", "position": 48, "token_count": 107, "has_code": false, "section_hierarchy": ["Extract the top/bottom halves, add them, sum the elements."], "metadata": {"chunk_id": "parameters-index-048", "document_id": "parameters-index", "position": 48, "token_count": 107, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Extract the top/bottom halves, add them, sum the elements."], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#extract-the-topbottom-halves-add-them-sum-the-elements"}}
{"chunk_id": "parameters-index-049", "document_id": "parameters-index", "content": "```\n\n```output\n[1, 2, 3, 4]\nElements sum: 10\n```\n\nThis makes use of the [`@parameter`](/mojo/manual/decorators/parameter) decorator to\ncreate a parametric if condition, which is an `if` statement that runs at compile-time.\nIt requires that its condition be a valid parameter expression, and ensures that only\nthe live branch of the `if` statement is compiled into the program. (This is similar to\nuse of the `@parameter` decorator with a `for` loop shown earlier.)", "position": 49, "token_count": 126, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-049", "document_id": "parameters-index", "position": 49, "token_count": 126, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-050", "document_id": "parameters-index", "content": "## `alias`: named parameter expressions\n\nIt is very common to want to *name* compile-time values. Whereas `var` defines a\nruntime value, we need a way to define a\ncompile-time temporary value. For this, Mojo uses an `alias` declaration. At its\nsimplest, `alias` can be used to define a constant value:\n\n```mojo\nalias rows = 512", "position": 50, "token_count": 86, "has_code": true, "section_hierarchy": ["`alias`: named parameter expressions"], "metadata": {"chunk_id": "parameters-index-050", "document_id": "parameters-index", "position": 50, "token_count": 86, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["`alias`: named parameter expressions"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#alias-named-parameter-expressions"}}
{"chunk_id": "parameters-index-051", "document_id": "parameters-index", "content": "```\n\nSome Mojo types use aliases to express enumerations. For example, the following\ncode defines a `Sentiment` type that defines aliases for different sentiment\nvalues:\n\n```mojo\n@fieldwise_init\nstruct Sentiment(EqualityComparable, ImplicitlyCopyable):\n var _value: Int\n\n alias NEGATIVE = Sentiment(0)\n alias NEUTRAL = Sentiment(1)\n alias POSITIVE = Sentiment(2)\n\n fn __eq__(self, other: Self) -> Bool:\n return self._value == other._value\n\n fn __ne__(self, other: Self) -> Bool:\n return not (self == other)\n\nfn is_happy(s: Sentiment):\n if s == Sentiment.POSITIVE:\n print(\"Yes. ðŸ˜€\")\n else:\n print(\"No. â˜¹ï¸\")", "position": 51, "token_count": 186, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-051", "document_id": "parameters-index", "position": 51, "token_count": 186, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-052", "document_id": "parameters-index", "content": "```\n\nThis pattern provides a type-safe enumeration.\n\nThe [`DType`](/mojo/stdlib/builtin/dtype/DType) struct implements a simple enum\nusing aliases like this. This allows clients to use values like `DType.float32`\nin parameter expressions or runtime expressions.\n\nTypes are another common use for aliases. Because types are compile-time\nexpressions, you can use an alias as a shorthand (or \"typedef\") for a\nparameterized type:\n\n```mojo\nalias Float16 = SIMD[DType.float16, 1]\nalias UInt8 = SIMD[DType.uint8, 1]\n\nvar x: Float16 = 0 # Float16 works like a \"typedef\"\n```\n\n(These aliases and others are actually defined in the\n[`simd` module](/mojo/stdlib/builtin/simd/#aliases).)\n\nLike `var` variables, aliases obey scope, and you can use local aliases within\nfunctions as you'd expect.", "position": 52, "token_count": 236, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-052", "document_id": "parameters-index", "position": 52, "token_count": 236, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-053", "document_id": "parameters-index", "content": "### Parametric aliases\n\nA *parametric alias* is a compile-time expression that takes a list of\nparameters and returns a compile-time constant value:\n\n```mojo\nalias AddOne[a: Int] : Int = a + 1\n\nalias nine = AddOne(8)\n```\n\nAs you can see in the previous example, a parametric alias is a little like a\n*compile-time-only function*. A regular function or method can also be invoked\nat compile time:\n\n```mojo\nfn add_one(a: Int) -> Int:\n return a + 1\n\nalias ten = add_one(9)\n```\n\nA major difference between a function and a parametric alias is that the value\nof an alias can be a type, while a function can't return a type as a value.\n\n```mojo", "position": 53, "token_count": 183, "has_code": true, "section_hierarchy": ["Parametric aliases"], "metadata": {"chunk_id": "parameters-index-053", "document_id": "parameters-index", "position": 53, "token_count": 183, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parametric aliases"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#parametric-aliases"}}
{"chunk_id": "parameters-index-054", "document_id": "parameters-index", "content": "# Does not workâ€”-dynamic type values not permitted\nfn int_type() -> AnyType:\n return Int", "position": 54, "token_count": 27, "has_code": false, "section_hierarchy": ["Does not workâ€”-dynamic type values not permitted"], "metadata": {"chunk_id": "parameters-index-054", "document_id": "parameters-index", "position": 54, "token_count": 27, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Does not workâ€”-dynamic type values not permitted"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#does-not-work-dynamic-type-values-not-permitted"}}
{"chunk_id": "parameters-index-055", "document_id": "parameters-index", "content": "# Works\nalias IntType = Int\n```\n\nBecause the value of an alias can be a type, you can use parametric aliases to\nexpress new types:\n\n```mojo\nalias TwoOfAKind[dt: DType] = SIMD[dt, 2]\ntwoFloats = TwoOfAKind[DType.float32](1.0, 2.0)\n\nalias StringKeyDict[ValueType: Copyable & Movable] = Dict[String, ValueType]\nvar b: StringKeyDict[UInt8] = {\"answer\": 42}", "position": 55, "token_count": 125, "has_code": true, "section_hierarchy": ["Works"], "metadata": {"chunk_id": "parameters-index-055", "document_id": "parameters-index", "position": 55, "token_count": 125, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Works"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#works"}}
{"chunk_id": "parameters-index-056", "document_id": "parameters-index", "content": "```\n\nParametric alias signatures support the same features as parameterized structs\nor functions: infer-only parameters, keyword-only and optional parameters,\n[automatic parameterization](#automatic-parameterization), and so on.\n\n```mojo\n alias Floats[size: Int, half_width: Bool = False] = SIMD[\n (DType.float16 if half_width else DType.float32), size\n ]\n var floats = Floats[2](6.0, 8.0)\n var half_floats = Floats[2, True](10.0, 12.0)\n```", "position": 56, "token_count": 136, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-056", "document_id": "parameters-index", "position": 56, "token_count": 136, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-057", "document_id": "parameters-index", "content": "## Fully-bound, partially-bound, and unbound types\n\nA parametric type with its parameters specified is said to be *fully-bound*.\nThat is, all of its parameters are bound to values. As mentioned before, you can\nonly instantiate a fully-bound type (sometimes called a *concrete type*).\n\nHowever, parametric types can be *unbound* or *partially bound* in some\ncontexts. For example, you can alias a partially-bound type to create a new type\nthat requires fewer parameters:\n\n```mojo\nalias StringKeyDict = Dict[String, _]\nvar b: StringKeyDict[UInt8] = {\"answer\": 42}", "position": 57, "token_count": 146, "has_code": true, "section_hierarchy": ["Fully-bound, partially-bound, and unbound types"], "metadata": {"chunk_id": "parameters-index-057", "document_id": "parameters-index", "position": 57, "token_count": 146, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Fully-bound, partially-bound, and unbound types"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#fully-bound-partially-bound-and-unbound-types"}}
{"chunk_id": "parameters-index-058", "document_id": "parameters-index", "content": "```\n\nHere, `StringKeyDict` is a type alias for a `Dict` that takes `String` keys. The\nunderscore `_` in the parameter list indicates that the second parameter,\n`V` (the value type), is unbound.\nYou specify the `V` parameter later, when you use `StringKeyDict`.\n\nnote Partially-bound types versus parametric aliases\n\nYou may notice that this example is very similar to an example in the section\non [parametric aliases](#parametric-aliases). For simple type aliases like this,\nyou can use either a partially-bound type or a parametric alias.\nParametric aliases provide a more flexible way to define type aliases, since\nyou can define the order of the parameters, add default values, and so on.\n\nPartially-bound and unbound types can provide a handy shortcut when defining\nparametric functions and aliases, called\n[automatic parameterization](#automatic-parameterization).\n\nYou can also use partially-bound types as the type bound for an argument or\nparameter.", "position": 58, "token_count": 228, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-058", "document_id": "parameters-index", "position": 58, "token_count": 228, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-059", "document_id": "parameters-index", "content": "You can also use partially-bound types as the type bound for an argument or\nparameter.\n\nFor example, given the following type:\n\n```mojo\nstruct MyType[s: String, i: Int, i2: Int, b: Bool = True]:\n pass", "position": 59, "token_count": 60, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-059", "document_id": "parameters-index", "position": 59, "token_count": 60, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-060", "document_id": "parameters-index", "content": "```\n\nIt can appear in code in the following forms:\n\n* *Fully bound*, with all of its parameters specified:\n\n ```mojo\n def my_fn1(m1: MyType[\"Hello\", 3, 4, True]):\n pass\n ```\n\n* *Partially bound*, with *some but not all* of its parameters specified:\n\n ```mojo\n def my_fn2(m2: MyType[\"Hola\", _, _, True]):\n pass\n ```\n\n* *Unbound*, with no parameters specified:\n\n ```mojo\n def my_fn3(m3: MyType[_, _, _, _]):\n pass\n ```\n\nYou can also use the star-underscore expression `*_` to unbind an arbitrary\nnumber of positional parameters at the end of a parameter list:\n\n```mojo", "position": 60, "token_count": 190, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-060", "document_id": "parameters-index", "position": 60, "token_count": 190, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-061", "document_id": "parameters-index", "content": "# These two types are equivalent\nMyType[\"Hello\", *_]\nMyType[\"Hello\", _, _, _]\n```\n\nThe `*_` expression specifically matches any parameters that can be specified by\nposition (positional-only or positional-or-keyword). To unbind keyword-only\nparameters, use the double-star-underscore expression, `**_`, which matches any\nparameters that can be specified by keyword (positional-or-keyword or\nkeyword-only).\n\n```mojo\n@fieldwise_init\nstruct KeyWordStruct[pos_or_kw: Int, *, kw_only: Int = 10]:\n pass", "position": 61, "token_count": 156, "has_code": true, "section_hierarchy": ["These two types are equivalent"], "metadata": {"chunk_id": "parameters-index-061", "document_id": "parameters-index", "position": 61, "token_count": 156, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["These two types are equivalent"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#these-two-types-are-equivalent"}}
{"chunk_id": "parameters-index-062", "document_id": "parameters-index", "content": "# Unbind both pos_or_kw and kw_only parameters\nfn use_kw_struct(k: KeyWordStruct[**_]):\n pass\n\ndef main():\n use_kw_struct(KeyWordStruct[10, kw_only=11]())\n```\n\nWhen a parameter is explicitly unbound with the `_`, `*_`, or `**_` expressions, you\n**must** specify a value for that parameter to use the type. Any default value from the\noriginal type declaration is ignored.\n\nPartially-bound and unbound parametric types can be used in some contexts where\nthe missing (unbound) parameters will be supplied laterâ€”such as in\n[aliases](#alias-named-parameter-expressions) and\n[automatically parameterized functions](#automatic-parameterization).\n\n### Omitted parameters\n\nMojo also supports an alternate format for unbound parameter where the parameter\nis simply omitted from the expression:\n\n```mojo\n# Partially bound\nMyType[\"Hi there\"]", "position": 62, "token_count": 226, "has_code": true, "section_hierarchy": ["Partially bound"], "metadata": {"chunk_id": "parameters-index-062", "document_id": "parameters-index", "position": 62, "token_count": 226, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Partially bound"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#partially-bound"}}
{"chunk_id": "parameters-index-063", "document_id": "parameters-index", "content": "# Partially bound\nMyType[\"Hi there\"]\n# Unbound\nMyType\n```\n\nThis format differs from the explicit unbinding syntax described above in that\nthe default values for omitted parameters are bound immediately. For example,\nthe following expressions are equivalent:\n\n```mojo\nMyType[\"Hi there\"]", "position": 63, "token_count": 66, "has_code": true, "section_hierarchy": ["Unbound"], "metadata": {"chunk_id": "parameters-index-063", "document_id": "parameters-index", "position": 63, "token_count": 66, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Unbound"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#unbound"}}
{"chunk_id": "parameters-index-064", "document_id": "parameters-index", "content": "# equivalent to\nMyType[\"Hi there\", _, _, True] # Uses the default value for `b`\n```\n\n[note]\nThis behavior with omitted parameters is currently supported for backwards\ncompatibility. We intend to reconcile the behavior of omitted parameters and\nexplicitly unbound parameters in the future.", "position": 64, "token_count": 64, "has_code": true, "section_hierarchy": ["equivalent to"], "metadata": {"chunk_id": "parameters-index-064", "document_id": "parameters-index", "position": 64, "token_count": 64, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["equivalent to"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#equivalent-to"}}
{"chunk_id": "parameters-index-065", "document_id": "parameters-index", "content": "## Automatic parameterization\n\nMojo supports \"automatic\" parameterization of functions and parametric aliases.\nIf a function argument type or parameter type is\n[partially-bound or unbound](#fully-bound-partially-bound-and-unbound-types),\nthe unbound parameters are automatically added as input parameters on the\nfunction. This is easier to understand with an example:\n\n```mojo\nfn print_params(vec: SIMD):\n print(vec.type)\n print(vec.size)\n\nvar v = SIMD[DType.float64, 4](1.0, 2.0, 3.0, 4.0)\nprint_params(v)\n```\n\n```output\nfloat64\n4", "position": 65, "token_count": 160, "has_code": true, "section_hierarchy": ["Automatic parameterization"], "metadata": {"chunk_id": "parameters-index-065", "document_id": "parameters-index", "position": 65, "token_count": 160, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Automatic parameterization"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#automatic-parameterization"}}
{"chunk_id": "parameters-index-066", "document_id": "parameters-index", "content": "```\n\n```output\nfloat64\n4\n```\n\nIn the above example, the `print_params` function is automatically\nparameterized. The `vec` argument takes an argument of type `SIMD[*_]`. This is\nan [unbound parameterized\ntype](#fully-bound-partially-bound-and-unbound-types)â€”that is, it doesn't\nspecify any parameter values for the type. Mojo treats the unbound parameters\non `vec` as infer-only parameters on the function. This is roughly equivalent to\nthe following code:\n\n```mojo\nfn print_params2[t: DType, s: Int, //](vec: SIMD[t, s]):\n print(vec.dtype)\n print(vec.size)", "position": 66, "token_count": 178, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-066", "document_id": "parameters-index", "position": 66, "token_count": 178, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-067", "document_id": "parameters-index", "content": "```\n\nWhen you call `print_params()` you must pass it a concrete instance of the\n`SIMD` typeâ€”that is, one with all of its parameters specified, like\n`SIMD[DType.float64, 4]`. The Mojo compiler *infers* the parameter\nvalues from the input argument.\n\nWith a manually parameterized function, you can access the input parameters by\nname (for example, `t` and `s` in the previous example). For an\nautomatically parameterized function, you can access the parameters as\nattributes on the argument (for example, `vec.type`).\n\nThis ability to access a type's input parameters is not specific to\nautomatically parameterized functions, you can use it anywhere. You can access\nthe input parameters of a parameterized type as attributes on the type itself:\n\n```mojo\nfn on_type():\n print(SIMD[DType.float32, 2].size) # prints 2", "position": 67, "token_count": 207, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-067", "document_id": "parameters-index", "position": 67, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-068", "document_id": "parameters-index", "content": "```\n\nOr as attributes on an *instance* of the type:\n\n```mojo\nfn on_instance():\n var x = SIMD[DType.int32, 2](4, 8)\n print(x.dtype) # prints int32", "position": 68, "token_count": 59, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-068", "document_id": "parameters-index", "position": 68, "token_count": 59, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-069", "document_id": "parameters-index", "content": "```\n\nYou can even use this syntax in the function's signature to define a\nfunction's arguments and return type based on an argument's parameters.\nFor example, if you want your function to take two SIMD vectors with the same\ntype and size, you can write code like this:\n\n```mojo\nfn interleave(v1: SIMD, v2: __type_of(v1)) -> SIMD[v1.type, v1.size*2]:\n var result = SIMD[v1.type, v1.size*2]()\n for i in range(v1.size):\n result[i*2] = SIMD[v1.type, 1](v1[i])\n result[i*2+1] = SIMD[v1.type, 1](v2[i])\n return result\n\nvar a = SIMD[DType.int16, 4](1, 2, 3, 4)\nvar b = SIMD[DType.int16, 4](0, 0, 0, 0)\nvar c = interleave(a, b)\nprint(c)", "position": 69, "token_count": 254, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-069", "document_id": "parameters-index", "position": 69, "token_count": 254, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-070", "document_id": "parameters-index", "content": "```\n\n```output\n[1, 0, 2, 0, 3, 0, 4, 0]\n```\n\nAs shown in the example, you can use the magic `__type_of(x)` call if you just want to\nmatch the type of an argument. In this case, it's more convenient and compact that\nwriting the equivalent `SIMD[v1.type, v1.size]`.", "position": 70, "token_count": 94, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-070", "document_id": "parameters-index", "position": 70, "token_count": 94, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-071", "document_id": "parameters-index", "content": "### Automatic parameterization of parameters\n\nYou can also take advantage of automatic parameterization in the parameter list\nof a function or parametric alias. For example:\n\n```mojo\nfn foo[value: SIMD]():\n pass", "position": 71, "token_count": 51, "has_code": true, "section_hierarchy": ["Automatic parameterization of parameters"], "metadata": {"chunk_id": "parameters-index-071", "document_id": "parameters-index", "position": 71, "token_count": 51, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Automatic parameterization of parameters"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#automatic-parameterization-of-parameters"}}
{"chunk_id": "parameters-index-072", "document_id": "parameters-index", "content": "# Equivalent to:\nfn foo[dtype: DType, size: Int, //, value: SIMD[dtype, size]]():\n pass\n```\n\nHere's another example using a parametric alias:\n\n```mojo\nalias Foo[S: SIMD] = Bar[S]", "position": 72, "token_count": 69, "has_code": true, "section_hierarchy": ["Equivalent to:"], "metadata": {"chunk_id": "parameters-index-072", "document_id": "parameters-index", "position": 72, "token_count": 69, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Equivalent to:"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#equivalent-to"}}
{"chunk_id": "parameters-index-073", "document_id": "parameters-index", "content": "# Equivalent to:\nalias Foo[dtype: DType, size: Int, //, S: SIMD[dtype, size]] = Bar[S]\n```", "position": 73, "token_count": 41, "has_code": true, "section_hierarchy": ["Equivalent to:"], "metadata": {"chunk_id": "parameters-index-073", "document_id": "parameters-index", "position": 73, "token_count": 41, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Equivalent to:"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#equivalent-to"}}
{"chunk_id": "parameters-index-074", "document_id": "parameters-index", "content": "### Automatic parameterization with partially-bound types\n\nMojo also supports automatic parameterization: with [partially-bound\nparameterized types](#fully-bound-partially-bound-and-unbound-types) (that is,\ntypes with some but not all of the parameters specified).\n\nFor example, suppose we have a `Fudge` struct with three parameters:\n\n```mojo\n@fieldwise_init\nstruct Fudge[sugar: Int, cream: Int, chocolate: Int = 7](Stringable):\n fn __str__(self) -> String:\n return String.write(\"Fudge (\", sugar, \",\", cream, \",\", chocolate, \")\")\n```\n\nWe can write a function that takes a `Fudge` argument with just one bound\nparameter (it's *partially bound*):\n\n```mojo\nfn eat(f: Fudge[5, *_]):\n print(\"Ate \" + String(f))", "position": 74, "token_count": 221, "has_code": true, "section_hierarchy": ["Automatic parameterization with partially-bound types"], "metadata": {"chunk_id": "parameters-index-074", "document_id": "parameters-index", "position": 74, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Automatic parameterization with partially-bound types"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#automatic-parameterization-with-partially-bound-types"}}
{"chunk_id": "parameters-index-075", "document_id": "parameters-index", "content": "```\n\nThe `eat()` function takes a `Fudge` struct with the first parameter (`sugar`)\nbound to the value 5. The second and third parameters, `cream` and `chocolate`\nare unbound.\n\nThe unbound `cream` and `chocolate` parameters become implicit input parameters\non the `eat` function. In practice, this is roughly equivalent to writing:\n\n```mojo\nfn eat[cr: Int, ch: Int](f: Fudge[5, cr, ch]):\n print(\"Ate\", String(f))\n```\n\nIn both cases, we can call the function by passing in an instance with the\n`cream` and `chocolate` parameters bound:\n\n```mojo\neat(Fudge[5, 5, 7]())\neat(Fudge[5, 8, 9]())\n```\n\n```output\nAte Fudge (5,5,7)\nAte Fudge (5,8,9)", "position": 75, "token_count": 214, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-075", "document_id": "parameters-index", "position": 75, "token_count": 214, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-076", "document_id": "parameters-index", "content": "```\n\n```output\nAte Fudge (5,5,7)\nAte Fudge (5,8,9)\n```\n\nIf you try to pass in an argument with a `sugar` value other than 5,\ncompilation fails, because it doesn't match the argument type:\n\n```mojo\neat(Fudge[12, 5, 7]())", "position": 76, "token_count": 81, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-076", "document_id": "parameters-index", "position": 76, "token_count": 81, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-077", "document_id": "parameters-index", "content": "# ERROR: invalid call to 'eat': argument #0 cannot be converted from 'Fudge[12, 5, 7]' to 'Fudge[5, 5, 7]'\n```\n\nYou can also explicitly unbind individual parameters. This gives you\nmore freedom in specifying unbound parameters.\n\nFor example, you might want to let the user specify values for `sugar` and\n`chocolate`, and leave `cream` constant. To do this, replace each unbound\nparameter value with a single underscore (`_`):\n\n```mojo\nfn devour(f: Fudge[_, 6, _]):\n print(\"Devoured\", String(f))", "position": 77, "token_count": 151, "has_code": true, "section_hierarchy": ["ERROR: invalid call to 'eat': argument #0 cannot be converted from 'Fudge[12, 5, 7]' to 'Fudge[5, 5, 7]'"], "metadata": {"chunk_id": "parameters-index-077", "document_id": "parameters-index", "position": 77, "token_count": 151, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["ERROR: invalid call to 'eat': argument #0 cannot be converted from 'Fudge[12, 5, 7]' to 'Fudge[5, 5, 7]'"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#error-invalid-call-to-eat-argument-0-cannot-be-converted-from-fudge12-5-7-to-fudge5-5-7"}}
{"chunk_id": "parameters-index-078", "document_id": "parameters-index", "content": "```\n\nAgain, the unbound parameters (`sugar` and `chocolate`) are added as implicit\ninput parameters on the function. This version is roughly equivalent to the\nfollowing code, where these two values are explicitly bound to the input\nparameters, `su` and `ch`:\n\n```mojo\nfn devour[su: Int, ch: Int](f: Fudge[su, 6, ch]):\n print(\"Devoured\", String(f))\n```\n\nYou can also specify parameters by keyword, or mix positional and keyword\nparameters, so the following function is roughly equivalent to the previous one:\nthe first parameter, `sugar` is explicitly unbound with the underscore character.\nThe `chocolate` parameter is unbound using the keyword syntax, `chocolate=_`.\nAnd `cream` is explicitly bound to the value 6:\n\n```mojo\nfn devour(f: Fudge[_, chocolate=_, cream=6]):\n print(\"Devoured\", String(f))", "position": 78, "token_count": 224, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-078", "document_id": "parameters-index", "position": 78, "token_count": 224, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-079", "document_id": "parameters-index", "content": "```\n\nAll three versions of the `devour()` function work with the following calls:\n\n```mojo\ndevour(Fudge[3, 6, 9]())\ndevour(Fudge[4, 6, 8]())\n```\n\n```output\nDevoured Fudge (3,6,9)\nDevoured Fudge (4,6,8)\n```", "position": 79, "token_count": 89, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-079", "document_id": "parameters-index", "position": 79, "token_count": 89, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}
{"chunk_id": "parameters-index-080", "document_id": "parameters-index", "content": "### Legacy syntax (omitted parameters)\n\nYou can also specify an unbound or partially-bound type by omitting parameters:\nfor example:\n\n```mojo\nfn nibble(f: Fudge[5]):\n print(\"Ate\", String(f))\n\nnibble(Fudge[5, 4, 7]())\n\n```\n\n```output\nAte Fudge (5,4,7)\n```\n\nHere, `Fudge[5]` works like `Fudge[5, *_]` **except** in the handling of\nparameters with default values. Instead of discarding the default value of\n`chocolate`, `Fudge[5]` binds the default value immediately, making it\nequivalent to: `Fudge[5, _, 7]`.\n\nThis means that the following code won't compile with the previous definition\nfor the `nibble()` function, since it doesn't use the default value for\n`chocolate`:\n\n```mojo\nnibble(Fudge[5, 5, 9]())", "position": 80, "token_count": 231, "has_code": true, "section_hierarchy": ["Legacy syntax (omitted parameters)"], "metadata": {"chunk_id": "parameters-index-080", "document_id": "parameters-index", "position": 80, "token_count": 231, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Legacy syntax (omitted parameters)"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#legacy-syntax-omitted-parameters"}}
{"chunk_id": "parameters-index-081", "document_id": "parameters-index", "content": "# ERROR: invalid call to 'nibble': argument #0 cannot be converted from 'Fudge[5, 5, 9]' to 'Fudge[5, 5, 7]'\n```\n\nnote TODO\n\nWe intend to reconcile the behavior of omitted parameters and explicitly unbound\nparameters in the future.", "position": 81, "token_count": 67, "has_code": true, "section_hierarchy": ["ERROR: invalid call to 'nibble': argument #0 cannot be converted from 'Fudge[5, 5, 9]' to 'Fudge[5, 5, 7]'"], "metadata": {"chunk_id": "parameters-index-081", "document_id": "parameters-index", "position": 81, "token_count": 67, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["ERROR: invalid call to 'nibble': argument #0 cannot be converted from 'Fudge[5, 5, 9]' to 'Fudge[5, 5, 7]'"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#error-invalid-call-to-nibble-argument-0-cannot-be-converted-from-fudge5-5-9-to-fudge5-5-7"}}
{"chunk_id": "parameters-index-082", "document_id": "parameters-index", "content": "## The `rebind()` builtin\n\nOne of the consequences of Mojo not performing function instantiation in the\nparser like C++ is that Mojo cannot always figure out whether some parametric\ntypes are equal and complain about an invalid conversion. This typically occurs\nin static dispatch patterns. For example, the following code won't compile:\n\n```mojo\nfn take_simd8(x: SIMD[DType.float32, 8]):\n pass\n\nfn generic_simd[nelts: Int](x: SIMD[DType.float32, nelts]):\n @parameter\n if nelts == 8:\n take_simd8(x)\n```\n\nThe parser will complain:\n\n```plaintext\nerror: invalid call to 'take_simd8': argument #0 cannot be converted from\n'SIMD[f32, nelts]' to 'SIMD[f32, 8]'\n take_simd8(x)\n ~~~~~~~~~~^~~", "position": 82, "token_count": 225, "has_code": true, "section_hierarchy": ["The `rebind()` builtin"], "metadata": {"chunk_id": "parameters-index-082", "document_id": "parameters-index", "position": 82, "token_count": 225, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["The `rebind()` builtin"], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters#the-rebind-builtin"}}
{"chunk_id": "parameters-index-083", "document_id": "parameters-index", "content": "```\n\nThis is because the parser fully type-checks the function without instantiation,\nand the type of `x` is still `SIMD[f32, nelts]`, and not `SIMD[f32, 8]`, despite\nthe static conditional. The remedy is to manually \"rebind\" the type of `x`,\nusing the `rebind` builtin, which inserts a compile-time assert that the input\nand result types resolve to the same type after function instantiation:\n\n```mojo\nfn take_simd8(x: SIMD[DType.float32, 8]):\n pass\n\nfn generic_simd[nelts: Int](x: SIMD[DType.float32, nelts]):\n @parameter\n if nelts == 8:\n take_simd8(rebind[SIMD[DType.float32, 8]](x))\n```", "position": 83, "token_count": 207, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "parameters-index-083", "document_id": "parameters-index", "position": 83, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": [], "file_path": "parameters/index.mdx", "url": "https://docs.modular.com/mojo/manual/parameters", "title": "Parameterization: compile-time metaprogramming", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/parameters"}}

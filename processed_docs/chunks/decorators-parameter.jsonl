{"chunk_id": "decorators-parameter-000", "document_id": "decorators-parameter", "content": "You can add the `@parameter` decorator on an `if` or `for` statement to run that\ncode at compile time, or on a nested function to create a [parametric\nclosure](#parametric-closure).", "position": 0, "token_count": 48, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "decorators-parameter-000", "document_id": "decorators-parameter", "position": 0, "token_count": 48, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "decorators/parameter.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/parameter", "title": "@parameter", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/parameter"}}
{"chunk_id": "decorators-parameter-001", "document_id": "decorators-parameter", "content": "## Parametric `if` statement\n\nYou can add `@parameter` to any `if` condition that's based on a valid\nparameter expression (it's an expression that evaluates at compile time). This\nensures that only the live branch of the `if` statement is compiled into the\nprogram, which can reduce your final binary size. For example:\n\n```mojo\n@parameter\nif True:\n print(\"this will be included in the binary\")\nelse:\n print(\"this will be eliminated at compile time\")\n```\n\n```output\nthis will be included in the binary\n```\n\n## Par", "position": 1, "token_count": 123, "has_code": true, "section_hierarchy": ["Parametric `if` statement"], "metadata": {"chunk_id": "decorators-parameter-001", "document_id": "decorators-parameter", "position": 1, "token_count": 123, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Parametric `if` statement"], "file_path": "decorators/parameter.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/parameter", "title": "@parameter", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/parameter#parametric-if-statement"}}
{"chunk_id": "decorators-parameter-002", "document_id": "decorators-parameter", "content": "ametric `for` statement\n\nYou can add the `@parameter` decorator to a `for` loop to create a loop that's\n\"unrolled\" at compile time.\n\nThe loop sequence and induction values must be valid parameter expressions (that\nis, expressions that evaluate at compile time). For example, if you use\n`for i in range(LIMIT)`, the expression `range(LIMIT)` defines the loop\nsequence. This is a valid parameter expression if `LIMIT` is a parameter, alias,\nor integer literal.\n\nThe compiler \"unrolls\" the loop by replacing the `for` loop with\n`LIMIT` copies of the loop body with different constant `i` values.\n\nYou can use run-time expressions in the body of the loop (for example, in the\nfollowing example, the `list`, `threshold`, and `count` variables are all\nrun-time values).\n\n```mojo\nfrom random import rand\n\ndef main():\n alias LIST_SIZE = 128\n\n var list = List[Float64](length=LIST_SIZE, fill=0)\n rand(list.unsafe_ptr(), LIST_SIZE)\n\n var threshold = 0.6\n var count = 0", "position": 2, "token_count": 241, "has_code": true, "section_hierarchy": ["Parametric `for` statement"], "metadata": {"chunk_id": "decorators-parameter-002", "document_id": "decorators-parameter", "position": 2, "token_count": 241, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Parametric `for` statement"], "file_path": "decorators/parameter.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/parameter", "title": "@parameter", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/parameter#parametric-for-statement"}}
{"chunk_id": "decorators-parameter-003", "document_id": "decorators-parameter", "content": "def main():\n alias LIST_SIZE = 128\n\n var list = List[Float64](length=LIST_SIZE, fill=0)\n rand(list.unsafe_ptr(), LIST_SIZE)\n\n var threshold = 0.6\n var count = 0\n\n @parameter\n for i in range(LIST_SIZE):\n if (list[i] > threshold):\n count += 1\n\n print(\"{} items over 0.6\".format(count))\n```\n\nThe `@parameter for` construct unrolls at the beginning of compilation, which\nmight explode the size of the program that still needs to be compiled, depending\non the amount of code that's unrolled.\n\nCurrently, `@parameter for` requires the sequence's `__iter__` method to\nreturn a `_StridedRangeIterator`, meaning the induction variables must be\n`Int`. The intention is to lift this restriction in the future.\n\n## Parametric closure\n\nYou can add `@parameter`", "position": 3, "token_count": 191, "has_code": true, "section_hierarchy": ["Parametric `for` statement"], "metadata": {"chunk_id": "decorators-parameter-003", "document_id": "decorators-parameter", "position": 3, "token_count": 191, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parametric `for` statement"], "file_path": "decorators/parameter.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/parameter", "title": "@parameter", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/parameter#parametric-for-statement"}}
{"chunk_id": "decorators-parameter-004", "document_id": "decorators-parameter", "content": "on a nested function to create a “parametric”\ncapturing closure. This means you can create a closure function that captures\nvalues from the outer scope (regardless of whether they are variables or\nparameters), and then use that closure as a parameter. For example:\n\n```mojo\nfn use_closure[func: fn(Int) capturing [_] -> Int](num: Int) -> Int:\n return func(num)\n\nfn create_closure():\n var x = 1\n\n @parameter\n fn add(i: Int) -> Int:\n return x + i\n\n var y = use_closure[add](2)\n print(y)\n\ncreate_closure()\n```\n\n```output\n3\n```\n\nWithout the `@parameter` decorator, you'll get a compiler error that says you\n\"cannot use a dynamic value in call parameter\"—referring to the\n`use_closure[add](2)` call—because the `add()` closure would still be dynamic.\n\nNote the `[_]` in the function type:\n\n```mojo\nfn use_closure[func: fn(Int) capturing [_] -> Int](num: Int) -> Int:\n```", "position": 4, "token_count": 229, "has_code": true, "section_hierarchy": ["Parametric closure"], "metadata": {"chunk_id": "decorators-parameter-004", "document_id": "decorators-parameter", "position": 4, "token_count": 229, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Parametric closure"], "file_path": "decorators/parameter.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/parameter", "title": "@parameter", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/parameter#parametric-closure"}}
{"chunk_id": "decorators-parameter-005", "document_id": "decorators-parameter", "content": "Note the `[_]` in the function type:\n\n```mojo\nfn use_closure[func: fn(Int) capturing [_] -> Int](num: Int) -> Int:\n```\n\nThis origin specifier represents the set of origins for the values captured by\nthe parametric closure. This allows the compiler to correctly extend the\nlifetimes of those values. For more information on lifetimes and origins, see\n[Lifetimes, origins and references](/mojo/manual/values/lifetimes).", "position": 5, "token_count": 102, "has_code": true, "section_hierarchy": ["Parametric closure"], "metadata": {"chunk_id": "decorators-parameter-005", "document_id": "decorators-parameter", "position": 5, "token_count": 102, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Parametric closure"], "file_path": "decorators/parameter.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/parameter", "title": "@parameter", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/parameter#parametric-closure"}}

{"chunk_id": "lifecycle-death-000", "document_id": "lifecycle-death", "content": "As soon as a value/object is no longer used, Mojo destroys it. Mojo does *not*\nwait until the end of a code block—or even until the end of an expression—to\ndestroy an unused value. It destroys values using an “as soon as possible”\n(ASAP) destruction policy that runs after every sub-expression. Even within an\nexpression like `a+b+c+d`, Mojo destroys the intermediate values as soon as\nthey're no longer needed.\n\nMojo uses static compiler analysis to find the point where a value is last used.\nThen, Mojo immediately ends the value's lifetime and calls the `__del__()`\ndestructor to perform any necessary cleanup for the type.\n\nFor example, notice when the `__del__()` destructor is called for each instance\nof `Balloon`:\n\n```mojo\n@fieldwise_init\nstruct Balloon(Writable):\n var color: String\n\n fn write_to(self, mut writer: Some[Writer]):\n writer.write(String(\"a \", self.color, \" balloon\"))\n\n fn __del__(deinit self):\n print(\"Destroyed\", String(self))\n\ndef main():\n var a = Balloon(\"red\")\n var b = Balloon(\"blue\")\n print(a)\n # a.__del__() runs here for \"red\" Balloon\n\n a = Balloon(\"green\")\n # a.__del__() runs immediately because \"green\" Balloon is never used\n\n print(b)\n # b.__del__() runs here\n\n```\n\n```output\na red balloon\nDestroyed a red balloon\nDestroyed a green balloon\na blue balloon\nDestroyed a blue balloon\n```\n\nNotice that each initialization of a value is matched with a call to the\ndestructor, and `a` is actually destroyed multiple times—once for each time it\nreceives a new value.\n\nAlso notice that this `__del__()` implementation doesn't actually do\nanything. Most structs don't require a custom destructor, and Mojo automatically\nadds a no-op destructor if you don't define one.", "position": 0, "token_count": 405, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "lifecycle-death-000", "document_id": "lifecycle-death", "position": 0, "token_count": 405, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death"}}
{"chunk_id": "lifecycle-death-001", "document_id": "lifecycle-death", "content": "dering how Mojo can destroy a type without a custom destructor, or\nwhy a no-op destructor is useful. If a type is simply a collection of fields,\nlike the `Balloon` example, Mojo only needs to destroy the fields: `Balloon` doesn't\ndynamically allocate memory or use any long-lived resources (like file handles).\nThere's no special action to take when a `Balloon` value is destroyed.\n\nWhen a `Balloon` value is destroyed, the `String` value in its `color` field is\nno longer used, and it is also immediately destroyed.\n\nThe `String` value is a little more complicated. Mojo strings are mutable. The\n`String` object has an internal buffer—a\n[`List`](/mojo/stdlib/collections/list/List) field,\nwhich holds the characters that make up the string. A `List` stores\nits contents in dynamically allocated memory on the heap, so the string can\ngrow or shrink. The string itself doesn't have any special destructor logic,\nbut when Mojo destroys a string, it calls the destructor for the\n`List` field, which de-allocates the memory.\n\nSince `String` doesn't require any custom destructor logic, it has a no-op\ndestructor: literally, a `__del__()` method that doesn't do anything.\nThis may seem pointless, but it means that Mojo can call the destructor on any\nvalue when its lifetime ends. This makes it easier to write generic containers\nand algorithms.\n\n### Benefits of ASAP destruction\n\nSimilar to oth", "position": 1, "token_count": 320, "has_code": false, "section_hierarchy": ["Default destruction behavior"], "metadata": {"chunk_id": "lifecycle-death-001", "document_id": "lifecycle-death", "position": 1, "token_count": 320, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Default destruction behavior"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#default-destruction-behavior"}}
{"chunk_id": "lifecycle-death-002", "document_id": "lifecycle-death", "content": "er languages, Mojo follows the principle that objects/values\nacquire resources in a constructor (`__init__()`) and release resources in a\ndestructor (`__del__()`). However, Mojo's ASAP destruction has some advantages\nover scope-based destruction (such as the C++ [RAII\npattern](https://en.cppreference.com/w/cpp/language/raii), which waits until\nthe end of the code scope to destroy values):\n\n* Destroying values immediately at last-use composes nicely with the \"move\"\n optimization, which transforms a \"copy+del\" pair into a \"move\" operation.\n\n* Destroying values at end-of-scope in C++ is problematic for some common\n patterns like tail recursion, because the destructor call happens after the\n tail call. This can be a significant performance and memory problem for\n certain functional programming patterns, which is not a problem in Mojo,\n because the destructor call always happens before the tail call.\n\nThe Mojo destruction policy is more similar to how Rust and Swift work, because\nthey both have strong value ownership tracking and provide memory safety. One\ndifference is that Rust and Swift require the use of a [dynamic \"drop\nflag\"](https://doc.rust-lang.org/nomicon/drop-flags.html)—they maintain hidden\nshadow variables to keep track of the state of your values to provide safety.\nThese are often optimized away, but the Mojo approach eliminates this overhead\nentirely, making the generated code faster and avoiding ambiguity.\n\n## Destructor\n\nMojo calls a value's destructor (`__de", "position": 2, "token_count": 315, "has_code": false, "section_hierarchy": ["Benefits of ASAP destruction"], "metadata": {"chunk_id": "lifecycle-death-002", "document_id": "lifecycle-death", "position": 2, "token_count": 315, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Benefits of ASAP destruction"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#benefits-of-asap-destruction"}}
{"chunk_id": "lifecycle-death-003", "document_id": "lifecycle-death", "content": "l__()` method) when the value's lifetime\nends (typically the point at which the value is last used). As we mentioned\nearlier, Mojo provides a default, no-op destructor for all types, so in most\ncases you don't need to define the `__del__()` method.\n\nYou should define the `__del__()` method to perform any kind of cleanup the\ntype requires. Usually, that includes freeing memory for any fields where you\ndynamically allocated memory (for example, via `UnsafePointer`) and\nclosing any long-lived resources such as file handles.\n\nHowever, any struct that is just a simple collection of other types does not\nneed to implement the destructor.\n\nFor example, consider this simple struct:\n\n```mojo\n@fieldwise_init\nstruct Balloons:\n var color: String\n var count: Int\n```\n\nThere's no need to define the `__del__()` destructor for this, because it's a\nsimple collection of other types (`String` and `Int`), and it doesn't\ndynamically allocate memory.\n\nWhereas, the following struct must define the `__del__()` method to free the\nmemory allocated by its\n[`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer):\n\n```mojo\nstruct HeapArray(Writable):\n var data: UnsafePointer[Int]\n var size: Int\n\n fn __init__(out self, *values: Int):\n self.size = len(values)\n self.data = UnsafePointer[Int].alloc(self.size)\n for i in range(self.size):\n (self.data + i).init_pointee_copy(values[i])\n\n fn write_to(self, mut writer: Some[Writer]):\n writer.write(\"[\")\n for i in range(self.size):\n writer.write(self.data[i])\n if i < self.size - 1:\n writer.write(\", \")\n writer.write(\"]\")", "position": 3, "token_count": 380, "has_code": true, "section_hierarchy": ["Destructor"], "metadata": {"chunk_id": "lifecycle-death-003", "document_id": "lifecycle-death", "position": 3, "token_count": 380, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Destructor"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#destructor"}}
{"chunk_id": "lifecycle-death-004", "document_id": "lifecycle-death", "content": " fn write_to(self, mut writer: Some[Writer]):\n writer.write(\"[\")\n for i in range(self.size):\n writer.write(self.data[i])\n if i < self.size - 1:\n writer.write(\", \")\n writer.write(\"]\")\n\n fn __del__(deinit self):\n print(\"Destroying\", self.size, \"elements\")\n for i in range(self.size):\n (self.data + i).destroy_pointee()\n self.data.free()\n\ndef main():\n var a = HeapArray(10, 1, 3, 9)\n print(a)\n```\n\n```output\n[10, 1, 3, 9]\nDestroying 4 elements\n```\n\nThe destructor takes its `self` argument using the `deinit`\n[argument convention](/mojo/manual/values/ownership#argument-conventions), which\ngrants exclusive ownership of the value and marks it as destroyed at the end of\nthe function. (For more information on the `deinit` convention, see\n[Field lifetimes during destruct and move](#field-lifetimes-during-destruct-and-move)).\n\nNote that a pointer doesn't *own* any values in the memory it points to, so\nwhen a pointer is destroyed, Mojo doesn't call the destructors on those values.\n\nSo in the `HeapArray` example above, calling `free()` on the pointer releases\nthe memory, but doesn't call the destructors on the stored values. To invoke\nthe destructors, use the `destroy_pointee()` method provided by the\n`UnsafePointer` type.\n\n[note]\nYou shouldn't call the destructor explicitly. If you need to ensure that a\ndestructor is called at a specific point, use the discard pattern described in\n[explicit lifetime extension](#explicit-lifetime-extension).", "position": 4, "token_count": 364, "has_code": true, "section_hierarchy": ["Destructor"], "metadata": {"chunk_id": "lifecycle-death-004", "document_id": "lifecycle-death", "position": 4, "token_count": 364, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Destructor"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#destructor"}}
{"chunk_id": "lifecycle-death-005", "document_id": "lifecycle-death", "content": "[note]\nYou shouldn't call the destructor explicitly. If you need to ensure that a\ndestructor is called at a specific point, use the discard pattern described in\n[explicit lifetime extension](#explicit-lifetime-extension).\n\nIt's important to notice that the `__del__()` method is an \"extra\" cleanup\nevent, and your implementation does not override any default destruction\nbehaviors. For example, Mojo still destroys all the fields in `Balloons` even\nif you add a `__del__()` method that to do nothing:\n\n```mojo\n@fieldwise_init\nstruct Balloons:\n var color: String\n var count: Int\n\n fn __del__(deinit self):\n # Mojo destroys all the fields when they're last used\n pass\n```\n\nHowever, the `self` value inside the `__del__()` destructor is still whole (so\nall fields are still usable) until the destructor returns, as we'll discuss\nmore in the following section.\n\nnote Destructors cannot raise errors\n\nCurrently a Mojo destructor isn't allowed to raise an error. This means that the\ndestructor must be defined as an `fn` function without the `raises` keyword.\nMojo won't allow you to define a destructor using `fn raises` or `def`.\n\n## Field lifetimes\n\nIn addition to tracking the lifetime of all objects in a program, Mojo also\ntracks each field of a structure independently. That is, Mojo keeps track of\nwhether a \"whole object\" is fully or partially initialized/destroyed", "position": 5, "token_count": 317, "has_code": true, "section_hierarchy": ["Destructor"], "metadata": {"chunk_id": "lifecycle-death-005", "document_id": "lifecycle-death", "position": 5, "token_count": 317, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Destructor"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#destructor"}}
{"chunk_id": "lifecycle-death-006", "document_id": "lifecycle-death", "content": ", and it\ndestroys each field independently with its ASAP destruction policy.\n\nFor example, consider this code that changes the value of a field:\n\n```mojo\n@fieldwise_init\nstruct Balloons:\n var color: String\n var count: Int\n\ndef main():\n var balloons = Balloons(\"red\", 5)\n print(balloons.color)\n # balloons.color.__del__() runs here, because this instance is\n # no longer used; it's replaced below\n\n balloons.color = \"blue\" # Overwrite balloons.color\n print(balloons.color)\n # balloons.__del__() runs here\n```\n\nThe `balloons.color` field is destroyed after the first `print()`, because Mojo\nknows that it will be overwritten below. You can also see this behavior when\nusing the transfer sigil:\n\n```mojo\nfn consume(var arg: String):\n pass\n\nfn use(arg: Balloons):\n print(arg.count, arg.color, \"balloons.\")\n\nfn consume_and_use():\n var balloons = Balloons(\"blue\", 8)\n consume(balloons.color^)\n # String.__moveinit__() runs here, which invalidates balloons.color\n # Now balloons is only partially initialized\n\n # use(balloons) # This fails because balloons.color is uninitialized\n\n balloons.color = String(\"orange\") # All together now\n use(balloons) # This is ok\n # balloons.__del__() runs here (and only if the object is whole)\n```\n\nNotice that the code transfers ownership of the `name` field to `consume()`.\nFor a period of time after that, the `name` field is uninitialized.\nThen `name` is reinitialized before it is passed to the `use()` function. If you\ntry calling `use()` before `name` is re-initialized, Mojo rejects the code\nwith an uninitialized field error.", "position": 6, "token_count": 382, "has_code": true, "section_hierarchy": ["Field lifetimes"], "metadata": {"chunk_id": "lifecycle-death-006", "document_id": "lifecycle-death", "position": 6, "token_count": 382, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Field lifetimes"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#field-lifetimes"}}
{"chunk_id": "lifecycle-death-007", "document_id": "lifecycle-death", "content": "Notice that the code transfers ownership of the `name` field to `consume()`.\nFor a period of time after that, the `name` field is uninitialized.\nThen `name` is reinitialized before it is passed to the `use()` function. If you\ntry calling `use()` before `name` is re-initialized, Mojo rejects the code\nwith an uninitialized field error.\n\nAlso, if you don't re-initialize the name by the end of the `pet` lifetime, the\ncompiler complains because it's unable to destroy a partially initialized\nobject.\n\nMojo's policy here is powerful and intentionally straight-forward: fields can\nbe temporarily transferred, but the \"whole object\" must be constructed with the\naggregate type's initializer and destroyed with the aggregate destructor. This\nmeans it's impossible to create an object by initializing only its fields, and\nit's likewise impossible to destroy an object by destroying only its fields.\n\n### Field lifetimes during destruct and move\n\nBoth the consuming move constructor and the destructor take their operand with\nthe `deinit` argument convention. This grants exclusive ownership of the value\nand marks it as destroyed at the end of the function. Within the function body,\nMojo’s ASAP policy st", "position": 7, "token_count": 250, "has_code": false, "section_hierarchy": ["Field lifetimes"], "metadata": {"chunk_id": "lifecycle-death-007", "document_id": "lifecycle-death", "position": 7, "token_count": 250, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Field lifetimes"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#field-lifetimes"}}
{"chunk_id": "lifecycle-death-008", "document_id": "lifecycle-death", "content": "ill applies to fields: each field is destroyed immediately\nafter its last use.\n\nJust to recap, the move constructor and destructor method signatures\nlook like this:\n\n```mojo\nstruct TwoStrings:\n fn __moveinit__(out self, deinit existing: Self):\n # Initializes a new `self` by consuming the contents of `existing`\n fn __del__(deinit self):\n # Destroys all resources in `self`\n```\n\nLike the `var` argument convention, the `deinit` convention gives the argument\nexclusive ownership of a value. But unlike a `var` argument, Mojo doesn't\ninsert a destructor call for the argument at the end of the function—because the\n`deinit` convention already marks it as a value that's in the process of being\ndestroyed.\n\nFor example, the following code shows how fields are destroyed inside a\ndestructor.\n\n```mojo\nfn consume(var str: String):\n print(\"Consumed\", str)\n\n@fieldwise_init\nstruct TwoStrings(Copyable, Movable):\n var str1: String\n var str2: String\n\n fn __del__(deinit self):\n # self value is whole at the beginning of the function\n self.dump()\n # After dump(): str2 is never used again, so str2.__del__() runs now\n\n consume(self.str1^)\n # self.str1 has been transferred so str1 becomes uninitialized, and\n # no destructor is called for str1.\n # self.__del__() is not called (avoiding an infinite loop).\n\n fn dump(mut self):\n print(\"str1:\", self.str1)\n print(\"str2:\", self.str2)\n\ndef main():\n var two_strings = TwoStrings(\"foo\", \"bar\")\n```\n\n## Explicit lifetime extension", "position": 8, "token_count": 357, "has_code": true, "section_hierarchy": ["Field lifetimes", "Field lifetimes during destruct and move"], "metadata": {"chunk_id": "lifecycle-death-008", "document_id": "lifecycle-death", "position": 8, "token_count": 357, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Field lifetimes", "Field lifetimes during destruct and move"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#field-lifetimes-during-destruct-and-move"}}
{"chunk_id": "lifecycle-death-009", "document_id": "lifecycle-death", "content": " fn dump(mut self):\n print(\"str1:\", self.str1)\n print(\"str2:\", self.str2)\n\ndef main():\n var two_strings = TwoStrings(\"foo\", \"bar\")\n```\n\n## Explicit lifetime extension\n\nMost of the time, Mojo’s ASAP destruction “just works.” Very rarely, you may\nneed to explicitly mark the last use of a value to control when its destructor\nruns. Think of this as an explicit last-use marker for the lifetime checker, not\na general-purpose pattern.\n\nYou might do this:\n\n- When writing tests that intentionally create otherwise-unused values (to avoid\n warnings", "position": 9, "token_count": 123, "has_code": true, "section_hierarchy": ["Field lifetimes", "Field lifetimes during destruct and move"], "metadata": {"chunk_id": "lifecycle-death-009", "document_id": "lifecycle-death", "position": 9, "token_count": 123, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Field lifetimes", "Field lifetimes during destruct and move"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#field-lifetimes-during-destruct-and-move"}}
{"chunk_id": "lifecycle-death-010", "document_id": "lifecycle-death", "content": "or dead-code elimination).\n\n- When writing unsafe/advanced code (for example, code that manipulates a\n value’s [origin](/mojo/manual/values/lifetimes)).\n\n- When you need deterministic destructor timing relative to specific side\n effects (such as logging or profiling).\n\nMark the last use by assigning the value to the `_` discard pattern at the point\nwhere it is okay to destroy it. This sets the last use at that line, so the\ndestructor runs immediately after the statement:\n\n```mojo\n# Without explicit extension: s is last used in the print() call, so it is\n# destroyed immediately afterwards.\nvar s = \"abc\"\nprint(s) # s.__del__() runs after this line\n\n# With explicit extension: push last-use to the discard line.\nvar t = \"xyz\"\nprint(t)\n\n# ... some time later\n_ = t # t.__del__() runs after this line\n```\n\n[note]\nPrevious versions of Mojo required the transfer sigil (`^`) when discarding a\nm", "position": 10, "token_count": 214, "has_code": true, "section_hierarchy": ["Explicit lifetime extension"], "metadata": {"chunk_id": "lifecycle-death-010", "document_id": "lifecycle-death", "position": 10, "token_count": 214, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Explicit lifetime extension"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#explicit-lifetime-extension"}}
{"chunk_id": "lifecycle-death-011", "document_id": "lifecycle-death", "content": "ove-only type. This is no longer required, since the compiler doesn't actua", "position": 11, "token_count": 17, "has_code": false, "section_hierarchy": ["Without explicit extension: s is last used in the print() call, so it is"], "metadata": {"chunk_id": "lifecycle-death-011", "document_id": "lifecycle-death", "position": 11, "token_count": 17, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Without explicit extension: s is last used in the print() call, so it is"], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#without-explicit-extension-s-is-last-used-in-the-print-call-so-it-is"}}
{"chunk_id": "lifecycle-death-012", "document_id": "lifecycle-death", "content": "lly\nmove the discarded value. For more information on the transfer sigil, see the\nsection on\n[ow", "position": 12, "token_count": 25, "has_code": false, "section_hierarchy": ["destroyed immediately afterwards."], "metadata": {"chunk_id": "lifecycle-death-012", "document_id": "lifecycle-death", "position": 12, "token_count": 25, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["destroyed immediately afterwards."], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#destroyed-immediately-afterwards"}}
{"chunk_id": "lifecycle-death-013", "document_id": "lifecycle-death", "content": "nership transfer](/mojo/manual/values/ownership#transfer-arguments-var-and-).", "position": 13, "token_count": 19, "has_code": false, "section_hierarchy": ["With explicit extension: push last-use to the discard line."], "metadata": {"chunk_id": "lifecycle-death-013", "document_id": "lifecycle-death", "position": 13, "token_count": 19, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["With explicit extension: push last-use to the discard line."], "file_path": "lifecycle/death.mdx", "url": "https://docs.modular.com/mojo/manual/lifecycle/death", "title": "Death of a value", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/lifecycle/death#with-explicit-extension-push-last-use-to-the-discard-line"}}

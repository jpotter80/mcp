{"chunk_id": "types-000", "document_id": "types", "content": "All values in Mojo have an associated data type. Most of the types are\n*nominal* types, defined by a [`struct`](/mojo/manual/structs). These types are\nnominal (or \"named\") because type equality is determined by the type's *name*,\nnot its *structure*.\n\nThere are some types that aren't defined as structs:\n\n* Functions are typed based on their signatures.\n* `NoneType` is a type with one instance, the `None` object, which is used to\n signal \"no value.\"\n\nMojo comes with a standard library that provides a number of useful types and\nutility functions. These standard types aren't privileged. Each of the standard\nlibrary types is defined just like user-defined types—even basic types like\n[`Int`](/mojo/stdlib/builtin/int/Int) and\n[`String`](/mojo/stdlib/collections/string/string/String). But these standard library\ntypes are the building blocks you'll use for most Mojo programs.\n\nThe most common types are *built-in types*, which are always available and\ndon't need to be imported. These include types for numeric values, strings,\nboolean values, and others.", "position": 0, "token_count": 245, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "types-000", "document_id": "types", "position": 0, "token_count": 245, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types"}}
{"chunk_id": "types-001", "document_id": "types", "content": "Mojo also has built-in types for integer, unsigned integer, and floating-point\nvalues of various precisions:\n\n<figure id=\"table-1\">\n\n| Type name | Description |\n| --------- | ----------------------------------------------------- |\n| `Int8` | 8-bit signed integer |\n| `UInt8` | 8-bit unsigned integer |\n| `Int16` | 16-bit signed integer |\n| `UInt16` | 16-bit unsigned integer |\n| `Int32` | 32-bit signed integer |\n| `UInt32` | 32-bit unsigned integer |\n| `Int64` | 64-bit signed integer |\n| `UInt64` | 64-bit unsigned integer |\n| `Int128` | 128-bit signed integer |\n| `UInt128` | 128-bit unsigned integer |\n| `Int256` | 256-bit signed integer |\n| `UInt256` | 256-bit unsigned integer |\n| `Float16` | 16-bit floating point number (IEEE 754-2008 binary16) |\n| `Float32` | 32-bit floating point number (IEEE 754-2008 binary32) |\n| `Float64` | 64-bit floating point number (IEEE 754-2008 binary64) |", "position": 1, "token_count": 256, "has_code": false, "section_hierarchy": ["Numeric types"], "metadata": {"chunk_id": "types-001", "document_id": "types", "position": 1, "token_count": 256, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Numeric types"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-types"}}
{"chunk_id": "types-002", "document_id": "types", "content": "<figcaption><b>Table 1.</b> Numeric types with specific precision</figcaption>\n</figure>\n\nThe types in Table 1 are actually all aliases to a single type,\n[`SIMD`](/mojo/stdlib/builtin/simd/SIMD), which is discussed later.\n\nAll of the numeric types support the usual numeric and bitwise operators. The\n[`math`](/mojo/stdlib/math/) module provides a number of additional math\nfunctions.\n\nYou may wonder when to use `Int` and when to use the other integer\ntypes. In general, `Int` is a good safe default when you need an integer type\nand you don't require a specific bit width. Using `Int` as the default integer\ntype for APIs makes APIs more consistent and predictable.\n\n### Signed and unsigned integers\n\nMojo supports both signed (`Int`) and unsigned (`UInt`) integers. You can use\nthe general `Int` or `UInt` types when you do not require a specific bit width.\nNote that any alias to a fixed-precision type will be of type\n[`SIMD`](/mojo/stdlib/builtin/simd/SIMD).", "position": 2, "token_count": 237, "has_code": false, "section_hierarchy": ["Numeric types"], "metadata": {"chunk_id": "types-002", "document_id": "types", "position": 2, "token_count": 237, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Numeric types"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-types"}}
{"chunk_id": "types-003", "document_id": "types", "content": "for a public API, or need\nadditional range.\n\nMojo's `UInt` type represents an unsigned integer of the\n[word size](https://en.wikipedia.org/wiki/Word_\\(computer_architecture\\)) of the\nCPU, which is 64 bits on 64-bit CPUs and 32 bits on 32-bit CPUs. If you wish to\nuse a fixed size unsigned integer, you can use `UInt8`, `UInt16`, `UInt32`, or\n`UInt64`, which are aliases to the [`SIMD`](/mojo/stdlib/builtin/simd/SIMD)\ntype.\n\nSigned and unsigned integers of the same bit width can represent the same number\nof values, but have different ranges. For example, an `Int8` can represent 256\nvalues ranging from -128 to 127. A `UInt8` can also represent 256 values, but\nrepresents a range of 0 to 255.\n\nSigned and unsigned integers also have different overflow behavior. When a\nsigned integer overflows outside the range of values that its type can\nrepresent, the value overflows to negative numbers. For example, adding `1` to\n`var si: Int8 = 127` results in `-128`.", "position": 3, "token_count": 256, "has_code": false, "section_hierarchy": ["Numeric types", "Signed and unsigned integers"], "metadata": {"chunk_id": "types-003", "document_id": "types", "position": 3, "token_count": 256, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Numeric types", "Signed and unsigned integers"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#signed-and-unsigned-integers"}}
{"chunk_id": "types-004", "document_id": "types", "content": "When an unsigned integer overflows outside the range of values that its type can\nrepresent, the value overflows to zero. So, adding `1` to `var ui: UInt8 = 255`\nis equal to `0`.\n\n### Floating-point numbers\n\nFloating-point types represent real numbers. Because not all real numbers can be\nexpressed in a finite number of bits, floating-point numbers can't represent\nevery value exactly.\n\nThe floating-point types listed in Table 1—`Float64`, `Float32`, and\n`Float16`—follow the IEEE 754-2008 standard for representing floating-point\nvalues. Each type includes a sign bit, one set of bits representing an expon", "position": 4, "token_count": 144, "has_code": false, "section_hierarchy": ["Numeric types", "Signed and unsigned integers"], "metadata": {"chunk_id": "types-004", "document_id": "types", "position": 4, "token_count": 144, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Numeric types", "Signed and unsigned integers"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#signed-and-unsigned-integers"}}
{"chunk_id": "types-005", "document_id": "types", "content": "ent,\nand another set representing the fraction or mantissa. Table 2 shows how each of\nthese types are represented in memory.\n\n<figure>\n\n| Type name | Sign | Exponent | Mantissa |\n| --------- | ----- | -------- | -------- |\n| `Float64` | 1 bit | 11 bits | 52 bits |\n| `Float32` | 1 bit | 8 bits | 23 bits |\n| `Float16` | 1 bit | 5 bits | 10 bits |\n\n<figcaption><b>Table 2.</b> Details of floating-point types</figcaption>\n</figure>\n\nNumbers with exponent values of all ones or all zeros represent special values,\nallowing floating-point numbers to represent infinity, negative infinity,\nsigned zeros, and not-a-number (NaN). For more details on how numbers are\nrepresented, see [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) on\nWikipedia.\n\nA few things to note with floating-point values:\n\n* Rounding errors. Rounding may produce unexpected results. For example, 1/3\n can't be represented exactly in these floating-point formats. The more\n operations you perform with floating-point numbers, the more the rounding\n errors accumulate.", "position": 5, "token_count": 255, "has_code": false, "section_hierarchy": ["Numeric types", "Floating-point numbers"], "metadata": {"chunk_id": "types-005", "document_id": "types", "position": 5, "token_count": 255, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Numeric types", "Floating-point numbers"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#floating-point-numbers"}}
{"chunk_id": "types-006", "document_id": "types", "content": "* Rounding errors. Rounding may produce unexpected results. For example, 1/3\n can't be represented exactly in these floating-point formats. The more\n operations you perform with floating-point numbers, the more the rounding\n errors accumulate.\n\n* Space between consecutive numbers. The space between consecutive numbers is\n variable across the range of a floating-point number format. For numbers close\n to zero, the distance between consecutive numbers is very small. For large\n positive and negative numbers, the space between consecutive numbers is\n greater than 1, so it may not be possible to represent consecutive integers.\n\nBecause the values are approximate, it is rarely useful to compare them with\nthe equality operator (`==`). Consider the following example:\n\n```mojo\nvar big_num = 1.0e16\nvar bigger_num = big_num+1.0\nprint(big_num == bigger_num)\n```\n\n```output\nTrue\n```\n\nComparison operators (`<` `>=` and so on) work with floating point numbers. You\ncan also use the [`math.isclose()`](/mojo/stdlib/math/math/isclose) function to\ncompare whether two floating-point numbers are equal within a specified\ntolerance.\n\n### Numeric literals", "position": 6, "token_count": 252, "has_code": true, "section_hierarchy": ["Numeric types", "Floating-point numbers"], "metadata": {"chunk_id": "types-006", "document_id": "types", "position": 6, "token_count": 252, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Numeric types", "Floating-point numbers"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#floating-point-numbers"}}
{"chunk_id": "types-007", "document_id": "types", "content": "the literal formats you can use to represent numbers.\n\n<figure>\n\n| Format | Examples | Notes |\n| ---------------------- | --------------- | ------------------------------------------------------------------------------------------------ |\n| Integer literal | `1760` | Integer literal, in decimal format. |\n| Hexadecimal literal | `0xaa`, `0xFF` | Integer literal, in hexadecimal format.<br />Hex digits are case-insensitive. |\n| Octal literal | `0o77` | Integer literal, in octal format. |\n| Binary literal | `0b0111` | Integer literal, in binary format. |\n| Floating-point literal | `3.14`, `1.2e9` | Floating-point literal.<br />Must include the decimal point to be interpreted as floating-point. |\n\n<figcaption><b>Table 3.</b> Numeric literal formats</figcaption>\n</figure>\n\nAt compile time, the literal types are arbitrary-precision (also called\ninfinite-precision) values, so the compiler can perform compile-time\ncalculations without overflow or rounding errors.", "position": 7, "token_count": 211, "has_code": false, "section_hierarchy": ["Numeric types", "Numeric literals"], "metadata": {"chunk_id": "types-007", "document_id": "types", "position": 7, "token_count": 211, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Numeric types", "Numeric literals"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-literals"}}
{"chunk_id": "types-008", "document_id": "types", "content": "At compile time, the literal types are arbitrary-precision (also called\ninfinite-precision) values, so the compiler can perform compile-time\ncalculations without overflow or rounding errors.\n\nAt runtime the values are converted to finite-precision types—`Int` for\ninteger values, and `Float64` for floating-point values. (This process of\nconverting a value that can only exist at compile time into a runtime value is\ncalled *materialization*.)\n\nThe following code sample shows the difference between an arbitrary-precision\ncalculation and the same calculation done using `Float64` values at runtime,\nwhich suffers from rounding errors.\n\n```mojo\nvar arbitrary_precision = 3.0 * (4.0 / 3.0 - 1.0)\n# use a variable to force the following calculation to occur at runtime\nvar three = 3.0\nvar finite_precision = three * (4.0 / three - 1.0)\nprint(arbitrary_precision, finite_precision)\n```\n\n```output\n1.0 0.99999999999999978\n```\n\n### `SIMD` and `DType`", "position": 8, "token_count": 237, "has_code": true, "section_hierarchy": ["Numeric types", "Numeric literals"], "metadata": {"chunk_id": "types-008", "document_id": "types", "position": 8, "token_count": 237, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Numeric types", "Numeric literals"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-literals"}}
{"chunk_id": "types-009", "document_id": "types", "content": "```output\n1.0 0.99999999999999978\n```\n\n### `SIMD` and `DType`\n\nTo support high-performance numeric processing, Mojo uses the\n[`SIMD`](/mojo/stdlib/builtin/simd/SIMD) type as the basis for its numeric\ntypes. SIMD (single instruction, multiple data) is a processor technology that\nallows you to perform an operation on an entire set of operands at once. Mojo's\n`SIMD` type abstracts SIMD operations. A `SIMD` value represents a SIMD\n*vector*—that is, a fixed-size array of values that can fit into a processor's\nregister. SIMD vectors are defined by two\n[*parameters*](/mojo/manual/parameters/):\n\n* A `DType` value, defining the d", "position": 9, "token_count": 171, "has_code": true, "section_hierarchy": ["Numeric types", "Numeric literals"], "metadata": {"chunk_id": "types-009", "document_id": "types", "position": 9, "token_count": 171, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Numeric types", "Numeric literals"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-literals"}}
{"chunk_id": "types-010", "document_id": "types", "content": "ata type in the vector (for example,\n 32-bit floating-point numbers).\n* The number of elements in the vector, which must be a power of two.\n\nFor example, you can define a vector of four `Float32` values like this:\n\n```mojo\nvar v", "position": 10, "token_count": 57, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime"], "metadata": {"chunk_id": "types-010", "document_id": "types", "position": 10, "token_count": 57, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#use-a-variable-to-force-the-following-calculation-to-occur-at-runtime"}}
{"chunk_id": "types-011", "document_id": "types", "content": "ec = SIMD[DType.float32, 4](3.0, 2.0, 2.0, 1.0)\n```\n\nMath operations on SIMD values are\napplied *elementwise*, on each individual element in the vector. For example:\n\n```mojo\nvar vec1 = SIMD[DType.int8, 4](2, 3, 5, 7)\nvar vec2 = SIMD[DType.int8, 4](1, 2, 3, 4)\nvar product = vec1 * vec2\nprint(product)\n```\n\n```output\n[2, 6, 15, 28]\n```\n\n### Scalar values\n\nThe `SIMD` module defines several *type aliases* that are shorthand for\ndifferent types of `SIMD` vectors. In particular, the `Scalar` type is just a\n`SIMD` vector with a single element. The numeric types listed in\n[Table 1](#table-1), like `Int8` and `Float32` are actually type aliases for\ndifferent types of scalar values:", "position": 11, "token_count": 229, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "`SIMD` and `DType`"], "metadata": {"chunk_id": "types-011", "document_id": "types", "position": 11, "token_count": 229, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "`SIMD` and `DType`"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#simd-and-dtype"}}
{"chunk_id": "types-012", "document_id": "types", "content": "```mojo\nalias Scalar = SIMD[size=1]\nalias Int8 = Scalar[DType.int8]\nalias Float32 = Scalar[DType.float32]\n```\n\nThis may seem a little confusing at first, but it means that whether you're\nworking with a single `Float32` value or a vector of float32 values,\nthe math operations go through exactly the same code path.\n\n#### The `DType` type\n\nThe `DType` struct describes the different data types that a `SIMD` vector can\nhold, and defines a number of utility functions for op", "position": 12, "token_count": 118, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "`SIMD` and `DType`"], "metadata": {"chunk_id": "types-012", "document_id": "types", "position": 12, "token_count": 118, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "`SIMD` and `DType`"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#simd-and-dtype"}}
{"chunk_id": "types-013", "document_id": "types", "content": "erating on those data\ntypes. The `DType` struct defines a set of aliases that act as identifiers for\nthe different data types, like `DType.int8` and `DType.float32`. You use\nthese aliases when declaring a `SIMD` vector:\n\n```mojo\nvar v: SIMD[DType.float64, 16]\n```\n\nNote that `DType.float64` isn't a *type*, it's a value that describes a data\ntype. You can't create a variable with the type `DType.float64`. You can create\na variable with the type `SIMD[DType.float64, 1]` (or `Float64`, which is the\nsame thing).\n\n```mojo\nfrom utils.numerics import max_finite, min_finite\n\ndef describeDType[dtype: DType]():\n print(dtype, \"is floating point:\", dtype.is_floating_", "position": 13, "token_count": 192, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Scalar values"], "metadata": {"chunk_id": "types-013", "document_id": "types", "position": 13, "token_count": 192, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Scalar values"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#scalar-values"}}
{"chunk_id": "types-014", "document_id": "types", "content": "point())\n print(dtype, \"is integral:\", dtype.is_integral())\n print(\"Min/max finite values for\", dtype)\n print(min_finite[dtype](), max_finite[dtype]())\n\ndescribeDType[DType.float32]()\n```\n\n```output\nfloat32 is floating point: True\nfloat32 is integral: False\nMin/max finite values for float32\n-3.4028234663852886e+38 3.4028234663852886e+38\n```\n\nThere are several other data types in the standard library that also use\nthe `DType` abstraction.\n\n### Numeric type conversion\n\n[Constructors and implicit conversion](/mojo/manual/lifecycle/life/#constructors-and-implicit-conversion)\ndocuments the circumstances in which Mojo automatically converts a value from\none type to another. Importantly, numeric [operators](/mojo/manual/operators)\n**don't** automatically narrow or widen operands to a common type.\n\nYou can explicitly convert a `SIMD` value to a different `SIMD` type either\nby invoking its [`cast()`](/mojo/stdlib/builtin/simd/SIMD#cast) method or by\npassing it as an argument to the constructor of the target type. For example:", "position": 14, "token_count": 258, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Scalar values", "The `DType` type"], "metadata": {"chunk_id": "types-014", "document_id": "types", "position": 14, "token_count": 258, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Scalar values", "The `DType` type"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#the-dtype-type"}}
{"chunk_id": "types-015", "document_id": "types", "content": "```mojo\nsimd1 = SIMD[DType.float32, 4](2.2, 3.3, 4.4, 5.5)\nsimd2 = SIMD[DType.int16, 4](-1, 2, -3, 4)\nsimd3 = simd1 * simd2.cast[DType.float32]() # Convert with cast() method\nprint(\"simd3:\", simd3)\nsimd4 = simd2 + SIMD[DType.int16, 4](simd1", "position": 15, "token_count": 105, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Scalar values", "The `DType` type"], "metadata": {"chunk_id": "types-015", "document_id": "types", "position": 15, "token_count": 105, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Scalar values", "The `DType` type"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#the-dtype-type"}}
{"chunk_id": "types-016", "document_id": "types", "content": ") # Convert with SIMD constructor\nprint(\"simd4:\", simd4)\n```\n\n```output\nsimd3: [-2.2, 6.6, -13.200001, 22.0]\nsimd4: [1, 5, 1, 9]\n```\n\nYou can convert a `Scalar` value by passing it as an argument to the constructor\nof the target type. For example:\n\n```mojo\nvar my_int: Int16 = 12 # SIMD[DType.int16, 1]\nvar my_float: Float32 = 0.75 # SIMD[DType.float32, 1]\nresult = Float32(my_int) * my_float # Result is SIMD[DType.float32, 1]\nprint(\"Result:\", result)\n```\n\n```output\nResult: 9.0\n```", "position": 16, "token_count": 172, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Numeric type conversion"], "metadata": {"chunk_id": "types-016", "document_id": "types", "position": 16, "token_count": 172, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Numeric type conversion"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-type-conversion"}}
{"chunk_id": "types-017", "document_id": "types", "content": "```output\nResult: 9.0\n```\n\nYou can convert a scalar value of any numeric type to `Int` by passing the value\nto the [`Int()`](/mojo/stdlib/builtin/int/Int#__init__) constructor method.\nAdditionally, you can pass an instance of any struct that implements the\n[`Intable`](/mojo/stdlib/builtin/int/Intable) trait or\n[`IntableRaising`](/mojo/stdlib/builtin/int/IntableRaising) trait to the `Int()`\nconstructor to convert that instance to an `Int`.\n\nYou can convert an `Int` or `IntLiteral` value to the `UInt` type by passing the\nvalue to the [`UInt()`](/mojo/stdlib/builtin/uint/UInt#__init__) constructor.\nYou can't convert other numeric types to `UInt` directly, though you can first\nconvert them to `Int` and then to `UInt`.\n\n## Strings\n\nMojo's `String` type represents a mutable string. (For Python programmers, note\nthat this is different from Python's standard string, which is immutable.)\nStrings support a variety of operators and common methods.", "position": 17, "token_count": 245, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Numeric type conversion"], "metadata": {"chunk_id": "types-017", "document_id": "types", "position": 17, "token_count": 245, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Numeric type conversion"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-type-conversion"}}
{"chunk_id": "types-018", "document_id": "types", "content": "## Strings\n\nMojo's `String` type represents a mutable string. (For Python programmers, note\nthat this is different from Python's standard string, which is immutable.)\nStrings support a variety of operators and common methods.\n\n```mojo\nvar s: String = \"Testing\"\ns += \" Mojo strings\"\nprint(s)\n```\n\n```output\nTesting Mojo strings\n```\n\nMost standard library types conform to the\n[`Stringable`](/mojo/stdlib/builtin/str/Stringable) trait, which represents\na type that can be converted to a string. Use `String(value)` to\nexplicitly convert a value to a string:\n\n```mojo\nvar s = \"Items in list: \" + String(5)\nprint(s)\n```\n\n```output\nItems in list: 5\n```\n\nOr use `String.write` to take variadic `Stringable` types, so you don't have to\ncall `String()` on each value:\n\n```mojo\nvar s = String(\"Items in list: \", 5)\nprint(s)\n```\n\n```output\nItems in list: 5\n```\n\n### String", "position": 18, "token_count": 235, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Numeric type conversion"], "metadata": {"chunk_id": "types-018", "document_id": "types", "position": 18, "token_count": 235, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Numeric type conversion"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#numeric-type-conversion"}}
{"chunk_id": "types-019", "document_id": "types", "content": "literals\n\nAs with numeric types, the standard library includes a string literal type used\nto represent literal strings in the program source. String literals are\nenclosed in either single or double quotes.\n\nAdjacent literals are concatenated together, so you can define a long string\nusing a series of literals broken up over several lines:\n\n```\nalias s = \"A very long string which is \"\n \"broken into two literals for legibility.\"\n```\n\nTo define a multi-line string, enclose the literal in three single or double\nquotes:\n\n```\nalias s = \"\"\"\nMulti-line string literals let you\nenter long blocks of text, including\nnewlines.\"\"\"\n```\n\nNote that the triple double quote form is also used for API documentation\nstrings.\n\nA `StringLiteral` will materialize to a `String` when used at run-time:\n\n```mojo\nalias param = \"foo\" # type = StringLiteral\nvar runtime_v", "position": 19, "token_count": 188, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Strings"], "metadata": {"chunk_id": "types-019", "document_id": "types", "position": 19, "token_count": 188, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Strings"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#strings"}}
{"chunk_id": "types-020", "document_id": "types", "content": "alue = \"bar\" # type = String\nvar runtime_value2 = param # type = String\n```\n\n## Booleans\n\nMojo's `Bool` type represents a boolean value. It can take one of two values,\n`True` or `False`. You can negate a boolean value using the `not` operator.\n\n```mojo\nvar conditionA = False\nvar conditionB: Bool\nconditionB = not conditionA\nprint(conditionA, conditionB)\n```\n\n```output\nFalse True\n```\n\nMany types have a boolean representation. Any type that implements the\n[`Boolable`](/mojo/stdlib/builtin/bool/Boolable) trait has a boolean\nrepresentation. As a general principle, collections evaluate as True if they\ncontain any elements, False if they are empty; strings evaluate as True if they\nhave a non-zero length.\n\n## Tuples\n\nMojo's `Tuple` type represents an immutable tuple consisting of zero or more\nvalues, separated by commas. Tuples can consist of multiple types and you can\nindex into tuples in multiple ways.\n\n```mojo\n# Tuples are immutable and can hold", "position": 20, "token_count": 236, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Strings", "String literals"], "metadata": {"chunk_id": "types-020", "document_id": "types", "position": 20, "token_count": 236, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Strings", "String literals"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#string-literals"}}
{"chunk_id": "types-021", "document_id": "types", "content": "multiple types\nexample_tuple = Tuple[Int, String](1, \"Example\")\n\n# Assign multiple variables at once\nx, y = example_tuple\nprint(x, y)\n\n# Get individual values with an index\ns = example_tuple[1]\nprint(s)\n```\n\n```output\n1 Example\nExample\n```\n\nYou can also create a tuple without explicit typing.\n\n```mojo\nexample_tuple = (1, \"Example\")\ns = example_tuple[1]\nprint(s)\n```\n\n```output\nExample\n```\n\nWhen defining a function, you can explicitly declare the type of tuple elements\nin one of two ways:\n\n```mojo\ndef return_tuple_1() -> Tuple[Int, Int]:\n return Tuple[Int, Int](1, 1)\n\ndef return_tuple_2() -> (Int, Int):\n return (2, 2)\n```\n\n#", "position": 21, "token_count": 177, "has_code": true, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Booleans"], "metadata": {"chunk_id": "types-021", "document_id": "types", "position": 21, "token_count": 177, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Booleans"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#booleans"}}
{"chunk_id": "types-022", "document_id": "types", "content": "# Collection types\n\nThe Mojo standard library also includes a set of basic collection types that\ncan be used to build more complex data structures:\n\n* [`List`](/mojo/stdlib/collections/list/List), a dynamically-", "position": 22, "token_count": 45, "has_code": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Tuples"], "metadata": {"chunk_id": "types-022", "document_id": "types", "position": 22, "token_count": 45, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["use a variable to force the following calculation to occur at runtime", "Tuples"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#tuples"}}
{"chunk_id": "types-023", "document_id": "types", "content": "sized array of\n items.\n* [`Dict`](/mojo/stdlib/collections/dict/Dict), an associative array of\n key-v", "position": 23, "token_count": 30, "has_code": false, "section_hierarchy": ["Tuples are immutable and can hold multiple types"], "metadata": {"chunk_id": "types-023", "document_id": "types", "position": 23, "token_count": 30, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Tuples are immutable and can hold multiple types"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#tuples-are-immutable-and-can-hold-multiple-types"}}
{"chunk_id": "types-024", "document_id": "types", "content": "alue pairs.\n* [`Set`](/mojo/stdlib/collections/set/Set), an unordered", "position": 24, "token_count": 19, "has_code": false, "section_hierarchy": ["Assign multiple variables at once"], "metadata": {"chunk_id": "types-024", "document_id": "types", "position": 24, "token_count": 19, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Assign multiple variables at once"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#assign-multiple-variables-at-once"}}
{"chunk_id": "types-025", "document_id": "types", "content": "collection of unique\n items.\n* [`Optional`](/mojo/stdlib/collections/optional/Optional)\n represents a value that may or may not be present.\n\nThe collection types are *generic types*: while a given collection can only\nhold a specific type of value (such as `Int` or `Float64`), you specify the\ntype at compile time using a [parameter](/mojo/manual/parameters/). For\nexample, you can create a `List` of `Int` values like this:\n\n```mojo\nvar l: List[Int] = [1, 2, 3, 4]\n# l.append(3.14) # error: FloatLit", "position": 25, "token_count": 142, "has_code": true, "section_hierarchy": ["Get individual values with an index"], "metadata": {"chunk_id": "types-025", "document_id": "types", "position": 25, "token_count": 142, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Get individual values with an index"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#get-individual-values-with-an-index"}}
{"chunk_id": "types-026", "document_id": "types", "content": "eral cannot be converted to Int\n```\n\nYou don't always need to specify the type explicitly. If Mojo can *infer* the\ntype, you can omit it. For example, when you construct a list from a set of\ninteger literals, Mojo creates a `List[Int]`.\n\n```mojo\n# Inferred type == List[Int]\nvar l1 = [1, 2, 3, 4]\n```\n\nWhere you need a more flexible collection, the\n[`Variant`](/mojo/stdlib/utils/variant/Variant) type can hold different types\nof values. For example, a `Variant[Int32, Float64]` can hold either an `Int32`\n*or* a `Float64` value at any given time. (Using `Variant` is not covered in\nthis section, see the [API docs](/mojo/stdlib/utils/variant/Variant) for more\ninformation.)\n\nThe following sections give brief introduction to the main collection types.\n\n### List\n\n[`List`](/mojo/stdlib/collections/list/List) is a dynamically-sized array of\nelements. Li", "position": 26, "token_count": 230, "has_code": true, "section_hierarchy": ["Get individual values with an index", "Collection types"], "metadata": {"chunk_id": "types-026", "document_id": "types", "position": 26, "token_count": 230, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Get individual values with an index", "Collection types"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#collection-types"}}
{"chunk_id": "types-027", "document_id": "types", "content": "st elements need to conform to the\n[`Copyable`](/mojo/stdlib/builtin/value/Copyable) and\n[`Movable`](/mojo/stdlib/builtin/value/Movable) traits. Most of the common\nstandard library primitives, like `Int`, `String`, and `SIMD` conform to this\ntrait. You can create a `List` by pass", "position": 27, "token_count": 79, "has_code": false, "section_hierarchy": ["l.append(3.14) # error: FloatLiteral cannot be converted to Int"], "metadata": {"chunk_id": "types-027", "document_id": "types", "position": 27, "token_count": 79, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["l.append(3.14) # error: FloatLiteral cannot be converted to Int"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#lappend314--error-floatliteral-cannot-be-converted-to-int"}}
{"chunk_id": "types-028", "document_id": "types", "content": "ing the element type as a parameter, like\nthis:\n\n```mojo\nvar l = List[String]()\n```\n\nThe `List` type supports a subset of the Python `list` API, including the\nability to append to the list, pop items out of the list, and access list items\nusing subscript notation.\n\n```mojo\nvar list = [2, 3, 5]\nlist.append(7)\nlist.append(11)\nprint(\"Popping last item from list: \", list.pop())\nfor idx in range(len(list)):\n print(list[idx], end=\", \")\n\n```\n\n```output\nPopping last item from list: 11\n2, 3, 5, 7,\n```\n\nNote that", "position": 28, "token_count": 149, "has_code": true, "section_hierarchy": ["Inferred type == List[Int]"], "metadata": {"chunk_id": "types-028", "document_id": "types", "position": 28, "token_count": 149, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Inferred type == List[Int]"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#inferred-type--listint"}}
{"chunk_id": "types-029", "document_id": "types", "content": "the previous code sample leaves out the type parameter when creating\nthe list. Because the list is being created with a set of `Int` values, Mojo can\n*infer* the type from the arguments.\n\n* Mojo supports list, set, and dictionary literals for collection initialization:\n\n ```mojo\n # List literal, element type infers to Int.\n var nums = [2, 3, 5]\n ```\n\n You can also use an explicit type if you want a specific element type:\n\n ```mojo\n var list : List[UInt8] = [2, 3, 5]\n ```\n\n You can also use list \"comprehensions\" for compact conditional initialization:\n\n ```mojo\n var list2 = [x*Int(y) for x in nums for y in list if x != 3]\n ```\n\n* You can't `print()` a list, or convert it directly into a string.\n\n ```mojo\n # Does not work\n print(list)\n ```\n\n As shown above, you can print the individual elements in a list as long as\n they're a [`Stringable`](/mojo/stdlib/builtin/str/Stringable) type.", "position": 29, "token_count": 239, "has_code": true, "section_hierarchy": ["Inferred type == List[Int]", "List"], "metadata": {"chunk_id": "types-029", "document_id": "types", "position": 29, "token_count": 239, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Inferred type == List[Int]", "List"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#list"}}
{"chunk_id": "types-030", "document_id": "types", "content": " As shown above, you can print the individual elements in a list as long as\n they're a [`Stringable`](/mojo/stdlib/builtin/str/Stringable) type.\n\n* Iterating a `List` returns an immutable\n [reference](/mojo/manual/values/lifetimes#working-with-references) to each\n item:\n\n```mojo\nvar list = [2, 3, 4]\nfor item in list:\n print(item, end=\", \")\n```\n\n```output\n2, 3, 4,\n```\n\nIf you would like to mutate the elements of the list, capture the reference to\nthe element with `ref` instead of making a copy:\n\n```mojo\nvar list = [2, 3, 4]\nfor ref item in list: # Capture a ref to the list element\n print(item, end=\", \")\n item = 0 # Mutates the element inside the list\nprint(\"\\nAfter loop:\", list[0], list[1], list[2])\n```\n\n```output\n2, 3, 4,\nAfter loop: 0 0 0\n```\n\nYou can see that the original loop entries were modified.\n\n### Dict", "position": 30, "token_count": 248, "has_code": true, "section_hierarchy": ["Inferred type == List[Int]", "List"], "metadata": {"chunk_id": "types-030", "document_id": "types", "position": 30, "token_count": 248, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Inferred type == List[Int]", "List"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#list"}}
{"chunk_id": "types-031", "document_id": "types", "content": "```output\n2, 3, 4,\nAfter loop: 0 0 0\n```\n\nYou can see that the original loop entries were modified.\n\n### Dict\n\nThe [`Dict`](/mojo/stdlib/collections/dict/Dict) type is an associative array\nthat holds key-value pairs. You can create a `Dict` by specifying the key type\nand value type as parameters and using dictionary literals:\n\n```mojo\n# Empty dictionary\nvar empty_dict: Dict[String, Float64] = {}\n\n# Dictionary with initial key-value pairs\nvar values: Dict[String, Float64] = {\"pi\": 3.14159, \"e\": 2.71828}\n```\n\nYou can also use the constructor syntax:\n\n```mojo\nvar values = Dict[String, Float64]()\n```\n\nThe dictionary's key type must conform to the\n[`KeyElement`](/mojo/stdlib/collections/dict/#keyelement) trait, and value\nelements must conform to the [`Copyable`](/mojo/stdlib/builtin/value/Copyable)\nand [`Movable`](/mojo/stdlib/builtin/value/Movable) traits.", "position": 31, "token_count": 240, "has_code": true, "section_hierarchy": ["Inferred type == List[Int]", "List"], "metadata": {"chunk_id": "types-031", "document_id": "types", "position": 31, "token_count": 240, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Inferred type == List[Int]", "List"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#list"}}
{"chunk_id": "types-032", "document_id": "types", "content": "eld\n[references](/mojo/manual/values/lifetimes#working-with-references), which are\ncopied into the declared name by default, but you can use the `ref` marker to\navoid the copy:\n\n```mojo\nvar d: Dict[String, Float64] = {\n \"plasticity\": 3.", "position": 32, "token_count": 69, "has_code": true, "section_hierarchy": ["Inferred type == List[Int]", "Dict"], "metadata": {"chunk_id": "types-032", "document_id": "types", "position": 32, "token_count": 69, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Inferred type == List[Int]", "Dict"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#dict"}}
{"chunk_id": "types-033", "document_id": "types", "content": "1,\n \"elasticity\": 1.3,\n \"electricity\": 9.7\n}\nfor item in d.item", "position": 33, "token_count": 26, "has_code": false, "section_hierarchy": ["Empty dictionary"], "metadata": {"chunk_id": "types-033", "document_id": "types", "position": 33, "token_count": 26, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Empty dictionary"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#empty-dictionary"}}
{"chunk_id": "types-034", "document_id": "types", "content": "s():\n print(item.key, item.value)\n```\n\n```output\nplasticity 3.1000000000000001\nelasticity 1.3\nelectricity 9.6999999999999993\n```\n\nThis is an unmeasurable micro-optimization in this case, but is useful when\nworking with types that aren't `Copyable`.\n\n### Set\n\nThe [`Set`](/mojo/stdlib/collections/set/Set) type represents a set of unique\nvalues. You can add and remove elements from the set, test whether a value\nexists in the set, and perform set algebra operations, like unions and\nintersections between two sets.\n\nSets are generic and the element type must conform to the\n[`KeyElement`](/mojo/stdlib/collections/dict/#keyelement) trait. Like lists and\ndictionaries, sets support standard literal syntax, as well as generator\ncomprehensions:\n\n```mojo\ni_like = {\"sushi\", \"ice cream\", \"tacos\", \"pho\"}\nyou_like = {\"burgers\", \"tacos\", \"salad\", \"ice cream\"}\nwe_like = i_like.intersection(you_like)", "position": 34, "token_count": 244, "has_code": true, "section_hierarchy": ["Dictionary with initial key-value pairs"], "metadata": {"chunk_id": "types-034", "document_id": "types", "position": 34, "token_count": 244, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Dictionary with initial key-value pairs"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#dictionary-with-initial-key-value-pairs"}}
{"chunk_id": "types-035", "document_id": "types", "content": "any type that conforms to the\n[`Copyable`](/mojo/stdlib/builtin/value/Copyable) and\n[`Movable`](/mojo/stdlib/builtin/value/Movable) traits.\n\n```mojo\n# Two ways to initialize an Optional with a value\nvar opt1 = Optional(5)\nvar opt2: Optional[Int] = 5\n# Two ways to initialize an Optional with no value\nvar opt3 = Optional[Int]()\nvar opt4: Optional[Int] = None\n```\n\nAn `Optional` evaluates as `True` when it holds a value, `False` otherwise. If\nthe `Optional` holds a value, you can retrieve a reference to the value using\nthe `value()` method. But calling `value()` on an `Optional` with no value\nresults in undefined behavior, so you should always guard a call to `value()`\ninside a conditional that checks whether a value exists.\n\n```mojo\nvar opt: Optional[Strin", "position": 35, "token_count": 204, "has_code": true, "section_hierarchy": ["Dictionary with initial key-value pairs", "Set"], "metadata": {"chunk_id": "types-035", "document_id": "types", "position": 35, "token_count": 204, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Dictionary with initial key-value pairs", "Set"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#set"}}
{"chunk_id": "types-036", "document_id": "types", "content": "g] = \"Testing\"\nif opt:\n var value_ref = opt.value()\n print(value_ref)\n```\n\n```output\nTesting\n```\n\nAlternately, you can use the `or_else()` method, which returns the stored\nvalue if there is one, or a user-specified default value otherwise:\n\n```mojo\nvar custom_greeting: Optional[String] = None\nprint(custom_greeting.or_else(\"Hello\"))\n\nc", "position": 36, "token_count": 87, "has_code": true, "section_hierarchy": ["Dictionary with initial key-value pairs", "Optional"], "metadata": {"chunk_id": "types-036", "document_id": "types", "position": 36, "token_count": 87, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Dictionary with initial key-value pairs", "Optional"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#optional"}}
{"chunk_id": "types-037", "document_id": "types", "content": "ustom_greeting = \"Hi\"\nprint(custom_greeting.or_else(\"Hello\"))\n\n```\n\n```output\nHello\nHi\n```\n\n## Regist", "position": 37, "token_count": 30, "has_code": true, "section_hierarchy": ["Two ways to initialize an Optional with a value"], "metadata": {"chunk_id": "types-037", "document_id": "types", "position": 37, "token_count": 30, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Two ways to initialize an Optional with a value"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#two-ways-to-initialize-an-optional-with-a-value"}}
{"chunk_id": "types-038", "document_id": "types", "content": "er-passable, memory-only, and trivial types\n\nIn various places in the documentation you'll see references to\nregister-passable, memory-only, and trivial types. Register-passable and\nmemory-only types are distinguished based on how they hold data:\n\n* Register-passable types are composed exclusively of fixed-size data types,\n which can (theoretically) be stored in a machine register. A register-passable\n type can include other types, as long as they are also register-passable.\n `Int`, `Bool`, and `SIMD`, for example, are all register-passable types. So\n a register-passable `struct` could include `Int` and `Bool` fields, but not a\n `String` field. Register-passable types are declared with the\n [`@register_passable`](/mojo/manual/decorators/register-passable) decorator.\n\n* Memory-only types consist of all other types that *aren't* specifically\n designated as register-passable types. These types often have pointers or\n references to dynam", "position": 38, "token_count": 211, "has_code": false, "section_hierarchy": ["Two ways to initialize an Optional with no value"], "metadata": {"chunk_id": "types-038", "document_id": "types", "position": 38, "token_count": 211, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Two ways to initialize an Optional with no value"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#two-ways-to-initialize-an-optional-with-no-value"}}
{"chunk_id": "types-039", "document_id": "types", "content": "ically-allocated memory. `String`, `List`, and `Dict` are\n all examples of memory-only types.\n\nRegister-passable types have a slightly different lifecycle than memory-only\ntypes, which is discussed in [Life of a value](/mojo/manual/lifecycle/life/).\n\nThere are also a number of low-level differences in how the Mojo compiler treats\nregister-passable types versus memory-only types, which you probably won't have\nto think about for most Mojo programming. For more information, see\nthe [`@register_passable`](/mojo/manual/decorators/register-passable) decorator\nreference.\n\nOur long-term goal is to make this distinction transparent to the user, and\nensure all APIs work with both register-passable and memory-only types.\nBut right now you will see a few standard library types that only work with\nregister-passable types or only work with memory-only types.", "position": 39, "token_count": 185, "has_code": false, "section_hierarchy": ["Two ways to initialize an Optional with no value", "Register-passable, memory-only, and trivial types"], "metadata": {"chunk_id": "types-039", "document_id": "types", "position": 39, "token_count": 185, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Two ways to initialize an Optional with no value", "Register-passable, memory-only, and trivial types"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#register-passable-memory-only-and-trivial-types"}}
{"chunk_id": "types-040", "document_id": "types", "content": "In addition to these two categories, Mojo also has \"trivial\" types. Conceptually\na trivial type is simply a type that doesn't require any custom logic in its\nlifecycle methods. The bits that make up an instance of a trivial type can be\ncopied or moved without any knowledge of what they do. Currently, trivial types\nare declared using the\n[`@register_passable(trivial)`](/mojo/manual/decorators/register-passable#register_passabletrivial)\ndecorator. Trivial types shouldn't be limited to only register-passable types,\nso in the future we intend to separate trivial types from the\n`@register_passable` decorator.\n\n## `AnyType` and `AnyTrivialRegType`\n\nTwo other things you'll see in Mojo APIs are references to `AnyType` and\n`AnyTrivialRegType`. These are effectively *metatypes*, that is, types of types.", "position": 40, "token_count": 192, "has_code": false, "section_hierarchy": ["Two ways to initialize an Optional with no value", "Register-passable, memory-only, and trivial types"], "metadata": {"chunk_id": "types-040", "document_id": "types", "position": 40, "token_count": 192, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Two ways to initialize an Optional with no value", "Register-passable, memory-only, and trivial types"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#register-passable-memory-only-and-trivial-types"}}
{"chunk_id": "types-041", "document_id": "types", "content": "Two other things you'll see in Mojo APIs are references to `AnyType` and\n`AnyTrivialRegType`. These are effectively *metatypes*, that is, types of types.\n\n* `AnyType` is a trait that represents a type with a destructor. You'll find\n more discussion of it on the\n [Traits page](/mojo/manual/traits#the-anytype-trait).\n* `AnyTrivialRegType` is a metatype representing any Mojo type that's marked\n as a trivial type.\n\nYou'll see them in signatures like this:\n\n```mojo\nfn any_type_function[ValueType: AnyTrivialRegType](value: ValueType):\n ...\n```\n\nYou can read this as `any_type_function` has an argument, `value` of type\n`ValueType`, where `ValueType` is a register-passable type, determined at\ncompile time.\n\nThere is still some code like this in the standard library, but it's gradually\nbeing migrated to more generic code that doesn't distinguish between\nregister-passable and memory-only types.", "position": 41, "token_count": 218, "has_code": true, "section_hierarchy": ["Two ways to initialize an Optional with no value", "Register-passable, memory-only, and trivial types"], "metadata": {"chunk_id": "types-041", "document_id": "types", "position": 41, "token_count": 218, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Two ways to initialize an Optional with no value", "Register-passable, memory-only, and trivial types"], "file_path": "types.mdx", "url": "https://docs.modular.com/mojo/manual/types", "title": "Types", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/types#register-passable-memory-only-and-trivial-types"}}

{"chunk_id": "traits-000", "document_id": "traits", "content": "A *trait* is a set of requirements that a type must implement. You can think of\nit as a contract: a type that *conforms* to a trait guarantees that it\nimplements all of the features of the trait.\n\nTraits are similar to Java *interfaces*, C++ *concepts*, Swift *protocols*, and\nRust *traits*. If you're familiar with any of those features, Mojo traits solve\nthe same basic problem.\n\nYou've probably already seen some traits, like `Copyable` and `Movable`, used in\nexample code. This section describes how traits work, how to use existing\ntraits, and how to define your own traits.", "position": 0, "token_count": 138, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "traits-000", "document_id": "traits", "position": 0, "token_count": 138, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits"}}
{"chunk_id": "traits-001", "document_id": "traits", "content": "## Background\n\nIn dynamically-typed languages like Python, you don't need to explicitly declare\nthat two classes are similar. This is easiest to show by example:\n\n```python title=\"ðŸ Python\"\nclass Duck:\n def quack(self):\n print(\"Quack.\")\n\nclass StealthCow:\n def quack(self):\n print(\"Moo!\")\n\ndef make_it_quack(maybe_a_duck):\n try:\n maybe_a_duck.quack()\n except:\n print(\"Not a duck.\")\n\nmake_it_quack(Duck())\nmake_it_quack(StealthCow())\n```\n\nThe `Duck` and `StealthCow` classes aren't related in any way, but they both\ndefine a `quack()` method, so they work the same in the `make_it_quack()`\nfunction. This works because Python uses dynamic dispatchâ€”it identifies the\nmethods to call at runtime. So `make_it_quack()` doesn't care what types\nyou're passing it, only the fact that they implement the `quack()` method.\n\nIn a statically-typed environment, this approach doesn't work:\nMojo functions require you to\nspecify the type of each argument. If you wanted to write this example in Mojo\n*without* traits, you'd need to write a function overload for each input type.\n\n```mojo title=\"ðŸ”¥ Mojo\"\n@fieldwise_init\nstruct Duck(Copyable, Movable):\n fn quack(self):\n print(\"Quack\")\n\n@fieldwise_init\nstruct StealthCow(Copyable, Movable):\n fn quack(self):\n print(\"Moo!\")\n\nfn make_it_quack(definitely_a_duck: Duck):\n definitely_a_duck.quack()\n\nfn make_it_quack(not_a_duck: StealthCow):\n not_a_duck.quack()\n\nmake_it_quack(Duck())\nmake_it_quack(StealthCow())\n```\n\n```output\nQuack\nMoo!\n```", "position": 1, "token_count": 393, "has_code": true, "section_hierarchy": ["Background"], "metadata": {"chunk_id": "traits-001", "document_id": "traits", "position": 1, "token_count": 393, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Background"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#background"}}
{"chunk_id": "traits-002", "document_id": "traits", "content": "fn make_it_quack(definitely_a_duck: Duck):\n definitely_a_duck.quack()\n\nfn make_it_quack(not_a_duck: StealthCow):\n not_a_duck.quack()\n\nmake_it_quack(Duck())\nmake_it_quack(StealthCow())\n```\n\n```output\nQuack\nMoo!\n```\n\nThis isn't too bad with only two types. But the more types you want to\nsupport, the less practical this approach is.\n\nYou might notice that the Mojo versions of `make_it_quack()` don't include the\n`try/except` statement. We don't need it because Mojo's static type checking\nensures that you can only pass instances of `Duck` or `StealthCow` into the\n`make_it_quack()`function.\n\n## Using traits\n\nTraits solve this problem by letting you define a", "position": 2, "token_count": 177, "has_code": true, "section_hierarchy": ["Background"], "metadata": {"chunk_id": "traits-002", "document_id": "traits", "position": 2, "token_count": 177, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Background"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#background"}}
{"chunk_id": "traits-003", "document_id": "traits", "content": "shared set of *behaviors* that\ntypes can implement. Then you can write a function that depends on the trait,\nrather than individual types. As an example, let's update the `make_it_quack()`\nexample using traits. This will involve three steps:\n\n1. Defining a new `Quackable` trait.\n2. Adding the trait to the `Duck` and `StealthCow` structs.\n3. Updating the `make_it_quack()` function to depend on the trait.\n\n### Defining a trait\n\nThe first step is defining a trait that requ", "position": 3, "token_count": 119, "has_code": false, "section_hierarchy": ["Using traits"], "metadata": {"chunk_id": "traits-003", "document_id": "traits", "position": 3, "token_count": 119, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Using traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#using-traits"}}
{"chunk_id": "traits-004", "document_id": "traits", "content": "ires a `quack()` method:\n\n```mojo\ntrait Quackable:\n fn quack(self):\n ...\n```\n\nA trait looks a lot like a struct, except it's introduced by the `trait`\nkeyword. Note that the `quack()` method signature is followed three dots\n(`...`), which indicates it isn't implemented. This is a *required method*\nthat must be implemented by any conforming struct.\n\nA trait can also supply a default implementations for a required method, so\nthat conforming structs don't need to implement it. For more information, see\n[Default method implementations](#default-method-implementations).\n\nA trait can also include associated aliasesâ€”compile-time constant values that\nmust be defined by conforming structs. Associated aliases are useful for writing\ntraits that describe generic types. For more information, see\n[Associated aliases for generics](#associated-aliases-for-generics).\n\n[note]\nCurrently, Mojo treats a trait method as not implemented if the function body\nstarts with `...` or `pass`. In the future only `...` will mark a trait method\nas not implemented.\n\n### Adding traits to structs\n\nNext we need some structs that conform to the `Quacka", "position": 4, "token_count": 250, "has_code": true, "section_hierarchy": ["Using traits", "Defining a trait"], "metadata": {"chunk_id": "traits-004", "document_id": "traits", "position": 4, "token_count": 250, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Using traits", "Defining a trait"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#defining-a-trait"}}
{"chunk_id": "traits-005", "document_id": "traits", "content": "ble` trait. Since the\n`Duck` and `StealthCow` structs above already implement the `quack()` method,\nall we need to do is add the `Quackable` trait to the traits it conforms to\n(in parenthesis, after the struct name).\n\n(If you're familiar with Python, this looks just like Python's inheritance\nsyntax.)\n\n```mojo\n@fieldwise_init\nstruct Duck(Copyable, Movable, Quackable):\n fn quack(self):\n print(\"Quack\")\n\n@fieldwise_init\nstruct StealthCow(Copyable, Movable, Quackable):\n fn quack(self):\n print(\"Moo!\")\n```\n\nThe struct needs to implement any methods that are declared in the trait. The\ncompiler enforces conformance: if a struct says it conforms to a trait, it must\nimplement everything required by the trait or the code won't compile.\n\n### Using a trait as a type bound\n\nFinally, you can define a function that takes a `Quackable` like thi", "position": 5, "token_count": 212, "has_code": true, "section_hierarchy": ["Using traits", "Adding traits to structs"], "metadata": {"chunk_id": "traits-005", "document_id": "traits", "position": 5, "token_count": 212, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Using traits", "Adding traits to structs"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#adding-traits-to-structs"}}
{"chunk_id": "traits-006", "document_id": "traits", "content": "s:\n\n```mojo\nfn make_it_quack[DuckType: Quackable](maybe_a_duck: DuckType):\n maybe_a_duck.quack()\n```\n\nOr using the shorthand form:\n\n```mojo\nfn make_it_quack2(maybe_a_duck: Some[Quackable]):\n maybe_a_duck.quack()\n```\n\nThis syntax may look a little unfamiliar if you haven't dealt with Mojo\n[parameters](/mojo/manual/parameters/) before. What the first signature means is\nthat `maybe_a_duck` is an argument of type `DuckType`, where `DuckType` is a\ntype that must conform to the `Quackable` trait. `Quackable` is called the *type\nbound* for `DuckType`.\n\nThe `Some[Quackable]` form expresses the same idea: the type of `maybe_a_duck`\nis some concrete type that conforms to the trait `Quackable`.\n\nBoth forms work the same, except that the first form explicitly names the type\nvalue. This can be useful, for example, if you want to take two values of the\nsame type:\n\n```mojo\nfn take_two_quackers[DuckType: Quackable](quacker1: DuckType, quacker2: DuckType):\n pass\n```\n\n### Putting it all together\n\nUsing the function is simple enough:\n\n```mojo\nmake_it_quack(Duck())\nmake_it_quack(S", "position": 6, "token_count": 306, "has_code": true, "section_hierarchy": ["Using traits", "Using a trait as a type bound"], "metadata": {"chunk_id": "traits-006", "document_id": "traits", "position": 6, "token_count": 306, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Using traits", "Using a trait as a type bound"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#using-a-trait-as-a-type-bound"}}
{"chunk_id": "traits-007", "document_id": "traits", "content": "tealthCow())\n```\n\n```output\nQuack\nMoo!\n```\n\nNote that you don't need the square brackets when you call `make_it_quack()`:\nthe compiler infers the type of the argument, and ensures the type has the\nrequired trait.\n\nOne limitation of traits is that you can't add traits to existing types. For\nexample, if you define a new `Numeric` trait, you can't add it to the standard\nlibrary `Float64` and `Int` types. However, the standard library already\nincludes quite a few traits, and we'll be adding more over time.\n\n### Traits can require static methods\n\nIn addition to regular instance methods, traits can specify required stat", "position": 7, "token_count": 146, "has_code": true, "section_hierarchy": ["Using traits", "Putting it all together"], "metadata": {"chunk_id": "traits-007", "document_id": "traits", "position": 7, "token_count": 146, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Using traits", "Putting it all together"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#putting-it-all-together"}}
{"chunk_id": "traits-008", "document_id": "traits", "content": "ic\nmethods.\n\n```mojo\ntrait HasStaticMethod:\n @staticmethod\n fn do_stuff(): ...\n\nfn fun_with_traits[type: HasStaticMethod]():\n type.do_stuff()\n```\n\n## Default method implementations\n\nOften, some or all of the structs that conform to a given trait can use the same\nimple", "position": 8, "token_count": 63, "has_code": true, "section_hierarchy": ["Using traits", "Traits can require static methods"], "metadata": {"chunk_id": "traits-008", "document_id": "traits", "position": 8, "token_count": 63, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Using traits", "Traits can require static methods"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#traits-can-require-static-methods"}}
{"chunk_id": "traits-009", "document_id": "traits", "content": "mentation for a given required method. In this case, the trait can include\na *default implementation*. A conforming struct can still define its own version\nof the method, overriding the default implementation. But if the struct doesn't\ndefine its own version, it automatically inherits the default implementation.\n\nDefining a default implementation for a trait looks the same as writing a method\nfor a struct:\n\n```mojo\ntrait DefaultQuackable:\n fn quack(self):\n print(\"Quack\")\n\n@fieldwise_init\nstruct DefaultDuck(Copyable, DefaultQuackable, Movable):\n pass\n```\n\nWhen looking at the API doc for a standard library trait, you'll see methods\nthat you *must* implement listed as *required methods*, and methods that have\ndefault implementations listed as *provided methods*.\n\nThe\n[`EqualityComparable`](/mojo/stdlib/builtin/equality_comparable/EqualityComparable/)\ntrait is a good example of the use case for default implementations. The trait\nincludes two methods: `__eq__()` (corresponding to the `==` operator) and\n`__ne__()` (corresponding to the `!=` operator). Every type that conforms to\n`EqualityComparable` needs to define the `__eq__()` method for itself, but the\ntrait supplies a default implementation for `__ne__()`. Given an `__eq__()`\nmethod, the definition of `__ne__()` is trivial for most types:\n\n```mojo\nfn __ne__(self, other: Self) -> Bool:\n return not self.__eq__(other)\n```\n\n## Trait compositions\n\nYou can compose traits using the `&` sigil. This lets you define new traits\nthat are simple combinations of other tr", "position": 9, "token_count": 360, "has_code": true, "section_hierarchy": ["Default method implementations"], "metadata": {"chunk_id": "traits-009", "document_id": "traits", "position": 9, "token_count": 360, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Default method implementations"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#default-method-implementations"}}
{"chunk_id": "traits-010", "document_id": "traits", "content": "aits. You can use a trait composition\nanywhere that you'd use a single trait:\n\n```mojo\ntrait Flyable:\n fn fly(self): ...\n\nfn quack_and_go[type: Quackable & Flyable](quacker: type):\n quacker.quack()\n quacker.fly()\n\n@fieldwise_init\nstruct FlyingDuck(Copyable, Movable, Quackable, Flyable):\n fn quack(self):\n print(\"Quack\")\n\n fn fly(self):\n print(\"Whoosh!\")\n```\n\nYou can also use the `alias` keyword to create a shorthand name for a\ntrait composition:\n\n```mojo\nalias DuckLike = Quackable & Flyable\n\nstruct ToyDuck(DuckLike):\n # ... implementation omitted\n```\n\nYou can also compose traits using [inheritance](#trait-inheritance), by defining\na new, empty trait like this:\n\n```mojo\ntrait DuckTrait(Quackable, Flyable):\n pass\n```\n\nHowever, this is less flexible than using a trait composition and not\nrecommended. The difference is that using the `trait` keyword defines a new,\nnamed trait. For a struct to conform to this trait, you need to *explicitly*\ninclude it in the struct's signature. On the other hand, the `DuckLike` alias\nrepresents a composition of two separate traits, `Quackable` and `Flyable`, and\nanything that conforms to those two traits conforms to `DuckLike`. For example,\nconsider the `FlyingDuck` type shown above:\n\n```mojo\nstruct FlyingDuck(Copyable, Movable, Quackable, Flyable):\n # ... etc\n```", "position": 10, "token_count": 346, "has_code": true, "section_hierarchy": ["Trait compositions"], "metadata": {"chunk_id": "traits-010", "document_id": "traits", "position": 10, "token_count": 346, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Trait compositions"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#trait-compositions"}}
{"chunk_id": "traits-011", "document_id": "traits", "content": "```mojo\nstruct FlyingDuck(Copyable, Movable, Quackable, Flyable):\n # ... etc\n```\n\nBecause `FlyingDuck` conforms to both `Quackable` and `Flyable`, it also\nconforms to the `DuckLike` trait composition. But it *doesn't*\nconform to `DuckTrait`, since it doesn't include `DuckTrait` in its list of\ntraits.\n\n## Trait inheritance\n\nTraits can inherit from other traits. A trait that inherits from another trait\nincludes all of the requirements declared by the parent trait. For example:", "position": 11, "token_count": 126, "has_code": true, "section_hierarchy": ["Trait compositions"], "metadata": {"chunk_id": "traits-011", "document_id": "traits", "position": 11, "token_count": 126, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Trait compositions"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#trait-compositions"}}
{"chunk_id": "traits-012", "document_id": "traits", "content": "```mojo\ntrait Animal:\n fn make_sound(self):\n ...\n\n# Bird inherits from Animal\ntrait Bird(Animal):\n fn fly(self):\n ...\n```\n\nSince `Bird` inherits from `Animal`, a struct that conforms to the `Bird` trait\nneeds to implement **both** `make_s", "position": 12, "token_count": 60, "has_code": true, "section_hierarchy": ["Trait inheritance"], "metadata": {"chunk_id": "traits-012", "document_id": "traits", "position": 12, "token_count": 60, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Trait inheritance"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#trait-inheritance"}}
{"chunk_id": "traits-013", "document_id": "traits", "content": "ound()` and `fly()`. And since every `Bird`\nconforms to `Animal`, a struct that conforms to `Bird` can be passed to any\nfunction that requires an `Animal`.\n\nTo inherit from multiple traits, add a comma-separated list of traits or\ntrait compositions inside the parenthesis. For example, you could define a\n`NamedAnimal` trait that combines the requirements of the `Animal` trait and a\nnew `Named` trait:\n\n```mojo\ntrait Named:\n fn get_name(self) -> String:\n ...\n\ntrait NamedAnimal(Animal, Named):\n fn emit_name_and_sound(self):\n ...\n```\n\nInheritance is useful when you're creating a new trait that adds its own\nrequirements. If you simply want to express the union of two or more traits,\nyou should use a simple trait composition instead:\n\n```mojo\nalias NamedAnimal = Animal & Named\n```\n\n## Traits and lifecycle methods\n\nTraits can specify required\n[lifecycle methods](/mojo/manual/lifecycle/#lifecycles-and-lifetimes), including\nconstructors, copy constructors and move constructors.\n\nFor example, the fol", "position": 13, "token_count": 229, "has_code": true, "section_hierarchy": ["Bird inherits from Animal"], "metadata": {"chunk_id": "traits-013", "document_id": "traits", "position": 13, "token_count": 229, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Bird inherits from Animal"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#bird-inherits-from-animal"}}
{"chunk_id": "traits-014", "document_id": "traits", "content": "lowing code creates a `MassProducible` trait. A\n`MassProducible` type has a default (no-argument) constructor and can be moved.\nIt uses two built-in traits:\n[`Defaultable`](/mojo/stdlib/builtin/value/Defaultable), which requires a default\n(no-argument) constructor, and\n[`Movable`](/mojo/stdlib/builtin/value/Movable),\nwhich requires the type to have a [move\nconstructor](/mojo/manual/lifecycle/life#move-constructor).\n\nThe `factory[]()` function returns a newly-constructed instance of a\n`MassProducible` type. The following example shows the definitions of\nthe `Defaultable` and `Movable` traits in comments for reference:\n\n```mojo\n# trait Defaultable\n# fn __init__(out self): ...\n\n# trait Movable\n# fn __moveinit__(out self, deinit existing: Self): ...\n\nalias MassProducible = Defaultable & Movable\n\nfn factory[type: MassProducible]() -> type:\n retu", "position": 14, "token_count": 219, "has_code": true, "section_hierarchy": ["Bird inherits from Animal", "Traits and lifecycle methods"], "metadata": {"chunk_id": "traits-014", "document_id": "traits", "position": 14, "token_count": 219, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Bird inherits from Animal", "Traits and lifecycle methods"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#traits-and-lifecycle-methods"}}
{"chunk_id": "traits-015", "document_id": "traits", "content": "rn type()\n\nstruct Th", "position": 15, "token_count": 5, "has_code": false, "section_hierarchy": ["trait Defaultable"], "metadata": {"chunk_id": "traits-015", "document_id": "traits", "position": 15, "token_count": 5, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["trait Defaultable"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#trait-defaultable"}}
{"chunk_id": "traits-016", "document_id": "traits", "content": "ing(MassProducible):\n var id: Int", "position": 16, "token_count": 10, "has_code": false, "section_hierarchy": ["fn __init__(out self): ..."], "metadata": {"chunk_id": "traits-016", "document_id": "traits", "position": 16, "token_count": 10, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["fn __init__(out self): ..."], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#fn-initout-self-"}}
{"chunk_id": "traits-017", "document_id": "traits", "content": "fn __init__(ou", "position": 17, "token_count": 5, "has_code": false, "section_hierarchy": ["trait Movable"], "metadata": {"chunk_id": "traits-017", "document_id": "traits", "position": 17, "token_count": 5, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["trait Movable"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#trait-movable"}}
{"chunk_id": "traits-018", "document_id": "traits", "content": "t self):\n self.id = 0\n\n fn __moveinit__(out self, deinit existing: Self):\n self.id = existing.id\n\nvar thing = factory[Thing]()\n```\n\n### Register-passable traits\n\nA trait can be declared with either the\n[`@register_passable`](/mojo/manual/decorators/register-passable)\ndecorator or the\n[`@register_passable(\"trivial\")`](/mojo/manual/decorators/register-passable#register_passabletrivia", "position": 18, "token_count": 101, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ..."], "metadata": {"chunk_id": "traits-018", "document_id": "traits", "position": 18, "token_count": 101, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ..."], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#fn-moveinitout-self-deinit-existing-self-"}}
{"chunk_id": "traits-019", "document_id": "traits", "content": "l)\ndecorator. These decorators add requirements for conforming structs:\n\n- If the trait is declared as `@register_passable`, every struct that conforms\n to the trait must be either `@register_passable` or\n `@register_passable(\"trivial\")`.\n\n- If the trait is declared as `@register_passable(\"trivial\")`, every struct that\n conforms to the trait must be\n struct must be `@register_passable(\"trivial\")`, too.\n\nFor the purpose of trait conformance, a trait or struct that's defined with\n`@register_passable` should automatically conform to the `Movable` trait, and a\ntrait or struct that's defined with `@register_passable(\"trivial\")` should\nautomatically conform to the `Copyable` and `Movable` traits.\n\n[note]\nIn some cases, the compiler may not track these automatic conformances\ncorrectly. If you run into an issue, add the traits to your struct explicitly.\n\n## Built-in traits\n\nThe Mojo standard library includes many traits. They're implemented\nby a number of standard library types, and you can also implement these on your\nown types. These standard library traits include:\n\n* [`Absable`](/mojo/stdlib/builtin/math/Absa", "position": 19, "token_count": 265, "has_code": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Register-passable traits"], "metadata": {"chunk_id": "traits-019", "document_id": "traits", "position": 19, "token_count": 265, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Register-passable traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#register-passable-traits"}}
{"chunk_id": "traits-020", "document_id": "traits", "content": "ble)\n* [`AnyType`](/mojo/stdlib/builtin/anytype/AnyType)\n* [`Boolable`](/mojo/stdlib/builtin/bool/Boolable)\n* [`Comparable`](/mojo/stdlib/builtin/comparable/Comparable)\n* [`Copyable`](/mojo/stdlib/builtin/value/Copyable)\n* [`Defaultable`](/mojo/stdlib/builtin/value/Defaultable)\n* [`Hashable`](/mojo/stdlib/hashlib/hash/Hashable)\n* [`Indexer`](/mojo/stdlib/builtin/int/Indexer)\n* [`Intable`](/mojo/stdlib/builtin/int/Intable)\n* [`IntableRaising`](/mojo/stdlib/builtin/int/IntableRaising)\n* [`KeyElement`](/mojo/stdlib/collections/dict/#keyelement)\n* [`Movable`](/mojo/stdlib/builtin/value/Movable)\n* [`PathLike`](/mojo/stdlib/os/pathlike/PathLike)\n* [`Powable`](/mojo/stdlib/builtin/math/Powable)\n* [`Representable`](/mojo/stdlib/builtin/repr/Representable)\n* [`Sized`](/mojo/stdlib/builtin/len/Sized)\n* [`Stringable`](/mojo/stdlib/builtin/str/Stringable)\n* [`StringableRaising`](/mojo/stdlib/builtin/str/StringableRaising)\n* [`Roundable`](/mojo/stdlib/builtin/math/Roundable)\n* [`Writable`](/mojo/stdlib/utils/write/Writable)\n* [`Writer`](/mojo/stdlib/utils/write/Writer)\n\nThe API reference docs linked above include usage examples for each trait. The\nfollowing sections discuss a few of these traits.\n\n### The `Sized` trait", "position": 20, "token_count": 377, "has_code": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits"], "metadata": {"chunk_id": "traits-020", "document_id": "traits", "position": 20, "token_count": 377, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#built-in-traits"}}
{"chunk_id": "traits-021", "document_id": "traits", "content": "n()`](/mojo/stdlib/builtin/len/len)\nfunction. For example, if you're writing a custom list type, you could\nimplement this trait so your type works with `len()`:\n\n```mojo\nstruct MyList(Copyable, Movable, Sized):\n var size: Int\n # ...\n\n fn __init__(out self):\n self.size = 0\n\n fn __len__(self) -> Int:\n return self.size\n\nprint(len(MyList()))\n```\n\n```output\n0\n```\n\n### The `Intable` and `IntableRaising` traits\n\nThe [`Intable`](/mojo/stdlib/builtin/int/Intable) trait identifies a type that\ncan be converted to `Int`. The\n[`IntableRaising`](/mojo/stdlib/builtin/int/IntableRaising) trait describes a\ntype can be converted to an `Int`, but the conversion", "position": 21, "token_count": 190, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Sized` trait"], "metadata": {"chunk_id": "traits-021", "document_id": "traits", "position": 21, "token_count": 190, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Sized` trait"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#the-sized-trait"}}
{"chunk_id": "traits-022", "document_id": "traits", "content": "might raise an error.\n\nBoth of these traits require the type to implement the `__int__()` method. For\nexample:\n\n```mojo\n@fieldwise_init\nstruct IntLike(Intable):\n var i: Int\n\n fn __int__(self) -> Int:\n return self.i\n\nvalue = IntLike(42)\nprint(Int(value) == 42)\n```\n\n```output\nTrue\n```\n\n### The `Stringable`, `Representable`, and `Writable` traits\n\nThe [`Stringable`](/mojo/stdlib/builtin/str/Stringable) trait identifies a type\nthat can be explicitly converted to\n[`String`](/mojo/stdlib/collections/string/string/String). The\n[`StringableRaising`](/mojo/stdlib/builtin/str/StringableRais", "position": 22, "token_count": 163, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Intable` and `IntableRaising` traits"], "metadata": {"chunk_id": "traits-022", "document_id": "traits", "position": 22, "token_count": 163, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Intable` and `IntableRaising` traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#the-intable-and-intableraising-traits"}}
{"chunk_id": "traits-023", "document_id": "traits", "content": "ing) trait\ndescribes a type that can be converted to a `String`, but the conversion might\nraise an error. These traits also mean that the type can support both the `{!s}`\nand `{}` format specifiers of the `String` and `StringSlice` class's\n[`format()`](/mojo/stdlib/collections/string/string/String#format) method. These\ntraits require the type to define the\n[`__str__()`](/mojo/stdlib/builtin/str/Stringable#__str__) method.\n\nIn contrast, the [`Representable`](/mojo/stdlib/builtin/repr/Representable)\ntrait defines a type that can be used with the built-in\n[`repr()`](/mojo/stdlib/builtin/repr/repr) function, as well as the `{!r}`\nformat specifier of the `format()` method. This trait requires the type to\ndefine the [`__repr__()`](/mojo/stdlib/builtin/repr/Representable#__repr__)\nmethod, which should compute the \"official\" string representation of a type. If\nat all possible, this should look like a valid Mojo expression that could be\nused to recreate a struct instance with the same value.\n\nThe [`Writable`](/mojo/stdlib/utils/write/Writable) trait describes a\ntype that can be converted to a stream of UTF-8 encoded data by writing to a\n`Writer` object. The [`print()`](/mojo/stdlib/builtin/io/print) function\nrequires that its arguments conform to the `Writable` trait. This enables\nefficient stream-based writing by default, avoiding unnecessary intermediate\nString heap allocations.", "position": 23, "token_count": 343, "has_code": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Stringable`, `Representable`, and `Writable` traits"], "metadata": {"chunk_id": "traits-023", "document_id": "traits", "position": 23, "token_count": 343, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Stringable`, `Representable`, and `Writable` traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#the-stringable-representable-and-writable-traits"}}
{"chunk_id": "traits-024", "document_id": "traits", "content": "The `Writable` trait requires a type to implement a\n[`write_to()`](/mojo/stdlib/utils/write/Writable#write_to) method, which\nis provided with an object that conforms to the\n[`Writer`](/mojo/stdlib/utils/write/Writer) as an argument. You then\ninvoke the `Writer` instance's\n[`write()`](/mojo/stdlib/utils/write/Writer#write) method to write a\nsequence of `Writable` arguments constituting the `String` representation of\nyour type.\n\nWhile this might sound complex at first, in practice you can minimize\nboilerplate and duplicated code by using the\n[`String.write()`](/mojo/stdlib/collections/string/string/String#write) static\nfunction to implement the type's `Stringable` implementation in terms of its\n`Writable` implementation. Here is a simple example of a type that implements\nall of the `Stringable`, `Representable`, and `Writable` traits:\n\n```mojo\n@fieldwise_init\nstruct Dog(Copyable, Stringable, Representable, Writable):\n var name: String\n var age: Int\n\n # Allows the type to be written into any `Writer`\n fn write_to(self, mut writer: Some[Writer]):\n writer.write(\"Dog(\", self.name, \", \", self.age, \")\")\n\n # Construct and return a `String` using the previous method\n fn __str__(self) -> String:\n return String.write(self)\n\n # Alternative full representation when calling `repr`\n fn __repr__(self) -> String:\n return String(\n \"Dog(name=\", repr(self.name), \", age=\", repr(self.age), \")\"\n )\n\ndog = Dog(\"Rex\", 5)\nprint(repr(dog))\nprint(dog)\n\nvar dog_info = \"String: {!s}\\nRepresentation: {!r}\".format(dog, dog)\nprint(dog_info)\n```", "position": 24, "token_count": 390, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Stringable`, `Representable`, and `Writable` traits"], "metadata": {"chunk_id": "traits-024", "document_id": "traits", "position": 24, "token_count": 390, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Stringable`, `Representable`, and `Writable` traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#the-stringable-representable-and-writable-traits"}}
{"chunk_id": "traits-025", "document_id": "traits", "content": "dog = Dog(\"Rex\", 5)\nprint(repr(dog))\nprint(dog)\n\nvar dog_info = \"String: {!s}\\nRepresentation: {!r}\".format(dog, dog)\nprint(dog_info)\n```\n\n```output\nDog(name='Rex', age=5)\nDog(Rex, 5)\nString: Dog(Rex, 5)\nRepresentation: Dog(name='Rex', age=5)\n```\n\n### The `AnyType` trait\n\nWhen building a generic container type, one challenge is knowing how to dispose\nof the contained items when the container is destroyed. Any type that\ndynamically allocates memory needs to supply a\n[destructor](/mojo/manual/lifecycle/death#destructor) (`__del__()` method)\nthat must be called to free the allocated memory. But not all types", "position": 25, "token_count": 177, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Stringable`, `Representable`, and `Writable` traits"], "metadata": {"chunk_id": "traits-025", "document_id": "traits", "position": 25, "token_count": 177, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `Stringable`, `Representable`, and `Writable` traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#the-stringable-representable-and-writable-traits"}}
{"chunk_id": "traits-026", "document_id": "traits", "content": "have a\ndestructor.\n\nThe [`AnyType`](/mojo/stdlib/builtin/anytype/AnyType) trait (also provided as\nthe\n[`ImplicitlyDestructible`](/mojo/stdlib/builtin/anytype/#implicitlydestructible)\nalias) represents a type with a destructor. Almost all traits inherit from\n`AnyType`, and all structs conform to `AnyType` by default. For any type that\nconforms to `AnyType` and doesn't define a destructor, Mojo generates a no-op\ndestructor. This means you can call the destructor on any type that inherits\nfrom `AnyType`/`ImplicitlyDestructible`.\n\nnote TODO\n\nIn the Mojo standard library docs you will also see a trait called\n[`UnknownDestructability`](/mojo/stdlib/builtin/anytype/UnknownDestructibility),\nwhich represents a type that may or may not have a destructor. All structs\nimplicitly conform to this trait.\n\nThis trait exists to support a planned future feature called *linear* or\n*explicitly-destroyed* types.\n\n## Generic structs with traits\n\nYou can also use traits when defining a generic container. A generic container\nis a container (for example, an array or hashmap) that can hold different data\ntypes. In a dynamic language like Python it's easy to add different types of\nitems to a container. But in a statically-typed environment the compiler needs\nto be able to identify the", "position": 26, "token_count": 303, "has_code": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `AnyType` trait"], "metadata": {"chunk_id": "traits-026", "document_id": "traits", "position": 26, "token_count": 303, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Built-in traits", "The `AnyType` trait"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#the-anytype-trait"}}
{"chunk_id": "traits-027", "document_id": "traits", "content": "types at compile time. For example, if the container\nneeds to copy a value, the compiler needs to verify that the type can be copied.\n\nThe [`List`](/mojo/stdlib/collections/list) type is an example of a\ngeneric container. A single `List` can only hold a single type of data.\nThe list elments must conform to the `Copyable` and `Movable` traits:\n\n```mojo\nstruct List[T: Copyable & Movable]:\n```\n\nFor example, you can create a list of integer values like this:\n\n```mojo\nvar list: List[Int]\nlist = [1, 2, 3, 4]\nfor i in range(len(list)):\n print(list[i], end=\" \")\n```\n\n```output\n1 2 3 4\n```\n\nYou can use traits to define requirements for elements that are stored in a\ncontainer. For example, `List` requires elements that can be moved and\ncopied. To store a struct in a `List`, the struct needs to conform to\nthe `Copyable` and `Movable` traits, which require a\n[copy constructor](/mojo/manual/lifecycle/life#copy-constructor) and a\n[move constructor](/mojo/manual/lifecycle/life#move-constructor).\n\nBuilding generic containers is an advanced topic. For an introduction, see the\nsection on\n[parameterized structs](/mojo/manual/parameters/#parameterized-structs).\n\n### Associated aliases for generics\n\nIn addition to methods, a trait can include _associated aliases_, which must be\ndefined by any conforming struct. For example:\n\n```mojo\ntrait Repeater:\n alias count: Int\n```\n\nAn implementing struct must define a concrete constant value for the alias,\nusing any compile-time parameter value. For example, it can use a literal\nconstant or a c", "position": 27, "token_count": 389, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Generic structs with traits"], "metadata": {"chunk_id": "traits-027", "document_id": "traits", "position": 27, "token_count": 389, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Generic structs with traits"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#generic-structs-with-traits"}}
{"chunk_id": "traits-028", "document_id": "traits", "content": "ompile-time expression, including one that uses the struct's\nparameters.\n\n```mojo\nstruct Doublespeak(Repeater):\n alias count: Int = 2\n\nstruct Multispeak[verbosity: Int](Repeater):\n alias count: Int = verbosity*2+1\n```\n\nThe `Doublespeak` struct has a constant value for the alias, but the `Multispeak`\nstruct lets the user set the value using a parameter:\n\n```mojo\nrepeater = Multispeak[12]()\n```\n\nNote that the alias is named `count`, and the `Multispeak` parameter is named\n`verbosity`. Parameters and aliases are in the same namespace, so the parameter\ncan't have the same name as the associated alias.\n\nAssociated aliases are most useful for writing traits for generic types. For\nexample, imagine that you want to write a trait that describes a generic stack\ndata structure that stores elements that conform to the `Copyable` and `Movable`\ntraits.\n\nBy adding the element type as an associated alias to the trait, you can specify\ngeneric methods on the trait:\n\n```mojo\ntrait Stacklike:\n alias EltType: Copyable & Movable\n\n fn push(mut self, var item: Self.EltType):\n ...\n\n fn pop(mut self) -> Self.EltType:\n ...\n```\n\nThe following struct implements the `Stacklike` trait using a `List` as the\nunderlying storage:\n\n```mojo\nstruct MyStack[type: Copyable & Movable](Stacklike):\n \"\"\"A simple Stack built using a List.\"\"\"\n alias EltType = type\n alias list_type = List[Self.EltType]\n\n var list: Self.list_type\n\n fn __init__(out self):\n self.list = Self.list_type()\n\n fn push(mut self, var item: Self.EltType):\n self.list.append(item^)\n\n fn pop(mut self) -> Self.EltType:\n return self.list.pop()", "position": 28, "token_count": 398, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Generic structs with traits", "Associated aliases for generics"], "metadata": {"chunk_id": "traits-028", "document_id": "traits", "position": 28, "token_count": 398, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Generic structs with traits", "Associated aliases for generics"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#associated-aliases-for-generics"}}
{"chunk_id": "traits-029", "document_id": "traits", "content": " var list: Self.list_type\n\n fn __init__(out self):\n self.list = Self.list_type()\n\n fn push(mut self, var item: Self.EltType):\n self.list.append(item^)\n\n fn pop(mut self) -> Self.EltType:\n return self.list.pop()\n\n fn dump[\n WritableEltType: Writable & Copyable & Movable\n ](self: MyStack[WritableEltType]):\n print(\"[\", end=\"\")\n for item in self.list:\n print(item, end=\", \")\n print(\"]\")\n```\n\nThe `MyStack` type adds a `dump()` method that prints the contents of the stack.\nBecause a struct that conforms to `Copyable` and `Movable` is not necessarily\nprintable, `MyStack` uses\n[conditional conformance](/mojo/manual/parameters/#conditional-conformance) to\ndefine a `dump()` method that works as long as the element type is\n[writable](/mojo/stdlib/utils/write/Writable/).\n\nThe following code exercises this new trait by defining a generic method,\n`add_to_stack()` that adds an item to any `Stacklike` type.\n\n```mojo\ndef add_to_stack[S: Stacklike](mut stack: S, var item: S.EltType):\n stack.push(item^)\n\ndef main():\n s = MyStack[Int]()\n add_to_stack(s, 12)\n add_to_stack(s, 33)\n s.dump() # [12, 33, ]\n print(s.pop()) # 33\n```", "position": 29, "token_count": 310, "has_code": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Generic structs with traits", "Associated aliases for generics"], "metadata": {"chunk_id": "traits-029", "document_id": "traits", "position": 29, "token_count": 310, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["fn __moveinit__(out self, deinit existing: Self): ...", "Generic structs with traits", "Associated aliases for generics"], "file_path": "traits.mdx", "url": "https://docs.modular.com/mojo/manual/traits", "title": "Traits", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/traits#associated-aliases-for-generics"}}

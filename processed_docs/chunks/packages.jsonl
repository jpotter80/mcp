{"chunk_id": "packages-000", "document_id": "packages", "content": "Mojo provides a packaging system that allows you to organize and compile code\nlibraries into importable files. This page introduces the necessary concepts\nabout how to organize your code into modules and packages (which is a lot\nlike Python), and shows you how to create a packaged binary with the [`mojo\npackage`](/mojo/cli/package) command.", "position": 0, "token_count": 72, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "packages-000", "document_id": "packages", "position": 0, "token_count": 72, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages"}}
{"chunk_id": "packages-001", "document_id": "packages", "content": "## Mojo modules\n\nTo understand Mojo packages, you first need to understand Mojo modules. A\nMojo module is a single Mojo source file that includes code suitable for use\nby other files that import it. For example, you can create a module\nto define a struct such as this one:\n\n```mojo title=\"mymodule.mojo\"\nstruct MyPair:\n var first: Int\n var second: Int\n\n fn __init__(out self, first: Int, second: Int):\n self.first = first\n self.second = second\n\n fn dump(self):\n print(self.first, self.second)\n```\n\nNotice that this code has no `main()` function, so you can't execute\n`mymodule.mojo`. However, you can import this into another file with a\n`main()` function and use it there.\n\nFor example, here's how you can import `MyPair` into a file named `main.mojo`\nthat's in the same directory as `mymodule.mojo`:\n\n```mojo title=\"main.mojo\"\nfrom mymodule import MyPair\n\nfn main():\n var mine = MyPair(2, 4)\n mine.dump()\n```\n\nAlternatively, you can import the whole module and then access its members\nthrough the module name. For example:", "position": 1, "token_count": 262, "has_code": true, "section_hierarchy": ["Mojo modules"], "metadata": {"chunk_id": "packages-001", "document_id": "packages", "position": 1, "token_count": 262, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Mojo modules"], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages#mojo-modules"}}
{"chunk_id": "packages-002", "document_id": "packages", "content": "fn main():\n var mine = MyPair(2, 4)\n mine.dump()\n```\n\nAlternatively, you can import the whole module and then access its members\nthrough the module name. For example:\n\n```mojo title=\"main.mojo\"\nimport mymodule\n\nfn main():\n var mine = mymodule.MyPair(2, 4)\n mine.dump()\n```\n\nYou can also create an alias for an imported member with `as`, like this:\n\n```mojo title=\"main.mojo\"\nimport mymodule as my\n\nfn main():\n var mine = my.MyPair(2, 4)\n mine.dump()\n```\n\nIn this example, it only works when `mymodule.mojo` is in the same directory as\n`main.mojo`. Currently, you can't import `.mojo` files as modules if they\nreside in other directories. That is, unless you treat the directory as a Mojo\npackage, as described in the next section.\n\n[note]\nA Mojo module may include a `main()` function and may also be\nexecutable, but that's generally not the practice and modules typically include\nAPIs to be imported and used in other Mojo programs.\n\n## Mojo packages\n\nA Mojo package is just a collection of M", "position": 2, "token_count": 254, "has_code": true, "section_hierarchy": ["Mojo modules"], "metadata": {"chunk_id": "packages-002", "document_id": "packages", "position": 2, "token_count": 254, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Mojo modules"], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages#mojo-modules"}}
{"chunk_id": "packages-003", "document_id": "packages", "content": "ojo modules in a directory that\nincludes an `__init__.mojo` file. By organizing modules together in a\ndirectory, you can then import all the modules together or individually.\nOptionally, you can also compile the package into a `.mojopkg` or `.ðŸ“¦` file\nthat's easier to share and still compatible with other system architectures.\n\nYou can import a package and its modules either directly from source files or\nfrom a compiled `.mojopkg`/`.ðŸ“¦` file. It makes no real difference to Mojo\nwhich way you import a package. When importing from source files, the directory\nname works as the package name, whereas when importing from a compiled package,\nthe filename is the package name (which you specify with the [`mojo\npackage`](/mojo/cli/package) commandâ€”it can differ from the directory\nname).\n\nFor example, consider a project with these files:\n\n```ini\nmain.mojo\nmypackage/\n __init__.mojo\n mymodule.mojo\n```\n\n`mymodule.mojo` is the same code from examples above (with the `MyPair`\nstruct) and `__init__.mojo` is empty.", "position": 3, "token_count": 249, "has_code": true, "section_hierarchy": ["Mojo packages"], "metadata": {"chunk_id": "packages-003", "document_id": "packages", "position": 3, "token_count": 249, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Mojo packages"], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages#mojo-packages"}}
{"chunk_id": "packages-004", "document_id": "packages", "content": "`mymodule.mojo` is the same code from examples above (with the `MyPair`\nstruct) and `__init__.mojo` is empty.\n\n[note]\nThe `__init__.mojo` file is essential. If you don't have it, Mojo won't\nrecognize the directory as a package and you can't import `mymodule`.\n\nIn this case, the `main.mojo` file can now import `MyPair` through the package\nname like this:\n\n```mojo title=\"main.mojo\"\nfrom mypackage.mymodule import MyPair\n\nfn main():\n var mine = MyPair(2, 4)\n mine.dump()\n```\n\nThis immediately works:\n\n```sh\nmojo main.mojo\n```\n\n```output\n2 4\n```\n\nHowever, if you don't want the `mypackage` source code in the same location\nas `main.mojo`, you can compile it into a package file like this:\n\n```sh\nmojo package mypackage -o mypack.mojopkg\n```", "position": 4, "token_count": 219, "has_code": true, "section_hierarchy": ["Mojo packages"], "metadata": {"chunk_id": "packages-004", "document_id": "packages", "position": 4, "token_count": 219, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Mojo packages"], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages#mojo-packages"}}
{"chunk_id": "packages-005", "document_id": "packages", "content": "```sh\nmojo package mypackage -o mypack.mojopkg\n```\n\n[note]\nA `.mojopkg` file contains non-elaborated code, so you can share it across\nsystems. The code becomes an architecture-specific executable only after it's\nimported into a Mojo program that's then compiled with `mojo build`.\n\nNow, you can move the `mypackage` source somewhere else, and the project files\nnow look like this:\n\n```ini\nmain.mojo\nmypack.mojopkg\n```\n\nBecause we named the package `mypack`, we need to fix\nthe import statement:\n\n```mojo title=\"main.mojo\"\nfrom mypack.mymodule import MyPair\n```\n\nAnd the code works the same:\n\n```sh\nmojo main.mojo\n```\n\n```output\n2 4\n```\n\n[note]\nIf you want to rename your package, you cannot simply edit the\n`.mojopkg` or `.ðŸ“¦` filename, because the package name is encoded in the file.\nYou must instead run `mojo package` again to specify a new name.\n\n### The `__init__` file", "position": 5, "token_count": 245, "has_code": true, "section_hierarchy": ["Mojo packages"], "metadata": {"chunk_id": "packages-005", "document_id": "packages", "position": 5, "token_count": 245, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Mojo packages"], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages#mojo-packages"}}
{"chunk_id": "packages-006", "document_id": "packages", "content": "te that a\ndirectory should be treated as a Mojo package, and it can be empty.\n\nCurrently, top-level code is not supported in `.mojo` files, so unlike Python,\nyou can't write code in `__init__.mojo` that executes upon import. You can,\nhowever, add structs and functions, which you can then import from the package\nname.\n\nHowever, instead of adding APIs in the `__init__.mojo` file, you can import\nmodule members, which has the same effect by making your APIs accessible from\nthe package name, instead of requiring the `<package_name>.<module_name>`\nnotation.\n\nFor example, again let's say you have these files:\n\n```ini\nmain.mojo\nmypackage/\n __init__.mojo\n mymodule.mojo\n```\n\nLet's now add the following line in `__init__.mojo`:\n\n```mojo title=\"__init__.mojo\"\nfrom .mymodule import MyPair\n```\n\nThat's all that's in there. Now, we can simplify the import statement in\n`main.mojo` like this:\n\n```mojo title=\"main.mojo\"\nfrom mypackage import MyPair\n```", "position": 6, "token_count": 246, "has_code": true, "section_hierarchy": ["Mojo packages", "The `__init__` file"], "metadata": {"chunk_id": "packages-006", "document_id": "packages", "position": 6, "token_count": 246, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Mojo packages", "The `__init__` file"], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages#the-init-file"}}
{"chunk_id": "packages-007", "document_id": "packages", "content": "That's all that's in there. Now, we can simplify the import statement in\n`main.mojo` like this:\n\n```mojo title=\"main.mojo\"\nfrom mypackage import MyPair\n```\n\nThis feature explains why some members in the Mojo standard library can be\nimported from their package name, while others required the\n`<package_name>.<module_name>` notation. For example, the\n[`functional`](/mojo/stdlib/algorithm/functional/) module resides in the\n`algorithm` package, so you can import members of that module (such as the\n`map()` function) like this:\n\n```mojo\nfrom algorithm.functional import map\n```\n\nHowever, the `algorithm/__init__.mojo` file also includes these lines:\n\n```mojo title=\"algorithm/__init__.mojo\"\nfrom .functional import *\nfrom .reduction import *\n```\n\nSo you can actually import anything from `functional` or `reduction` simply by\nnaming the package. That is, you can drop the `functional` name from the import\nstatement, and it also works:\n\n```mojo\nfrom algorithm import map\n```", "position": 7, "token_count": 239, "has_code": true, "section_hierarchy": ["Mojo packages", "The `__init__` file"], "metadata": {"chunk_id": "packages-007", "document_id": "packages", "position": 7, "token_count": 239, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Mojo packages", "The `__init__` file"], "file_path": "packages.md", "url": "https://docs.modular.com/mojo/manual/packages", "title": "Modules and packages", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/packages#the-init-file"}}

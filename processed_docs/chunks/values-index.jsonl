{"chunk_id": "values-index-000", "document_id": "values-index", "content": "A program is nothing without data, and all modern programming languages store\ndata in one of two places: the call stack and the heap (also sometimes in CPU\nregisters, but we won't get into that here). However, each language reads and\nwrites data a bit differently—sometimes very differently. So in the following\nsections, we'll explain how Mojo manages memory in your programs and how this\naffects the way you write Mojo code.\n\n[note]\nFor an alternate introduction to ownership in Mojo, check out our two-part blog\npost:\n[What ownership is really about: a mental model approach](https://www.modular.com/blog/what-ownership-is-really-about-a-mental-model-approach), and [Deep dive into\nownership in Mojo](https://www.modular.com/blog/deep-dive-into-ownership-in-mojo).\n\n## Stac", "position": 0, "token_count": 180, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "values-index-000", "document_id": "values-index", "position": 0, "token_count": 180, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "values/index.mdx", "url": "https://docs.modular.com/mojo/manual/values", "title": "Intro to value ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values"}}
{"chunk_id": "values-index-001", "document_id": "values-index", "content": "k and heap overview\n\nIn general, all modern programming languages divide a running program's memory\ninto four segments:\n\n* Text. The compiled program.\n* Data. Global data, either initialized or uninitialized.\n* Stack. Local data, automatically managed during the program's runtime.\n* Heap. Dynamically-allocated data, managed by the programmer.\n\nThe text and data segments are statically sized, but the stack and heap change\nsize as the program runs.\n\nThe *stack* stores data local to the current function. When a function is\ncalled, the program allocates a block of memory—a *stack frame*—that is exactly\nthe size required to store the function's data, including any *fixed-size*\nlocal variables. When another function is called, a new stack frame is pushed\nonto the top of the stack. When a function is done, its stack frame is popped\noff the stack.\n\nNotice that we said only \"*fixed-size* local values\" are stored in the stack.\nDynamically-sized values that can change in size at runtime are instead\nstored in the heap, which is a much larger region of memory that allows for\ndynamic memory allocation. Technically, a local variable for such a value\nis still stored in the call stack, but its value is a fixed-size pointer to the\nreal value on the heap. Consider a Mojo string: it can be any length, and\nits length can change at runtime. So the Mojo `String` struct includes some statically-sized fields, plus a pointer to a dynamically-allocated buffer\nholding the actual string data.", "position": 1, "token_count": 322, "has_code": false, "section_hierarchy": ["Stack and heap overview"], "metadata": {"chunk_id": "values-index-001", "document_id": "values-index", "position": 1, "token_count": 322, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Stack and heap overview"], "file_path": "values/index.mdx", "url": "https://docs.modular.com/mojo/manual/values", "title": "Intro to value ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values#stack-and-heap-overview"}}
{"chunk_id": "values-index-002", "document_id": "values-index", "content": "Another important difference between the heap and the stack is that the stack is\nmanaged automatically—the code to push and pop stack frames is added by the\ncompiler. Heap memory, on the other hand, is managed by the programmer\nexplicitly allocating and deallocating memory. You may do this indirectly—by\nusing standard library types like `List` and `String`—or directly, using the\n[`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer) API.\n\nValues that need to outlive the lifetime of a function (such as\nan array that's passed between functions and should not be copied) are stored\nin the heap, because heap memory is accessible from anywhere in the call stack,\neven after the function that created it is removed from the stack. This sort of\nsituation—in which a heap-allocated value is used by multiple functions—is where\nmost memory errors occur, and it's where memory management strategies vary the\nmost between programming languages.\n\n## Memo", "position": 2, "token_count": 203, "has_code": false, "section_hierarchy": ["Stack and heap overview"], "metadata": {"chunk_id": "values-index-002", "document_id": "values-index", "position": 2, "token_count": 203, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Stack and heap overview"], "file_path": "values/index.mdx", "url": "https://docs.modular.com/mojo/manual/values", "title": "Intro to value ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values#stack-and-heap-overview"}}
{"chunk_id": "values-index-003", "document_id": "values-index", "content": "ry management strategies\n\nBecause memory is limited, it's important that programs remove unused data from\nthe heap (\"free\" the memory) as quickly as possible. Figuring out when to free\nthat memory is pretty complicated.\n\nSome programming languages try to hide the complexities of memory management\nfrom you by utilizing a \"garbage collector\" process that tracks all memory\nusage and deallocates unused heap memory periodically (also known as automatic\nmemory management). A significant benefit of this method is that it relieves\ndevelopers from the burden of manual memory management, generally avoiding more\nerrors and making developers more productive. However, it incurs a performance\ncost because the garbage collector interrupts the program's execution, and it\nmight not reclaim memory very quickly.\n\nOther languages require that you manually free data that's allocated on the\nheap. When done properly, this makes programs execute quickly, because there's\nno processing time consumed by a garbage collector. However, the challenge with\nthis approach is that programmers make mistakes, especially when multiple parts\nof the program need access to the same memory—it becomes difficult to know\nwhich part of the program \"owns\" the data and must deallocate it. Programmers\nmight accidentally deallocate data before the program is done with it (causing\n\"use-after-free\" errors), or they might deallocate it twice (\"double free\"\nerrors), or they might never deallocate it (\"leaked memory\" errors). Mistakes\nlike these and others can have catastrophic results for the program, and these\nbugs are often hard to track down, making it especially important that they\ndon't occur in the first place.", "position": 3, "token_count": 333, "has_code": false, "section_hierarchy": ["Memory management strategies"], "metadata": {"chunk_id": "values-index-003", "document_id": "values-index", "position": 3, "token_count": 333, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Memory management strategies"], "file_path": "values/index.mdx", "url": "https://docs.modular.com/mojo/manual/values", "title": "Intro to value ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values#memory-management-strategies"}}
{"chunk_id": "values-index-004", "document_id": "values-index", "content": "Mojo uses a third approach called \"ownership\" that relies on a collection of\nrules that programmers must follow when passing values. The rules ensure there\nis only one \"owner\" for a given value at a time. When a value's lifetime ends,\nMojo calls its destructor, which is responsible for deallocating any heap memory\nthat needs to be deallocated.\n\nIn this way, Mojo helps ensure memory is freed, but it does so in a way that's\ndeterministic and safe from errors such as use-after-free, double-free and\nmemory leaks. Plus, it does so with a very low performance overhead.\n\nMojo's value ownership model provides an excellent balance of programming\nproductivity and strong memory safety. It only requires that you learn some new\nsyntax and a few rules about how to share access to memory within your program.\n\nBut before we explain the rules and syntax for Mojo's value ownership model,\nyou first need to understand [value\nsemantics](/mojo/manual/values/value-semantics).", "position": 4, "token_count": 208, "has_code": false, "section_hierarchy": ["Memory management strategies"], "metadata": {"chunk_id": "values-index-004", "document_id": "values-index", "position": 4, "token_count": 208, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Memory management strategies"], "file_path": "values/index.mdx", "url": "https://docs.modular.com/mojo/manual/values", "title": "Intro to value ownership", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values#memory-management-strategies"}}

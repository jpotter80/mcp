{"chunk_id": "pointers-index-000", "document_id": "pointers-index", "content": "A pointer is an indirect reference to one or more values stored in memory. The\npointer is a value that holds an address to memory, and provides APIs to store\nand retrieve values to that memory. The value pointed to by a pointer is also\nknown as a _pointee_.\n\nThe Mojo standard library includes several types of pointers, which provide\ndifferent sets of features. All of these pointer types are _generic_—they can\npoint to any type of value, and the value type is specified as a parameter. For\nexample, the following code creates an `OwnedPointer` that points to an `Int`\nvalue:\n\n```mojo\nvar ptr: OwnedPointer[Int]\nptr = OwnedPointer(100)\n```\n\nThe `ptr` variable has a value of type `OwnedPointer[Int]`. The pointer *points\nto* a value of type `Int`, as shown in Figure 1.\n\n<figure>\n\n![](../images/owned-pointer-diagram.png#light)\n![](../images/owned-pointer-diagram-dark.png#dark)\n\n<figcaption><b>Figure 1.</b> Pointer and pointee</figcaption>\n</figure>\n\nAccessing the memory—to retrieve or update a value—is called\n_dereferencing_ the pointer. You can dereference a pointer by following the\nvariable name with an empty pair of square brackets:\n\n```mojo\n#", "position": 0, "token_count": 283, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "pointers-index-000", "document_id": "pointers-index", "position": 0, "token_count": 283, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers"}}
{"chunk_id": "pointers-index-001", "document_id": "pointers-index", "content": "Update an initialized value\nptr[] += 10\n#", "position": 1, "token_count": 12, "has_code": false, "section_hierarchy": ["Update an initialized value"], "metadata": {"chunk_id": "pointers-index-001", "document_id": "pointers-index", "position": 1, "token_count": 12, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Update an initialized value"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#update-an-initialized-value"}}
{"chunk_id": "pointers-index-002", "document_id": "pointers-index", "content": "Access an initialized value\nprint(ptr[])\n```\n\n#", "position": 2, "token_count": 11, "has_code": true, "section_hierarchy": ["Access an initialized value"], "metadata": {"chunk_id": "pointers-index-002", "document_id": "pointers-index", "position": 2, "token_count": 11, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Access an initialized value"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#access-an-initialized-value"}}
{"chunk_id": "pointers-index-003", "document_id": "pointers-index", "content": "# Pointer terminology\n\nBefore we jump into the pointer types, here are a few terms you'll run across. Some\nof them may already be familiar to you.\n\n- **Safe pointers**: are designed to prevent memory errors. Unless you use one\n of the APIs that are specially designated as unsafe, you can use these\n pointers without worrying about memory issues like double-free or\n use-after-free.\n\n- **Nullable pointers**: can point to an invalid memory location (typically 0,\nor a “null pointer”). Safe pointers aren't nullable.\n\n- **Smart pointers**: own their pointees, which means that the value they point\n to may be deallocated when the pointer itself is destroyed. Non-owning\n pointers may point to values owned elsewhere, or may require some manual\n management of the value lifecycle.\n\n- **Memory allocation**: some pointer types can allocate memory to store their\n pointees, while other pointers can only point to pre-existing values. Memory\n allocation can either be implicit (that is, performed automatically when\n initializing a pointer with a value) or explicit.\n\n- **Uninitialized memory**: refers to memory locations that haven't been\n initialized with a value, which may therefore contain random data.\n Newly-allocated memory is uninitialized. The safe pointer types don't allow\n users to access memory that's uninitialized. Unsafe pointers can allocate a\n block of uninitialized memory locations and then initialize them one at a time.\n Being able to access uninitialized memory is unsafe by definition.\n\n- **Copyable types**: can be copied implicitly (for example, by assigning a\n value to a variable). Also called *implicitly copyable types*.\n\n ```mojo\n copied_ptr = ptr\n ```\n\n *Explicitly copyable* types require the user to request a copy, using a\n constructor with a keyword argument:\n\n ```mojo\n copied_owned_ptr = OwnedPointer(other=owned_ptr)\n ```\n\n## Pointer types\n\nThe Mojo", "position": 3, "token_count": 389, "has_code": true, "section_hierarchy": ["Access an initialized value", "Pointer terminology"], "metadata": {"chunk_id": "pointers-index-003", "document_id": "pointers-index", "position": 3, "token_count": 389, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Access an initialized value", "Pointer terminology"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#pointer-terminology"}}
{"chunk_id": "pointers-index-004", "document_id": "pointers-index", "content": "standard library includes several pointer types with different\ncharacteristics:\n\n- [`Pointer`](/mojo/stdlib/memory/pointer/Pointer) is a safe pointer that points\n to a single value that it doesn't own.\n\n- [`OwnedPointer`](/mojo/stdlib/memory/owned_pointer/OwnedPointer) is a smart\n pointer that points to a single value, and maintains exclusive ownership of\n that value.\n\n- [`ArcPointer`](/mojo/stdlib/memory/arc/ArcPointer) is a reference-counted\n smart pointer that points to an owned value with ownership potentially shared\n with other instances of `ArcPointer`.\n\n- [`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer) points to\n one or more consecutive memory locations, and can refer to uninitialized\n memory.\n\nTable 1 summarizes the different types of pointers:\n\n<figure>\n\n| | `Pointer` | `OwnedPointer` | `ArcPointer` | `UnsafePointer` |\n| --- | --- | --- | --- | --- |\n| Safe | Yes | Yes | Yes | No |\n| Allocates memory | No | Implicitly <sup>1</sup> | Implicitly <sup>1</sup> | Explicitly |\n| Owns pointee(s) | No | Yes | Yes | No <sup>2</sup> |\n| Copyable | Yes | No <sup>3</sup> | Yes | Yes |\n| Nullable | No | No | No | Yes |\n| Can point to uninitialized memory | No | No | No | Yes |\n| Can point to multiple values (array-like access) | No | No | No | Yes |\n\n<figcaption><b>Table 1.</b> Pointer types</figcaption>\n</figure>\n\n<sup>1</sup> `OwnedPointer` and `ArcPointer` implicitly allocate memory when you\ninitialize the pointer with a value.", "position": 4, "token_count": 385, "has_code": false, "section_hierarchy": ["Access an initialized value", "Pointer types"], "metadata": {"chunk_id": "pointers-index-004", "document_id": "pointers-index", "position": 4, "token_count": 385, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Access an initialized value", "Pointer types"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#pointer-types"}}
{"chunk_id": "pointers-index-005", "document_id": "pointers-index", "content": "<figcaption><b>Table 1.</b> Pointer types</figcaption>\n</figure>\n\n<sup>1</sup> `OwnedPointer` and `ArcPointer` implicitly allocate memory when you\ninitialize the pointer with a value.\n\n<sup>2</sup> `UnsafePointer` provides unsafe methods for initializing and\ndestroying instances of the stored type. The user is responsible for managing\nthe lifecycle of stored values.\n\n<sup>3</sup> `OwnedPointer` is explicitly copyable, but explicitly copying an\n`OwnedPointer` copies the *stored value* into a new `OwnedPointer`.\n\nThe following sections provide more details on each pointer type.\n\n## `Pointer`\n\nThe [`Pointer`](/moj", "position": 5, "token_count": 147, "has_code": false, "section_hierarchy": ["Access an initialized value", "Pointer types"], "metadata": {"chunk_id": "pointers-index-005", "document_id": "pointers-index", "position": 5, "token_count": 147, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Access an initialized value", "Pointer types"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#pointer-types"}}
{"chunk_id": "pointers-index-006", "document_id": "pointers-index", "content": "o/stdlib/memory/pointer/Pointer) type is a safe pointer that\npoints to a initialized value that it doesn't own. Some example use cases for a\n`Pointer` include:\n\n- Storing a reference to a related type. For example, a list's iterator object\nmight hold a `Pointer` back to the original list.\n\n- Passing the memory location for a single value to external code via\n`external_call()`.\n\n- Where you need an API to return a long-lived reference to a value. (Currently\nthe iterators for standard library collection types like `List` return\npointers.)\n\nYou can construct a `Pointer` to an existing value by calling the constructor\nwith the `to` keyword argument:\n\n```mojo\nptr = Pointer(to=some_value)\n```\n\nYou can also create a `Pointer` by copying an existing `Pointer`.\n\nA `Pointer` carries an [`origin`](/mojo/manual/values/lifetimes) for the stored\nvalue, so Mojo can track the lifetime of the referenced value.\n\n## `OwnedPointer`\n\nThe [`OwnedPoin", "position": 6, "token_count": 222, "has_code": true, "section_hierarchy": ["Access an initialized value", "`Pointer`"], "metadata": {"chunk_id": "pointers-index-006", "document_id": "pointers-index", "position": 6, "token_count": 222, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Access an initialized value", "`Pointer`"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#pointer"}}
{"chunk_id": "pointers-index-007", "document_id": "pointers-index", "content": "ter`](/mojo/stdlib/memory/owned_pointer/OwnedPointer) type is a\nsmart pointer designed for cases where there is single ownership of the\nunderlying data. An `OwnedPointer` points to a single item, which is passed in\nwhen you initialize the `OwnedPointer`. The `OwnedPointer` allocates memory and\nmoves or copies the value into the reserved memory.\n\n```mojo\no_ptr = OwnedPointer(some_big_struct)\n```\n\nAn owned pointer can hold almost any type of item, but when constructing an\n`OwnedPointer`, the stored item must be either `Movable` or `Copyable`.\n\nSince an `OwnedPointer` is designed to enforce single ownership, the pointer\nitself can be moved, but not copied.\n\nNote: Currently, you can't create an `Optional[OwnedPointer[T]]` because the\n`Optional` type only works with types that are both movable and copyable. This\nrestricts some use cases that would otherwise be a natural fit\nfor `OwnedPointer`, including self-referential data structures like linked lists\nand trees. (Until this use case is supported for `OwnedPointer`, it's possible\nto use `ArcPointer` where you need a smart pointer that can be `Optional`.)\n\n## `ArcPointer`\n\nAn [`ArcPointer`]", "position": 7, "token_count": 272, "has_code": true, "section_hierarchy": ["Access an initialized value", "`OwnedPointer`"], "metadata": {"chunk_id": "pointers-index-007", "document_id": "pointers-index", "position": 7, "token_count": 272, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Access an initialized value", "`OwnedPointer`"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#ownedpointer"}}
{"chunk_id": "pointers-index-008", "document_id": "pointers-index", "content": "(/mojo/stdlib/memory/arc/ArcPointer) is a reference-counted\nsmart pointer, ideal for shared resources where the last owner for a given value\nmay not be clear. Like an `OwnedPointer`, it points to a single value, and it\nallocates memory when you initialize the `ArcPointer` with a value:\n\n```mojo\nattributesDict: Dict[String, String] = {}\nattributes = ArcPointer(attributesDict)\n```\n\nUnlike an `OwnedPointer`, an `ArcPointer` can be freely copied. All instances\nof a given `ArcPointer` share a reference count, which is incremented whenever\nthe `ArcPointer` is copied and decremented whenever an instance is destroyed.\nWhen the reference count reaches zero, the stored value is destroyed and the\nallocated memory is freed.\n\nYou can use `ArcPointer` to implement safe reference-semantic types. For\nexample, in the following code snippet `SharedDict` uses an `ArcPointer` to\nstore a dictionary. Copying an instance of `SharedDict` only copies the\n`ArcPointer`, not the dictionary, which is shared between all of the copies.\n\n```mojo\nfrom memory import ArcPointer\n\nstruct SharedDict:\n var attributes: ArcPointer[Dict[String, String]]\n\n fn __init__(out self):\n attributesDict: Dict[String, String] = {}\n self.attributes = ArcPointer(attributesDict)\n\n fn __copyinit__(out self, other: Self):\n self.attributes = other.attributes\n\n def __setitem__(mut self, key: String, value: String):\n self.attributes[][key] = value\n\n def __getitem__(self, key: String) -> String:\n return self.attributes[].get(key, default=\"\")\n\ndef main():\n thing1 = SharedDict()\n thing2 = thing1\n thing1[\"Flip\"] = \"Flop\"\n print(thing2[\"Flip\"])\n```", "position": 8, "token_count": 382, "has_code": true, "section_hierarchy": ["Access an initialized value", "`ArcPointer`"], "metadata": {"chunk_id": "pointers-index-008", "document_id": "pointers-index", "position": 8, "token_count": 382, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Access an initialized value", "`ArcPointer`"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#arcpointer"}}
{"chunk_id": "pointers-index-009", "document_id": "pointers-index", "content": " def __setitem__(mut self, key: String, value: String):\n self.attributes[][key] = value\n\n def __getitem__(self, key: String) -> String:\n return self.attributes[].get(key, default=\"\")\n\ndef main():\n thing1 = SharedDict()\n thing2 = thing1\n thing1[\"Flip\"] = \"Flop\"\n print(thing2[\"Flip\"])\n```\n\nNote: The reference count is stored using an\n[`Atomic`](/mojo/stdlib/os/atomic/Atomic)\nvalue to ensure that updates to the reference count are thread-safe. However,\nMojo doesn't currently enforce exclusive access across thread boundaries, so\nit's possible to form race conditions.\n\n## UnsafePointer\n\n[`UnsafePointer`](/mojo/stdlib/memory/unsafe_pointer/UnsafePointer) is a\nlow-l", "position": 9, "token_count": 167, "has_code": true, "section_hierarchy": ["Access an initialized value", "`ArcPointer`"], "metadata": {"chunk_id": "pointers-index-009", "document_id": "pointers-index", "position": 9, "token_count": 167, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Access an initialized value", "`ArcPointer`"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#arcpointer"}}
{"chunk_id": "pointers-index-010", "document_id": "pointers-index", "content": "evel pointer that can access a block of contiguous memory locations, which\nmight be uninitialized. It's analogous to a raw pointer in the C and C++\nprogramming languages. `UnsafePointer` provides unsafe methods for initializing\nand destroying stored values, as well as for accessing the values once they're\ninitialized.\n\nAs the name suggests, `UnsafePointer` doesn't provide any memory safety\nguarantees, so you should reserve it for cases when none of the other pointer\ntypes will do the job. Here are some use cases where you might want to use an\n`UnsafePointer`:\n\n- Building a high-performance array-like structure, such as `List` or `Tensor`.\n A single `UnsafePointer` can access many values, and gives you a lot of\n control over how you allocate, use, and deallocate memory. Being able to\n access uninitialized memory means that you can preallocate a block of memory,\n and initialize values incrementally as they are added to the collection.\n\n- Interacting with external libraries including C++ and Python. You can\n use`UnsafePointer` to pass a buffer full of data to or from an external\n library.\n\nFor more information, see [Unsafe\npointers](/mojo/manual/pointers/unsafe-pointers).", "position": 10, "token_count": 260, "has_code": false, "section_hierarchy": ["Access an initialized value", "UnsafePointer"], "metadata": {"chunk_id": "pointers-index-010", "document_id": "pointers-index", "position": 10, "token_count": 260, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Access an initialized value", "UnsafePointer"], "file_path": "pointers/index.mdx", "url": "https://docs.modular.com/mojo/manual/pointers", "title": "Intro to pointers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/pointers#unsafepointer"}}

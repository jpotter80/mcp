{"chunk_id": "decorators-compiler-register-000", "document_id": "decorators-compiler-register", "content": "The `@compiler.register` decorator registers a custom operation for use with the\nGraph API. For more information on custom operations, see\n[Intro to custom ops](/max/custom-ops).\n\nTo define a custom operation:\n\n- Import the `compiler` package.\n\n- Create a struct that implements the `execute()` and (optional) `shape()`\n static methods.\n\n- Register it using the `@compiler.register` decorator.\n\nThe following snippet shows the outline of a custom operation:\n\n```mojo\n@compiler.register(\"add_vectors_custom\")\nstruct AddVectorsCustom:\n\n @staticmethod\n fn execute[...](...) raises:\n pass\n\n @staticmethod\n fn shape(...) raises -> IndexList:\n pass\n```\n\nThe `@compiler.register` decorator takes a single arguments, the name of the\ncustom operation, as a string. This name is used to load the custom op into your\ngraph.\n\nOutput from the `execute()` method is usually returned using one or more\ndestination-passing style (DPS) output tensors. Destination-passing style (DPS)\nmeans that the calling function passes in pre-allocated storage space for the\noutput value(s). This allows for more efficient memory management. For example,\nthe graph compiler can optimize memory use by allocating output tensors on the\nstack, instead of requiring custom ops to allocate heap storage for return\nvalues.\n\nDestination passing style requires the graph compiler to determine the\ndimensions of the output tensor(s) before executing the operation. It uses the\noperation's `shape()` function to determine the dimensions if they can't be\ndetermined statically.\n\nThe following sections describe the `execute()` and `shape()` functions.\n\n### `execute()` function\n\nT", "position": 0, "token_count": 343, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "decorators-compiler-register-000", "document_id": "decorators-compiler-register", "position": 0, "token_count": 343, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "decorators/compiler-register.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/compiler-register", "title": "@compiler.register", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/compiler-register"}}
{"chunk_id": "decorators-compiler-register-001", "document_id": "decorators-compiler-register", "content": "he `execute()` function performs the actual work of the custom op. It takes the\nfollowing parameter:\n\n- `target` (`StaticString`): Indicates the device the operation is running on:\n currently takes the values `\"cpu\"` or `\"gpu\"`.\n\nGraph output and input tensors are passed to the `execute()` function as\ninstances of\n[`OutputTensor`](/max/api/mojo/tensor/managed_tensor_slice/#aliases) and\n[`InputTensor`](/max/api/mojo/tensor/managed_tensor_slice/#aliases),\nrespectively. These are both aliases for specific configurations of\n[`ManagedTensorSlice`](/max/api/mojo/tensor/managed_tensor_slice/ManagedTensorSlice),\nso they both have the same API.\n\nIn addition to input and output tensors, the function can take the following\narguments:\n\n- Any arguments of type [`Scalar`](/mojo/manual/types#scalar-values).\n\n- A single argument of type `DeviceContextPtr`. This opaque pointer is\n currently required for GPU support.\n\n```mojo\nimport compiler\nfrom utils.index import IndexList\nfrom max.tensor import OutputTensor, InputTensor, foreach, ManagedTensorSlice\nfrom runtime.asyncrt import DeviceContextPtr\n\n@compiler.register(\"add_vectors_custom\")\nstruct AddVectorsCustom:\n @staticmethod\n fn execute[\n # \"gpu\" or \"cpu\"\n target: StaticString,\n ](\n # the first argument is the output\n out: OutputTensor,\n # starting here is the list of inputs\n x: InputTensor[dtype = out.dtype, rank = out.rank],\n y: InputTensor[dtype = out.dtype, rank = out.rank],\n # the context is needed for some GPU calls\n ctx: DeviceContextPtr,\n ) raises:\n\n @parameter\n @always_inline\n fn func[width: Int](idx: IndexList[x.rank]) -> SIMD[x.dtype, width]:\n return x.load[width](idx) + y.load[width](idx)", "position": 1, "token_count": 395, "has_code": true, "section_hierarchy": ["`execute()` function"], "metadata": {"chunk_id": "decorators-compiler-register-001", "document_id": "decorators-compiler-register", "position": 1, "token_count": 395, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["`execute()` function"], "file_path": "decorators/compiler-register.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/compiler-register", "title": "@compiler.register", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/compiler-register#execute-function"}}
{"chunk_id": "decorators-compiler-register-002", "document_id": "decorators-compiler-register", "content": "graph compiler can't statically\ndetermine the shape of the output tensor(s), and you don't manually annotate the\noutput shapes when building a graph.\n\nThe function takes the same arguments as the `execute()` function, minus the\noutput tensors and `DeviceContextPtr`. It must return an\n[`IndexList`](/mojo/stdlib/utils/index_/IndexList/) specifying the dimensions of\nthe output tensor.\n\nFor example, if the operation takes two input tensors, and the shape of the\noutput tensor matches the first input tensor, you could use the following\n`shape()` function:\n\n```mojo\n @staticmethod\n fn shape(\n in1: InputTensor,\n in2: InputTensor,\n ) raises -> IndexList[in1.rank]:\n return in1.spec.shape\n```", "position": 2, "token_count": 158, "has_code": true, "section_hierarchy": ["`shape()` function"], "metadata": {"chunk_id": "decorators-compiler-register-002", "document_id": "decorators-compiler-register", "position": 2, "token_count": 158, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["`shape()` function"], "file_path": "decorators/compiler-register.mdx", "url": "https://docs.modular.com/mojo/manual/decorators/compiler-register", "title": "@compiler.register", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/decorators/compiler-register#shape-function"}}

{"chunk_id": "errors-000", "document_id": "errors", "content": "This page discusses how to raise errors in Mojo programs and how to detect and\nhandle error conditions. It also discusses how you can use context managers to\ncorrectly allocate and release resources such as files, even when error\nconditions occur. Finally, it shows you how to implement context managers for\nyour own custom resources.", "position": 0, "token_count": 65, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "errors-000", "document_id": "errors", "position": 0, "token_count": 65, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors"}}
{"chunk_id": "errors-001", "document_id": "errors", "content": "## Raise an error\n\nThe `raise` statement raises an error condition in your program. You provide the\n`raise` statement with an [`Error`](/mojo/stdlib/builtin/error/Error) instance\nto indicate the type of error that occurred. For example:\n\n```mojo\nraise Error(\"integer overflow\")\n```\n\nAs a convenience, you can instead provide an error message in the form of a\n[`String`](/mojo/stdlib/collections/string/string/String) or\n[`StringLiteral`](/mojo/stdlib/builtin/string_literal/StringLiteral) value, and\n`raise` automatically uses that to create an `Error` instance. So you can raise\nthe same error condition as shown above by executing:\n\n```mojo\nraise \"integer overflow\"\n```\n\n[note]\nCurrently, Mojo does not support typed error conditions. All errors are\ninstances of `Error`, and the only thing that distinguishes different error\nconditions is the error message that you provide.", "position": 1, "token_count": 201, "has_code": true, "section_hierarchy": ["Raise an error"], "metadata": {"chunk_id": "errors-001", "document_id": "errors", "position": 1, "token_count": 201, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Raise an error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#raise-an-error"}}
{"chunk_id": "errors-002", "document_id": "errors", "content": "[note]\nCurrently, Mojo does not support typed error conditions. All errors are\ninstances of `Error`, and the only thing that distinguishes different error\nconditions is the error message that you provide.\n\nAn error interrupts the execution flow of your program. If you provide an error\nhandler (as described in [Handle an error](#handle-an-error)) in the current\nfunction, execution resumes with that handler. If the error isn't handled in the\ncurrent function, it propagates to the calling function and so on. If an error\nisn't caught by any error handler, your program terminates with a non-zero exit\ncode and prints a stack trace, if enabled, followed by the error message. For\nexample:\n\n```output\nstack trace was not collected. Enable stack trace collection with environment variable `MOJO_ENABLE_STACK_TRACE_ON_ERROR`\nUnhandled exception caught during execution: integer overflow\n```\n\n## Enab", "position": 2, "token_count": 188, "has_code": true, "section_hierarchy": ["Raise an error"], "metadata": {"chunk_id": "errors-002", "document_id": "errors", "position": 2, "token_count": 188, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Raise an error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#raise-an-error"}}
{"chunk_id": "errors-003", "document_id": "errors", "content": "le stack trace generation for errors\n\nBy default, Mojo generates a stack trace when your program hits a segmentation\nfault. If you don't want this behavior, you can disable it by setting the\n`MOJO_ENABLE_STACK_TRACE_ON_CRASH` environment variable to `0` or `false`\n(case-insensitive).\n\nHowever, Mojo *doesn't* generate a stack trace when your program raises an\nerrorâ€”we skip this to avoid the additional run-time overhead. If you want stack\ntraces for raised errors, you can enable them by setting the\n`MOJO_ENABLE_STACK_TRACE_ON_ERROR` environment variable to any value other than\n`0` or `false` (case-insensitive).\n\nKeep in mind that when you compile your program with [`mojo\nbuild`](/mojo/cli/build/), the compiler optimizes and strips symbols by default,\nso often your stack trace won't be very useful.\n\nLet's look at this program:\n\n```mojo title=\"stacktrace_error.mojo\"\ndef func2() -> None:\n raise Error(\"Intentional error\")\n\ndef func1() -> None:\n func2()\n\ndef main():\n func1()\n```", "position": 3, "token_count": 235, "has_code": true, "section_hierarchy": ["Enable stack trace generation for errors"], "metadata": {"chunk_id": "errors-003", "document_id": "errors", "position": 3, "token_count": 235, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Enable stack trace generation for errors"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#enable-stack-trace-generation-for-errors"}}
{"chunk_id": "errors-004", "document_id": "errors", "content": "Let's look at this program:\n\n```mojo title=\"stacktrace_error.mojo\"\ndef func2() -> None:\n raise Error(\"Intentional error\")\n\ndef func1() -> None:\n func2()\n\ndef main():\n func1()\n```\n\nIf you compile the program with the default settings and run it with the\nenvironment variable set, you'll see a stack trace without symbols:\n\n```sh\nmojo build stacktrace_error.mojo\n```\n```sh\nMOJO_ENABLE_STACK_TRACE_ON_ERROR=1 stacktrace_error\n```\n\n```output\n#0 0x0000000104ef8ecc llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xccecc)\n#1 0x0000000104e379e4 KGEN_CompilerRT_GetStackTrace (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xb9e4)\n#2 0x000000010478868c main (/Users/ken/tmp/stack/stacktrace_error+0x10000068c)", "position": 4, "token_count": 247, "has_code": true, "section_hierarchy": ["Enable stack trace generation for errors"], "metadata": {"chunk_id": "errors-004", "document_id": "errors", "position": 4, "token_count": 247, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Enable stack trace generation for errors"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#enable-stack-trace-generation-for-errors"}}
{"chunk_id": "errors-005", "document_id": "errors", "content": "```sh\nmojo build --debug-level full stacktrace_error.mojo\n```\n```sh\nMOJO_ENABLE_STACK_TRACE_ON_ERROR=1 ./stacktrace_error\n```\n\n```output\n#0 0x0000000102bf4ecc llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xccecc)\n#1 0x0000000102b339e4 KGEN_CompilerRT_GetStackTrace (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xb9e4)\n#2 0x000000010266468c stdlib::builtin::error::Error::__init__[__mlir_type.!kgen.string](::StringLiteral[$0])_REMOVED_ARG open-source/max/mojo/stdlib/stdlib/builtin/error.mojo:159:38\n#3 0x000000010266468c stacktrace_error::func2()_REMOVED_ARG /Users/ken/tmp/stack/stacktrace_error.mojo:14:16\n#4 0x000000010266468c stacktrace_error::func1() /Users/ken/tmp/stack/stacktrace_error.mojo:18:10\n#5 0x000000010266468c stacktrace_error::main() /Users/ken/tmp/stack/stacktrace_error.mojo:22:10\n#6 0x000000010266468c stdlib::builtin::_startup::__wrap_and_execute_raising_main[fn() raises -> None](::SIMD[::DType(int32), ::Int(1)],__mlir_type.!kgen.pointer<pointer<scalar<ui8>>>),main_func=\"stacktrace_error::main()\" open-source/max/mojo/stdlib/stdlib/builtin/_startup.mojo:88:18\n#7 0x000000010266468c main open-source/max/mojo/stdlib/stdlib/builtin/_startup.mojo:103:4", "position": 5, "token_count": 439, "has_code": true, "section_hierarchy": ["Enable stack trace generation for errors"], "metadata": {"chunk_id": "errors-005", "document_id": "errors", "position": 5, "token_count": 439, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Enable stack trace generation for errors"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#enable-stack-trace-generation-for-errors"}}
{"chunk_id": "errors-006", "document_id": "errors", "content": "```sh\nMOJO_ENABLE_STACK_TRACE_ON_ERROR=1 mojo --debug-level full stacktrace_error.mojo\n```\n\n```output\n#0 0x000000013a9c4ecc llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xccecc)\n#1 0x000000013a9039e4 KGEN_CompilerRT_GetStackTrace (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xb9e4)\n#2 0x000000032002807c\n#3 0x000000010488a0f4 M::KGEN::ExecutionEngine::runProgram(llvm::StringRef, llvm::StringRef, llvm::function_ref<M::ErrorOrSuccess (void*)>) (/Users/ken/tmp/stack/.pixi/envs/default/bin/mojo+0x10039e0f4)\n#4 0x0000000104512000 executeMain(M::KGEN::ExecutionEngine&, M::AsyncRT::Runtime&, llvm::ArrayRef<char const*>) (/Users/ken/tmp/stack/.pixi/envs/default/bin/mojo+0x100026000)\n#5 0x00000001045118e8 run(M::State const&) (/Users/ken/tmp/stack/.pixi/envs/default/bin/mojo+0x1000258e8)\n#6 0x000000010451a240 main (/Users/ken/tmp/stack/.pixi/envs/default/bin/mojo+0x10002e240)\n#7 0x0000000186d7ab98", "position": 6, "token_count": 369, "has_code": true, "section_hierarchy": ["Enable stack trace generation for errors"], "metadata": {"chunk_id": "errors-006", "document_id": "errors", "position": 6, "token_count": 369, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Enable stack trace generation for errors"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#enable-stack-trace-generation-for-errors"}}
{"chunk_id": "errors-007", "document_id": "errors", "content": "Unhandled exception caught during execution: Intentional error\nmojo: error: execution exited with a non-zero result: 1\n```\n\nAs described in [Handle an error](#handle-an-error), you can bind the `Error`\ninstance to a variable in the `except` clause. If you do, you can invoke its\n[`get_stack_trace()`](/mojo/stdlib/builtin/error/Error#get_stack_trace) method\nto get a [`StackTrace`](/mojo/stdlib/builtin/error/StackTrace) instance.\n`StackTrace` implements the [`Stringable`](/mojo/stdlib/builtin/str/Stringable)\ntrait, so you can construct a `String` with `String(stack_trace)` if you want to\nextract the stack trace as a `String` for further processing. For example:\n\n```mojo\ndef func2() -> None:\n raise Error(\"Intentional error\")\n\ndef func1() -> None:\n func2()\n\ndef main():\n try:\n func1()\n except e:\n print(e)\n print(\"-\" * 20)\n print(String(e.get_stack_trace()))\n```\n\nWhen you compile this program with symbols and run it with stack trace\ngeneration enabled, you'll see the following output:", "position": 7, "token_count": 250, "has_code": true, "section_hierarchy": ["Enable stack trace generation for errors"], "metadata": {"chunk_id": "errors-007", "document_id": "errors", "position": 7, "token_count": 250, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Enable stack trace generation for errors"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#enable-stack-trace-generation-for-errors"}}
{"chunk_id": "errors-008", "document_id": "errors", "content": "```sh\nmojo build --debug-level full stacktrace_error_capture.mojo\n```\n```sh\nMOJO_ENABLE_STACK_TRACE_ON_ERROR=1 ./stacktrace_error_capture\n```\n\n```output\nIntentional error\n--------------------\n#0 0x0000000102d24ecc llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xccecc)\n#1 0x0000000102c639e4 KGEN_CompilerRT_GetStackTrace (/Users/ken/tmp/stack/.pixi/envs/default/lib/libKGENCompilerRTShared.dylib+0xb9e4)\n#2 0x00000001026d4694 stdlib::builtin::error::Error::__init__[__mlir_type.!kgen.string](::StringLiteral[$0])_REMOVED_ARG open-source/max/mojo/stdlib/stdlib/builtin/error.mojo:159:38\n#3 0x00000001026d4694 stacktrace_error_capture::func2()_REMOVED_ARG /Users/ken/tmp/stack/stacktrace_error_capture.mojo:14:16\n#4 0x00000001026d4694 stacktrace_error_capture::func1() /Users/ken/tmp/stack/stacktrace_error_capture.mojo:18:10\n#5 0x00000001026d4694 stacktrace_error_capture::main() /Users/ken/tmp/stack/stacktrace_error_capture.mojo:23:14\n#6 0x00000001026d4694 stdlib::builtin::_startup::__wrap_and_execute_raising_main[fn() raises -> None](::SIMD[::DType(int32), ::Int(1)],__mlir_type.!kgen.pointer<pointer<scalar<ui8>>>),main_func=\"stacktrace_error_capture::main()\" open-source/max/mojo/stdlib/stdlib/builtin/_startup.mojo:88:18\n#7 0x00000001026d4694 main open-source/max/mojo/stdlib/stdlib/builtin/_startup.mojo:103:4\n```", "position": 8, "token_count": 463, "has_code": true, "section_hierarchy": ["Enable stack trace generation for errors"], "metadata": {"chunk_id": "errors-008", "document_id": "errors", "position": 8, "token_count": 463, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Enable stack trace generation for errors"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#enable-stack-trace-generation-for-errors"}}
{"chunk_id": "errors-009", "document_id": "errors", "content": "yword is *non-raising* by default. So if it\ncan raise an error, you must include the `raises` keyword in the function\ndefinition. For example:\n\n```mojo\nfn incr(n: Int) raises -> Int:\n if n == Int.MAX:\n raise \"inc: integer overflow\"\n else:\n return n + 1\n```\n\nIf you don't include the `raises` keyword on an `fn` function,\nthen the function must explicitly handle any errors that might occur in the code\nit executes. For example:\n\n```mojo\n# This function doesn't compile because of the unhandled error\nfn unhandled_error(n: In", "position": 9, "token_count": 136, "has_code": true, "section_hierarchy": ["Declare a raising function"], "metadata": {"chunk_id": "errors-009", "document_id": "errors", "position": 9, "token_count": 136, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Declare a raising function"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#declare-a-raising-function"}}
{"chunk_id": "errors-010", "document_id": "errors", "content": "t):\n print(n, \"+ 1 =\", incr(n))\n\n# This function compiles because it handles the possible error\nfn handled_error(n: Int):", "position": 10, "token_count": 31, "has_code": false, "section_hierarchy": ["This function doesn't compile because of the unhandled error"], "metadata": {"chunk_id": "errors-010", "document_id": "errors", "position": 10, "token_count": 31, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["This function doesn't compile because of the unhandled error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#this-function-doesnt-compile-because-of-the-unhandled-error"}}
{"chunk_id": "errors-011", "document_id": "errors", "content": "try:\n print(n, \"+ 1 =\", incr(n))\n except e:\n print(\"Handled an error:\", e)\n```\n\nIn contrast, a `def` function is *raising* by default. So the following\n`incr()` function is equivalent to the `incr()` function defined above with\n`fn`:\n\n```mojo\ndef incr(n: Int) -> Int:\n if n == Int.MAX:\n raise \"inc: integer overflow\"\n else:\n return n + 1\n```\n\n## Handle an error\n\nMojo allows you to detect and handle error conditions using the `try-except`\ncontrol flow structure. The full", "position": 11, "token_count": 128, "has_code": true, "section_hierarchy": ["This function compiles because it handles the possible error"], "metadata": {"chunk_id": "errors-011", "document_id": "errors", "position": 11, "token_count": 128, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This function compiles because it handles the possible error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#this-function-compiles-because-it-handles-the-possible-error"}}
{"chunk_id": "errors-012", "document_id": "errors", "content": "syntax is:\n\n```mojo\ntry:\n # Code block to execute that might raise an error\nexcept <optional_variable_name>:\n # Code block to execute if an error occurs\nelse:\n # Code block to execute if no error occurs\nfinally:\n # Final code block to execute in all circumstances\n```\n\nYou must include one or both of the `except` and `finally` clauses. The `else`\nclause is optional.\n\nThe `try` clause contains a code block to execute that might raise an error. If\nno error occurs, the entire code block executes. If an error occurs, execution\nof the code block stops at the point that the error is raised. Your program then\ncontinues with the execution of the `except` clause, if provided, or the\n`finally` clause.\n\nIf the `except` clause is present, its code block executes only if an error\noccurred in the `try` clause. The `except` clause \"consumes\" the error that\noccurred in the `try` clause. You can then implement any error handling or\nrecovery that's appropriate for your application.", "position": 12, "token_count": 232, "has_code": true, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "metadata": {"chunk_id": "errors-012", "document_id": "errors", "position": 12, "token_count": 232, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#handle-an-error"}}
{"chunk_id": "errors-013", "document_id": "errors", "content": "If you provide the name of a variable after the `except` keyword, then the\n`Error` instance is bound to the variable if an error occurs. The `Error` type\nimplements the [`Writable`](/mojo/stdlib/utils/write/Writable) trait, so you can\npass it as an argument to the [`print()`](/mojo/stdlib/builtin/io/print)\nfunction if you'd like to print its error message to the console. It also\nimplements the [`Stringable`](/mojo/stdlib/builtin/str/Stringable) trait, so you\ncan construct a `String` with `String(error)` if you want to extract the error\nmessage as a `String` for further processing.\n\nIf desired, you can re-raise an error condition from your `except` clause simply\nby executing a `raise` statement from within its code block. This can be either\na new `Error` instance or, if you provided a variable name to capture the\n`Error` that occurred originally, you can re-raise that error.", "position": 13, "token_count": 219, "has_code": false, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "metadata": {"chunk_id": "errors-013", "document_id": "errors", "position": 13, "token_count": 219, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#handle-an-error"}}
{"chunk_id": "errors-014", "document_id": "errors", "content": "[note]\nBecause Mojo does not currently support typed errors, a `try-except` control\nstructure can include at most one `except` clause, which catches any `Error`\nraised.\n\nIf the `else` clause is present, its code block executes only if an error does\nnot occur in the `try` clause. Note that the `else` clause is *skipped* if the\n`try` clause executes a `continue`, `break`, or `return` that exits from the\n`try` block.\n\nIf the `finally` clause is present, its code block executes after the `try`\nclause and the `except` or `else` clause, if applicable. The `finally` clause\nexecutes even if one of the other code blocks exits by executing a `continue`,\n`break`, or `return` statement or by raising an error. The `finally` clause is\noften used to release resources used by the `try` clause (such as a file handle)\nregardless of whether an error occurred.\n\nAs an example, consider the following program:", "position": 14, "token_count": 221, "has_code": false, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "metadata": {"chunk_id": "errors-014", "document_id": "errors", "position": 14, "token_count": 221, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#handle-an-error"}}
{"chunk_id": "errors-015", "document_id": "errors", "content": "As an example, consider the following program:\n\n```mojo title=\"handle_error.mojo\"\ndef incr(n: Int) -> Int:\n if n == Int.MAX:\n raise \"inc: integer overflow\"\n else:\n return n + 1\n\ndef main():\n for value in [0, 1, Int.MAX]:\n try:\n print()\n print(\"try =>\", value)\n if value == 1:\n continue\n result = \"{} incremented is {}\".format(value, incr(value))\n except e:\n print(\"except =>\", e)\n else:\n print(\"else =>\", result)\n finally:\n print(\"finally => ====================\")\n```\n\nRunning this program generates the following output:\n\n```output\ntry => 0\nelse => 0 incremented is 1\nfinally => ====================\n\ntry => 1\nfinally => ====================\n\ntry => 9223372036854775807\nexcept => inc: integer overflow\nfinally => ====================\n```\n\n## Use a context manager\n\nA *context manager* is an object that manages resources such as files, network\nconnections, and database connections. It provides a way to allocate resources\nand release them automatically when they are no longer needed, ensuring proper\ncleanup and preventing resource leaks even in the cas", "position": 15, "token_count": 249, "has_code": true, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "metadata": {"chunk_id": "errors-015", "document_id": "errors", "position": 15, "token_count": 249, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["This function compiles because it handles the possible error", "Handle an error"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#handle-an-error"}}
{"chunk_id": "errors-016", "document_id": "errors", "content": "e of error conditions.\n\nAs an example, consider reading data from a file. A naive approach might look\nlike this:\n\n```mojo\n# Obtain a file handle to read from storage\nf = open(input_file, \"r\")\ncontent = f.read()\n# Process the content as needed\n# Close the file handle\nf.close()\n```\n\nCalling [`close()`](/mojo/stdlib/builtin/file/FileHandle#close) releases the\nmemory and other operating system resources associated with the opened file. If", "position": 16, "token_count": 105, "has_code": true, "section_hierarchy": ["This function compiles because it handles the possible error", "Use a context manager"], "metadata": {"chunk_id": "errors-016", "document_id": "errors", "position": 16, "token_count": 105, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["This function compiles because it handles the possible error", "Use a context manager"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#use-a-context-manager"}}
{"chunk_id": "errors-017", "document_id": "errors", "content": "your program were to open many files without closing them, you could exhaust the\nresourc", "position": 17, "token_count": 19, "has_code": false, "section_hierarchy": ["Obtain a file handle to read from storage"], "metadata": {"chunk_id": "errors-017", "document_id": "errors", "position": 17, "token_count": 19, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Obtain a file handle to read from storage"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#obtain-a-file-handle-to-read-from-storage"}}
{"chunk_id": "errors-018", "document_id": "errors", "content": "es available to your program and", "position": 18, "token_count": 6, "has_code": false, "section_hierarchy": ["Process the content as needed"], "metadata": {"chunk_id": "errors-018", "document_id": "errors", "position": 18, "token_count": 6, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Process the content as needed"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#process-the-content-as-needed"}}
{"chunk_id": "errors-019", "document_id": "errors", "content": "cause errors. The problem is even worse\nif you were writing to a file instead of reading from it, because the operating\nsystem might buffer the output in memory until the file is closed. If your\nprogram were to crash instead of exiting normally, that buffered data could be\nlost instead of being written to storage.\n\nThe example above actually includes the call to `close()`, but it ignores the\npossibility that [`read()`](/mojo/stdlib/builtin/file/FileHandle#read) could\nraise an error, which would prevent the `close()` from executing.\nTo handle this scenario, you could rewrite the code to use `try` like this:\n\n```mojo\n# Obtain a file handle to read from storage\nf = open(input_file, \"r\")\n\ntry:\n content = f.read()\n # Process the content as needed\nfinally:\n # Ensure that the file handle is closed even if read() raises an error\n f.close()\n```\n\nHowever, the [`FileHandle`](/mojo/stdlib/builtin/file/FileHandle) struct\nreturned by [`ope", "position": 19, "token_count": 220, "has_code": true, "section_hierarchy": ["Close the file handle"], "metadata": {"chunk_id": "errors-019", "document_id": "errors", "position": 19, "token_count": 220, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Close the file handle"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#close-the-file-handle"}}
{"chunk_id": "errors-020", "document_id": "errors", "content": "n()`](/mojo/stdlib/builtin/file/open) is a context manager.\nWhen used with Mojo's `with` statement, a context manager ensures that the\nresources it manages are properly released at the end of the block, even if an\nerror occurs. In the case of a `FileHandle`, that means the call to `close()`\ntakes place automatically. So you could rewrite the example above to take\nadvantage of the context manager (and omit the explicit call to `close()`)\nlike this:\n\n```mojo\nwith open(input_file, \"r\") as f:\n content = f.read()\n # Process the content as needed\n```\n\nThe `with` statement also allows you to use multiple context managers within the\nsame code block. As an example, the following code opens one text file, reads\nits entire content, converts it to upper case, and then writes the result to a\ndifferent file:\n\n```mojo\nwith open(input_file, \"r\") as f_in, open(output_file, \"w\") as f_out:\n input_text = f_in.read()\n output_text = input_text.upper()\n f_out.write(output_text)\n```", "position": 20, "token_count": 239, "has_code": true, "section_hierarchy": ["Obtain a file handle to read from storage"], "metadata": {"chunk_id": "errors-020", "document_id": "errors", "position": 20, "token_count": 239, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Obtain a file handle to read from storage"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#obtain-a-file-handle-to-read-from-storage"}}
{"chunk_id": "errors-021", "document_id": "errors", "content": "```mojo\nwith open(input_file, \"r\") as f_in, open(output_file, \"w\") as f_out:\n input_text = f_in.read()\n output_text = input_text.upper()\n f_out.write(output_text)\n```\n\n`FileHandle` is perhaps the most commonly used context manager. Other examples\nof context managers in the Mojo standard library are\n[`NamedTemporaryFile`](/mojo/stdlib/tempfile/tempfile/NamedTemporaryFile),\n[`TemporaryDirectory`](/mojo/stdlib/tempfile/tempfile/TemporaryDirectory),\n[`BlockingScopedLock`](/mojo/stdlib/utils/lock/BlockingScopedLock), and\n[`assert_raises`](/mojo/stdlib/testing/testing/assert_raises). You can also\ncreate your own custom context managers, as described in [Write a custom context\nmanager](#write-a-custom-context-manager) below.\n\n## Write a custom context manager\n\nWriting a custom context manager is a matter of defining a\n[struct](/mojo/manual/structs) that implements two special *dunder* methods\n(\"double underscore\" methods): `__enter__()` and `__exit__()`:", "position": 21, "token_count": 233, "has_code": true, "section_hierarchy": ["Obtain a file handle to read from storage"], "metadata": {"chunk_id": "errors-021", "document_id": "errors", "position": 21, "token_count": 233, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Obtain a file handle to read from storage"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#obtain-a-file-handle-to-read-from-storage"}}
{"chunk_id": "errors-022", "document_id": "errors", "content": "uld initialize any state necessary for the context\n and return the context manager.\n\n- `__exit__()` is called when the `with` code block completes execution, even if\n the `with` code block terminates with a call to `continue`, `break`, or\n `return`. The `__exit__()` method should release any resources associated with\n the context. After the `__exit__()` method returns, the context manager is\n destroyed.\n\n If the `with` code block raises an error, then the `__exit__()` method runs\n before any error processing occurs (that is, before it is caught by a\n `try-except` structure or your program terminates). If you'd like to define\n conditional processing for error conditions in a `with` code block, you can\n implement an overloaded version of `__exit__()` that takes an `Error`\n argument. For more information, see [Define a conditional `__exit__()`\n method](#define-a-conditional-__exit__-method) below.", "position": 22, "token_count": 211, "has_code": false, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager"], "metadata": {"chunk_id": "errors-022", "document_id": "errors", "position": 22, "token_count": 211, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#write-a-custom-context-manager"}}
{"chunk_id": "errors-023", "document_id": "errors", "content": " For context managers that don't need to release resources or perform other\n actions on termination, you are not required to implement an `__exit__()`\n method. In that case the context manager is destroyed automatically after the\n `with` code block completes execution.\n\nHere is an example of implementing a `Timer` context manager, which prints the\namount of time spent executing the `with` code block:\n\n```mojo title=\"context_mgr.mojo\"\nimport sys\nimport time\n\n@fieldwise_init\nstruct Timer(ImplicitlyCopyable, Movable):\n var start_time: Int\n\n fn __init__(out self):\n self.start_time = 0\n\n fn __enter__(mut self) -> Self:\n self.start_time = Int(time.perf_counter_ns())\n return self\n\n fn __exit__(mut self):\n end_time = time.perf_counter_ns()\n elapsed_time_ms = round(((end_time - self.start_time) / 1e6), 3)\n print(\"Elapsed time:\", elapsed_time_ms, \"milliseconds\")\n\ndef main():\n with Timer():\n print(\"Beginning execution\")\n time.sleep(1.0)\n if len(sys.argv()) > 1:\n raise \"simulated error\"\n time.sleep(1.0)\n print(\"Ending execution\")\n```", "position": 23, "token_count": 254, "has_code": true, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager"], "metadata": {"chunk_id": "errors-023", "document_id": "errors", "position": 23, "token_count": 254, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#write-a-custom-context-manager"}}
{"chunk_id": "errors-024", "document_id": "errors", "content": "def main():\n with Timer():\n print(\"Beginning execution\")\n time.sleep(1.0)\n if len(sys.argv()) > 1:\n raise \"simulated error\"\n time.sleep(1.0)\n print(\"Ending execution\")\n```\n\nRunning this example produces output like this:\n\n```sh\nmojo context_mgr.mojo\n```\n\n```output\nBeginning execution\nEnding execution\nElapsed time: 2010.0 milliseconds\n```\n\n```sh\nmojo context_mgr.mojo fail\n```\n\n```output\nBeginning execution\nElapsed time: 1002.0 milliseconds\nUnhandled exception caught during execution: simulated error\n```\n\n### Define a conditional `__exit__()` method\n\nWhen creating a context manager, you can implement the `__exit__(self)` form of\nthe `__exit__()` method to handle completion of the `with` statement under all\ncircumstances including errors. However, you have the option of additionally\nimplementing an overloaded version that is invoked instead when an error occurs\nin the `with` code block:\n\n```mojo\nfn __exit__(self, error: Error) raises -> Bool\n```\n\nGiven the `Err", "position": 24, "token_count": 238, "has_code": true, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager"], "metadata": {"chunk_id": "errors-024", "document_id": "errors", "position": 24, "token_count": 238, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#write-a-custom-context-manager"}}
{"chunk_id": "errors-025", "document_id": "errors", "content": "or` that occurred as an argument, the method can do any of the\nfollowing actions:\n\n- Return `True` to suppress the error\n- Return `False` to re-raise the error\n- Raise a new error\n\nThe following is an example of a context manager that suppresses only a certain\ntype of error condition and propagates all others:\n\n```mojo title=\"conditional_context_mgr.mojo\"\nimport time\n\n@fieldwise_init\nstruct ConditionalTimer(ImplicitlyCopyable, Movable):\n var start_time: Int\n\n fn __init__(out self):\n self.start_time = 0\n\n fn __enter__(mut self) -> Self:\n self.start_time = Int(time.perf_counter_ns())\n return self\n\n fn __exit__(mut self):\n end_time = time.perf_counter_ns()\n elapsed_time_ms = round(((end_time - self.start_time) / 1e6), 3)\n print(\"Elapsed time:\", elapsed_time_ms, \"milliseconds\")\n\n fn __exit__(mut self, e: Error) raises -> Bool:\n if String(e) == \"just a warning\":\n print(\"Suppressing error:\", e)\n self.__exit__()\n return True\n else:\n print(\"Propagating error\")\n self.__exit__()\n return False", "position": 25, "token_count": 254, "has_code": true, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager", "Define a conditional `__exit__()` method"], "metadata": {"chunk_id": "errors-025", "document_id": "errors", "position": 25, "token_count": 254, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager", "Define a conditional `__exit__()` method"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#define-a-conditional-exit-method"}}
{"chunk_id": "errors-026", "document_id": "errors", "content": "def flaky_identity(n: Int) -> Int:\n if (n % 4) == 0:\n raise \"really bad\"\n elif (n % 2) == 0:\n raise \"just a warning\"\n else:\n return n\n\ndef main():\n for i in range(1, 9):\n with ConditionalTimer():\n print(\"\\nBeginning execution\")\n\n print(\"i =\", i)\n time.sleep(0.1)\n\n if i == 3:\n print(\"continue executed\")\n continue\n\n j = flaky_identity(i)\n print(\"j =\", j)\n\n print(\"Ending execution\")\n```\n\nRunning this example produces this output:\n\n```output\nBeginning execution\ni = 1\nj = 1\nEnding execution\nElapsed time: 105.0 milliseconds\n\nBeginning execution\ni = 2\nSuppressing error: just a warning\nElapsed time: 106.0 milliseconds\n\nBeginning execution\ni = 3\ncontinue executed\nElapsed time: 106.0 milliseconds\n\nBeginning execution\ni = 4\nPropagating error\nElapsed time: 106.0 milliseconds\nUnhandled exception caught during execution: really bad\n```", "position": 26, "token_count": 230, "has_code": true, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager", "Define a conditional `__exit__()` method"], "metadata": {"chunk_id": "errors-026", "document_id": "errors", "position": 26, "token_count": 230, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Obtain a file handle to read from storage", "Write a custom context manager", "Define a conditional `__exit__()` method"], "file_path": "errors.mdx", "url": "https://docs.modular.com/mojo/manual/errors", "title": "Errors, error handling, and context managers", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/errors#define-a-conditional-exit-method"}}

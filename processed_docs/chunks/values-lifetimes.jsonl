{"chunk_id": "values-lifetimes-000", "document_id": "values-lifetimes", "content": "The Mojo compiler includes a lifetime checker, a compiler pass that analyzes\ndataflow through your program. It identifies when variables are valid and\ninserts destructor calls when a variable's lifetime ends.\n\nThe Mojo compiler uses a special value called an *origin* to track the lifetime\nof variables and the validity of references.\n\nSpecifically, an origin answers two questions:\n\n* What variable \"owns\" this value?\n* Can the value be mutated using this reference?\n\nFor example, consider the following code:\n\n```mojo\nfn print_str(s: String):\n print(s)\n\nname = \"Joan\"\nprint_str(name)\n```\n\n```output\nJoan\n```\n\nThe line `name = \"Joan\"` declares a variable with an identifier (`name`)\nand logical storage space for a `String` value. When you pass `name` into the\n`print_str()` function, the function gets an immutable reference to the value.\nSo both `name` and `s` refer to the same logical storage space, and have\nassociated origin values that lets the Mojo compiler reason about them.\n\nMost of the time, origins are handled automatically by the compiler.\nHowever, in some cases you'll need to interact with origins directly:\n\n* When working with references—specifically `ref` arguments and `ref` return\n values.\n\n* When working with types like\n [`Pointer`](/mojo/stdlib/memory/pointer/Pointer) or\n [`Span`](/mojo/stdlib/memory/span/Span) which are parameterized on the\n origin of the data they refer to.\n\nThis section also covers [`ref` arguments](#ref-arguments) and\n[`ref` return values](#ref-return-values), which let functions\ntake arguments and provide return values as references with parametric\norigins.\n\n## Work", "position": 0, "token_count": 366, "has_code": true, "section_hierarchy": [], "metadata": {"chunk_id": "values-lifetimes-000", "document_id": "values-lifetimes", "position": 0, "token_count": 366, "has_code": true, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes"}}
{"chunk_id": "values-lifetimes-001", "document_id": "values-lifetimes", "content": "ing with origins\n\nMojo's origin values are unlike most other values in the language, because\nthey're primitive values, not Mojo structs.\n\nLikewise, because these values are mostly created by the\ncompiler, you can't just create your own origin value—you usually need to\nderive an origin from an existing value.\n\nAmong other things, Mojo uses origins to extend the lifetimes of referenced\nvalues, so values aren't destroyed prematurely.\n\n### Ori", "position": 1, "token_count": 91, "has_code": false, "section_hierarchy": ["Working with origins"], "metadata": {"chunk_id": "values-lifetimes-001", "document_id": "values-lifetimes", "position": 1, "token_count": 91, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Working with origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#working-with-origins"}}
{"chunk_id": "values-lifetimes-002", "document_id": "values-lifetimes", "content": "gin types\n\nMojo supplies a struct and a set of aliases that you can use to specify\norigin types. As the names suggest, the `ImmutableOrigin` and\n`MutableOrigin` aliases represent immutable and mutable origins,\nrespectively:\n\n```mojo\nstruct ImmutableRef[origin: ImmutableOrigin]:\n pass\n```\n\nOr you can use the [`Origin`](/mojo/stdlib/builtin/type_aliases/Origin)\nstruct to specify an origin with parametric mutability:\n\n```mojo\nstruct ParametricRef[\n is_mutable: Bool,\n //,\n origin: Origin[is_mutable]\n]:\n pass\n```\n\nOrigin types carry the mutability of a reference as a boolean parameter value,\nindicating whether the origin is mutable, immutable, or even with mutability\ndepending on a parameter specified by the enclosing API.\n\nThe `is_mutable` parameter here is an [infer-only\nparameter](/mojo/manual/parameters/#infer-only-parameters). The `origin` value\nis often inferred, as well. For example, the following code creates a\n[`Pointer`](/mojo/stdlib/memory/pointer/Pointer) to an existing value, but\ndoesn't need to specify an origin—the `origin` is inferred from the existing\nvalue.\n\n```mojo\nfrom memory import Pointer\n\ndef use_pointer():\n a = 10\n ptr = Pointer(to=a)\n```\n\n### Origin sets\n\nAn `OriginS", "position": 2, "token_count": 292, "has_code": true, "section_hierarchy": ["Working with origins", "Origin types"], "metadata": {"chunk_id": "values-lifetimes-002", "document_id": "values-lifetimes", "position": 2, "token_count": 292, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Working with origins", "Origin types"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#origin-types"}}
{"chunk_id": "values-lifetimes-003", "document_id": "values-lifetimes", "content": "et` is not a type of origin, it represents a group of origins. Origin\nsets are used for tracking the lifetimes of values captured in closures.\n\n### Origin values\n\nMost orig", "position": 3, "token_count": 38, "has_code": false, "section_hierarchy": ["Working with origins", "Origin sets"], "metadata": {"chunk_id": "values-lifetimes-003", "document_id": "values-lifetimes", "position": 3, "token_count": 38, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Working with origins", "Origin sets"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#origin-sets"}}
{"chunk_id": "values-lifetimes-004", "document_id": "values-lifetimes", "content": "in values are created by the compiler. As a developer, there are a\nfew ways to specify origin values:\n\n* Static origin. The `StaticConstantOrigin` alias is an origin value\n representing immutable values that last for the duration of the program.\n String literal values have a `StaticConstantOrigin`.\n* Derived origin. The `__origin_of()` magic function returns the origin\n associated with the value (or values) passed in.\n* Inferred origin. You can use inferred parameters to capture the origin of a\n value passed in to a function.\n* Wildcard origins. The `ImmutableAnyOrigin` and `MutableAnyOrigin` aliases are\n special cases indicating a reference that might access any live value.\n\n#### Static origins\n\nYou can use", "position": 4, "token_count": 151, "has_code": false, "section_hierarchy": ["Working with origins", "Origin values"], "metadata": {"chunk_id": "values-lifetimes-004", "document_id": "values-lifetimes", "position": 4, "token_count": 151, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Working with origins", "Origin values"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#origin-values"}}
{"chunk_id": "values-lifetimes-005", "document_id": "values-lifetimes", "content": "the static origin `StaticConstantOrigin` when you have a\nvalue that exists for the entire duration of the program.\n\nFor example, the `StringLiteral` method\n[`as_string_slice()`](/mojo/stdlib/builtin/string_literal/StringLiteral#as_string_slice)\nreturns a\n[`StringSlice`](/mojo/stdlib/collections/string/string_slice/StringSlice)\npointing to the original string literal. String literals are static—they're\nallocated at compile time and never destroyed—so the slice is created with an\nimmutable, static origin.\n\n#### Derived origins\n\nUse the `__", "position": 5, "token_count": 120, "has_code": false, "section_hierarchy": ["Working with origins", "Origin values", "Static origins"], "metadata": {"chunk_id": "values-lifetimes-005", "document_id": "values-lifetimes", "position": 5, "token_count": 120, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Working with origins", "Origin values", "Static origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#static-origins"}}
{"chunk_id": "values-lifetimes-006", "document_id": "values-lifetimes", "content": "origin_of(value)` operator to obtain a value's origin. An argument\nto `__origin_of()` can take an arbitrary expression that yields one of the\nfollowing:\n\n- An origin value.\n\n- A value with a memory location.\n\nFor example:\n\n```mojo\n__origin_of(self)\n__origin_of(x.y)\n__origin_of(foo())\n```\n\nThe `__origin_of()` operator is analyzed statically at compile time;\nThe expressions passed to `__origin_of()` are never evaluated. (For example,\nwhen the compiler analyzes `__origin_of(foo())`, it doesn't run the `foo()`\nfunction.)\n\nThe following struct stores a string value using a\n[`OwnedPointer`](/mojo/stdlib/memory/owned_pointer/OwnedPointer): a smart\npointer that holds an owned value. The `as_ptr()` method returns a `Pointer` to\nthe stored string, using the same origin as the original `OwnedPointer`.\n\n```mojo\nfrom memory import OwnedPointer, Pointer\n\nstruct BoxedString:\n var o_ptr: OwnedPointer[String]\n\n fn __init__(out self, value: String):\n self.o_ptr = OwnedPointer(value)\n\n fn as_ptr(mut self) -> Pointer[String, __origin_of(self.o_ptr)]:\n return Pointer(to=self.o_ptr[])\n```\n\nNote that the `as_ptr()` method takes its `self` argument as `mut self`. If it\nused the default `read` argument convention, it would be immutable, and the\nderived origin (`__origin_of(self.o_ptr)`) would also be immutable.\n\nYou can also pass multiple expressions to `__origin_of()` to express the union\nof two or more origins:\n\n`__origin_of(a, b)`\n\n#### Inferred origins\n\nThe other common way to access an", "position": 6, "token_count": 360, "has_code": true, "section_hierarchy": ["Working with origins", "Origin values", "Derived origins"], "metadata": {"chunk_id": "values-lifetimes-006", "document_id": "values-lifetimes", "position": 6, "token_count": 360, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Working with origins", "Origin values", "Derived origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#derived-origins"}}
{"chunk_id": "values-lifetimes-007", "document_id": "values-lifetimes", "content": "origin value is to *infer* it from the\nthe arguments passed to a function or method. For example, the `Span` type\nhas an associated `origin`:\n\n```mojo\nstruct Span[\n is_mutable: Bool, //,\n T: Copyable & Movable,\n origin: Origin[is_mutable],\n](CollectionElementNew):\n \"\"\"A non owning view of contiguous data.\n```\n\nOne of its constructors creates a `Span` from an existing `List`, and infers\nits `origin` value from the list:\n\n```mojo\n fn __init__(out self, ref [origin]list: List[T, *_]):\n \"\"\"Construct a Span from a List.\n\n Args:\n list: The list to which the span refers.\n \"\"\"\n self._data = list.data\n self._len = len(list)\n```\n\n#### Origin unions\n\nThe union of two or more origins creates a new origin that references both of\nthe original origin", "position": 7, "token_count": 193, "has_code": true, "section_hierarchy": ["Working with origins", "Origin values", "Inferred origins"], "metadata": {"chunk_id": "values-lifetimes-007", "document_id": "values-lifetimes", "position": 7, "token_count": 193, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Working with origins", "Origin values", "Inferred origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#inferred-origins"}}
{"chunk_id": "values-lifetimes-008", "document_id": "values-lifetimes", "content": "s for the purposes of lifetime extension (so a union of the\norigins of `a` and `b` extends both lifetimes).\n\nAn origin union is mutable if and only if all of its constituent origins are\nmutable. For an example, see\n[Return values with union origins](#return-values-with-union-origins).\n\n## Working with references\n\nYou can use the `ref` keyword with arguments and return values to specify a\nreference wit", "position": 8, "token_count": 94, "has_code": false, "section_hierarchy": ["Working with origins", "Origin values", "Origin unions"], "metadata": {"chunk_id": "values-lifetimes-008", "document_id": "values-lifetimes", "position": 8, "token_count": 94, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Working with origins", "Origin values", "Origin unions"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#origin-unions"}}
{"chunk_id": "values-lifetimes-009", "document_id": "values-lifetimes", "content": "h parametric mutability. That is, they can be either mutable or\nimmutable.\n\nFrom inside the called function, a `ref` argument looks like a `read` or\n`mut` argument.\n\nA `ref` return value looks like any other return value to the calling function,\nbut it is a *reference* to an existing value, not a copy.\n\n### `ref` arguments\n\nThe `ref` argument convention lets you specify an argument of parametric\nmutability: that is, yo", "position": 9, "token_count": 103, "has_code": false, "section_hierarchy": ["Working with references"], "metadata": {"chunk_id": "values-lifetimes-009", "document_id": "values-lifetimes", "position": 9, "token_count": 103, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Working with references"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#working-with-references"}}
{"chunk_id": "values-lifetimes-010", "document_id": "values-lifetimes", "content": "u don't need to know in advance whether the passed\nargument will be mutable or immutable. There are several reasons you might want\nto use a `ref` argument:\n\n* You want to accept an argument with parametric mutability.\n\n* You want to tie the lifetime of one argument to the lifetime of another\n argument.\n\n* When you want an argument that is guaranteed to be passed in memory: this can\n be important and useful for generic arguments that need an identity,\n irrespective of whether the concrete type is register passable.\n\nThe syntax for a `ref` argument is:\n\n<code><strong>ref</strong> <var>arg_name</var>: <var>arg_type</var></code>\n\nOr:\n\n<code><strong>ref [</strong><var>origin_specifier(s)</var><strong>]</strong>\n<var>arg_name</var>: <var>arg_type</var></code>\n\nIn the first form, the origin and mutability of the `ref` argument is inferred\nfrom the value passed in. The second form includes an origin clause, consisting\nof one or more origin specifiers inside square brackets. An origin\nspecifier can be either:\n\n* An origin value.\n\n* An arbitrary expression, which is treated as shorthand for\n `__origin_of(expression)`. In other words, the following declarations are\n equivalent:\n\n ```mojo\n ref [__origin_of(self)]\n ref [self]\n ```\n\n* An [`AddressSpace`](/nightly/mojo/stdlib/memory/pointer/AddressSpace) value.\n\n* An underscore character (`_`) to indicate that the origin is *unbound*. This\n is equivalent to omitting the origin specifier.\n\n ```mojo\n def add_ref(ref a: Int, b: Int) -> Int:\n return a+b\n ```", "position": 10, "token_count": 369, "has_code": true, "section_hierarchy": ["Working with references", "`ref` arguments"], "metadata": {"chunk_id": "values-lifetimes-010", "document_id": "values-lifetimes", "position": 10, "token_count": 369, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Working with references", "`ref` arguments"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#ref-arguments"}}
{"chunk_id": "values-lifetimes-011", "document_id": "values-lifetimes", "content": "* An [`AddressSpace`](/nightly/mojo/stdlib/memory/pointer/AddressSpace) value.\n\n* An underscore character (`_`) to indicate that the origin is *unbound*. This\n is equivalent to omitting the origin specifier.\n\n ```mojo\n def add_ref(ref a: Int, b: Int) -> Int:\n return a+b\n ```\n\nYou can also name the origin explicitly. This is useful if you want to specify\nan `ImmutableOrigin` or `MutableOrigin`, or if you want to bind to\nthe `is_mutable` parameter.\n\n```mojo\ndef take_str_ref[\n is_mutable: Bool, //,\n origin: Origin[is_mutable]\n ](ref [origin] s: String):\n @parameter\n if is_mutable:\n print(\"Mutable: \" + s)\n else:\n print(\"Immutable: \" + s)\n\ndef pass_refs(s1: String, var s2: String):\n take_str_ref(s1)\n take_str_ref(s2)\n\npass_refs(\"Hello\", \"Goodbye\")\n```\n\n```output\nImmutable: Hello\nMutable: Goodbye\n```\n\n### `ref` return values\n\nLike `ref` arguments, `ref` return values allow a function to return a mutable\nor immutable reference to a value. The syntax for a `ref` return value", "position": 11, "token_count": 273, "has_code": true, "section_hierarchy": ["Working with references", "`ref` arguments"], "metadata": {"chunk_id": "values-lifetimes-011", "document_id": "values-lifetimes", "position": 11, "token_count": 273, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Working with references", "`ref` arguments"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#ref-arguments"}}
{"chunk_id": "values-lifetimes-012", "document_id": "values-lifetimes", "content": "is:\n\n<code><strong>-> ref [</strong><var>origin_specifier(s)</var><strong>]</strong>\n <var>arg_type</var></code>\n\nNote that you **must** specify an origin specifier for a `ref` return value. The\nvalues allowed for origin specifiers are the same as the ones listed for\n[`ref` arguments](#ref-arguments).\n\n`ref` return values can be an efficient way to handle updating items in a\ncollection. The standard way to do this is by implementing the `__getitem__()`\nand `__setitem__()` dunder methods. These are invoked to read from and write to\na subscripted item in a collection:\n\n```mojo\nvalue = list[a]\nlist[b] += 10\n```\n\nWith a `ref` argument, `__getitem__()` can return a mutable reference that can\nbe modified directly. This has pros and cons compared to using a `__setitem__()`\nmethod:\n\n* The mutable reference is more efficient—a single update isn't broken up across\n two methods. However, the referenced value must be in memory.\n\n* A `__getitem__()`/`__setitem__()` pair allows for arbitrary code to be run\n when values are retrieved and set. For example, `__setitem__()` can validate\n or constrain input values.\n\nFor example, in the following example, `NameList` has a `__getitem__()` method\nthat returns a reference:\n\n```mojo\nstruct NameList:\n var names: List[String]\n\n def __init__(out self, *names: String):\n self.names = []\n for name in names:\n self.names.append(name)\n\n def __getitem__(ref self, index: Int) ->\n ref [self.names] String:\n if (index >=0 and index < len(self.names)):\n return self.names[index]\n else:\n raise Error(\"index out of bounds\")", "position": 12, "token_count": 392, "has_code": true, "section_hierarchy": ["Working with references", "`ref` return values"], "metadata": {"chunk_id": "values-lifetimes-012", "document_id": "values-lifetimes", "position": 12, "token_count": 392, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Working with references", "`ref` return values"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#ref-return-values"}}
{"chunk_id": "values-lifetimes-013", "document_id": "values-lifetimes", "content": " def __init__(out self, *names: String):\n self.names = []\n for name in names:\n self.names.append(name)\n\n def __getitem__(ref self, index: Int) ->\n ref [self.names] String:\n if (index >=0 and index < len(self.names)):\n return self.names[index]\n else:\n raise Error(\"index out of bounds\")\n\ndef main():\n list = NameList(\"Thor\", \"Athena\", \"Dana\", \"Vrinda\")\n ref name = list[2]\n print(name)\n name += \"?\"\n print(list[2])\n```\n\n```output\nDana\nDana?\n```\n\nNote the use of the `ref name` syntax to create a reference binding.\n\nIf you assign a `ref` return value to a variable, the variable receives a\n*copy* of the referenced item. Use a\n[reference binding](/mojo/manual/variables#reference-bindings) if you need to\ncapture the reference for future use:\n\n```mojo\nvar name_copy = list[2] # owned copy of list[2]\nref name_ref = list[2] # reference to list[2]\n```\n\n#### Parametric mutability of return values\n\nAnother advantage of `ref` return arguments is the ability to support parametric\nmutability. For example, recall the signature of the `__getitem__()` method\nabove:\n\n```mojo\ndef __getitem__(ref self, index: Int) ->\n ref [self] S", "position": 13, "token_count": 303, "has_code": true, "section_hierarchy": ["Working with references", "`ref` return values"], "metadata": {"chunk_id": "values-lifetimes-013", "document_id": "values-lifetimes", "position": 13, "token_count": 303, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Working with references", "`ref` return values"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#ref-return-values"}}
{"chunk_id": "values-lifetimes-014", "document_id": "values-lifetimes", "content": "tring:\n```\n\nSince the `origin` of the return value is tied to the origin of `self`, the\nreturned reference will be mutable if the method was called using a\nmutable reference. The method still works if you have an immutable reference\nto the `NameList`, but it returns an immutable reference:\n\n```mojo\nfn pass_immutable_list(list: NameList) raises:\n print(list[2])\n # list[2] += \"?\" # Error, this list is immutable\n\ndef main():\n list = NameList(\"Sophie\", \"Jack\", \"Diana\")\n pass_immutable_list(list)\n```\n\n```output\nDiana\n```\n\nWithout parametric mutability, you'd need to write two versions of\n`__getitem__()`, one that accepts an immutable `self` and another that accepts\na mutable `self`.\n\n#### Return values with union origins\n\nA `ref` return value can include multiple values in its origin specifier, which\nyields the union of the origins. For example, the following `pick_one()`\nfunction returns a reference to one of the two input strings, with an origin\nthat's a union of b", "position": 14, "token_count": 236, "has_code": true, "section_hierarchy": ["Working with references", "`ref` return values", "Parametric mutability of return values"], "metadata": {"chunk_id": "values-lifetimes-014", "document_id": "values-lifetimes", "position": 14, "token_count": 236, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Working with references", "`ref` return values", "Parametric mutability of return values"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#parametric-mutability-of-return-values"}}
{"chunk_id": "values-lifetimes-015", "document_id": "values-lifetimes", "content": "oth origins.\n\n```mojo\ndef pick_one(cond: Bool, ref a: String, ref b: String) -> ref [a, b] String:\n return a if cond else b\n```\n\nBecause the compiler can't statically determine which branch will be picked,\nthis function must use the union origin `[a, b]`. This ensures that the compiler\nextends the lifetime of _both_ values as long as the returned reference is live.\n\nThe returned reference is mutable if **both** `a` and `b` are mutable.", "position": 15, "token_count": 110, "has_code": true, "section_hierarchy": ["Working with references", "`ref` return values", "Return values with union origins"], "metadata": {"chunk_id": "values-lifetimes-015", "document_id": "values-lifetimes", "position": 15, "token_count": 110, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Working with references", "`ref` return values", "Return values with union origins"], "file_path": "values/lifetimes.mdx", "url": "https://docs.modular.com/mojo/manual/values/lifetimes", "title": "Lifetimes, origins, and references", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/values/lifetimes#return-values-with-union-origins"}}

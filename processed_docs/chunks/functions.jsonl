{"chunk_id": "functions-000", "document_id": "functions", "content": "As mentioned in the [syntax overview](/mojo/manual/basics), Mojo supports two\nkeywords to declare functions: `def` and `fn`. You can use either declaration\nwith any function, including the `main()` function, but they have different\ndefault behaviors, as described on this page.\n\nWe believe both `def` and `fn` have good use cases and don't consider either to\nbe better than the other. Deciding which to use is a matter of personal taste as\nto which style best fits a given task.\n\n[note]\nFunctions declared inside a [`struct`](/mojo/manual/structs) are called\n\"methods,\" but they have all the same qualities as \"functions\" described here.\n\n## Anat", "position": 0, "token_count": 151, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "functions-000", "document_id": "functions", "position": 0, "token_count": 151, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions"}}
{"chunk_id": "functions-001", "document_id": "functions", "content": "omy of a function\n\nBoth `def` and `fn` function declarations have the same basic components (here\ndemonstrated with a `def` function):\n\n<pre>\n<strong>def</strong> <var>function_name</var><strong>[\n&#8203; </strong><var>parameters ...</var><strong>\n](\n&#8203; </strong><var>arguments ...</var><strong>\n) -&gt;</strong> <var>return_value_type</var>:\n&#8203; <var>function_body</var>\n</pre>\n\nFunctions can have:\n\n- Parameters: A function can optionally take one or more compile-time\n _parameter_ values used for metaprogramming.\n- Arguments: A function can also optionally take one or more run-time\n _arguments_.\n- Return value: A function can optionally return a value.\n- Function body: Statements that are executed when you call the function.\n Function definitions must include a body.\n\nAll of the optional parts of the function can be omitted, so the minimal\nfunction is something like this:\n\n```mojo\ndef do_nothing():\n pass\n```\n\nIf a function takes no parameters, you can omit the square brackets, but the\nparentheses are always required.", "position": 1, "token_count": 256, "has_code": true, "section_hierarchy": ["Anatomy of a function"], "metadata": {"chunk_id": "functions-001", "document_id": "functions", "position": 1, "token_count": 256, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Anatomy of a function"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#anatomy-of-a-function"}}
{"chunk_id": "functions-002", "document_id": "functions", "content": "meters\n\nFunctions take two kinds of inputs: _arguments_ and _parameters_. Arguments are\nfamiliar from many other languages: they are run-time values passed into the\nfunction.\n\n```mojo\ndef add(a: Int, b: Int) -> Int:\n return a+b\n```\n\nOn the other hand, you can think of a parameter as a compile-time variable that\nbecomes a run-time constant. For example, consider the following function with a\nparameter:\n\n```mojo\ndef add_tensors[rank: Int](a: MyTensor[rank], b: MyTensor[rank]) -> MyTensor[rank]:\n # ...\n```\n\nIn this case, the `rank` value needs to be specified in a way that can be\ndetermined at compilation time, such as a literal or expression.\n\nWhen you compile a program that uses this code, the compiler produces a unique\nversion of the function for each unique `rank` value used in the program, with\n`rank` treated as a constant within each specialized version.", "position": 2, "token_count": 213, "has_code": true, "section_hierarchy": ["Anatomy of a function", "Arguments and parameters"], "metadata": {"chunk_id": "functions-002", "document_id": "functions", "position": 2, "token_count": 213, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Anatomy of a function", "Arguments and parameters"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#arguments-and-parameters"}}
{"chunk_id": "functions-003", "document_id": "functions", "content": "When you compile a program that uses this code, the compiler produces a unique\nversion of the function for each unique `rank` value used in the program, with\n`rank` treated as a constant within each specialized version.\n\nThis usage of \"parameter\"\nis probably different from what you're used to from other languages, where\n\"parameter\" and \"argument\" are often used interchangeably. In Mojo, \"parameter\"\nand \"parameter expression\" refer to compile-time values, and \"argument\" and\n\"expression\" refer to run-time values.\n\nBy default, both arguments and parameters can be specified either by position or\nby keyword. These forms can also be mixed in the same function call.\n\n```mojo\n# positional\nx = add(5, 7) #", "position": 3, "token_count": 159, "has_code": true, "section_hierarchy": ["Anatomy of a function", "Arguments and parameters"], "metadata": {"chunk_id": "functions-003", "document_id": "functions", "position": 3, "token_count": 159, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Anatomy of a function", "Arguments and parameters"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#arguments-and-parameters"}}
{"chunk_id": "functions-004", "document_id": "functions", "content": "Positionally, a=5 and b=7\n# keyword\ny = add(b=3, a=9)\n# mix", "position": 4, "token_count": 27, "has_code": false, "section_hierarchy": ["positional"], "metadata": {"chunk_id": "functions-004", "document_id": "functions", "position": 4, "token_count": 27, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["positional"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#positional"}}
{"chunk_id": "functions-005", "document_id": "functions", "content": "ed\nz = add(5, b=7) # Positio", "position": 5, "token_count": 16, "has_code": false, "section_hierarchy": ["keyword"], "metadata": {"chunk_id": "functions-005", "document_id": "functions", "position": 5, "token_count": 16, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["keyword"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#keyword"}}
{"chunk_id": "functions-006", "document_id": "functions", "content": "nally, a=5\n```\n\nFor more information on arguments, see [Function arguments](#function-arguments)\non this page. For more information on parameters, see\n[Parameterization: compile-time metaprogramming](/mojo/manual/parameters/).\n\n## `def` and `fn` comparison\n\nDefini", "position": 6, "token_count": 68, "has_code": true, "section_hierarchy": ["mixed"], "metadata": {"chunk_id": "functions-006", "document_id": "functions", "position": 6, "token_count": 68, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#mixed"}}
{"chunk_id": "functions-007", "document_id": "functions", "content": "ng a function using `def` and `fn` have much in common. They both have the\nfollowing requirements:\n\n* You must declare the type of each function parameter and argument.\n\n* If a function doesn't return a value, you can either omit the return type or\n declare `None` as the return type.\n\n ```mojo\n # The following function definitions are equivalent\n\n def greet(name: String):\n print(\"Hello,\" name)\n\n def greet(name: String) -> None:\n print(\"Hello,\" name)\n ```\n\n* If the function returns a value, you must either declare the return type using\n the <code><strong>-></strong> <var>type</var></code> syntax or provide a\n [named result](#named-results) in the argument list.\n\n ```mojo\n # The following function definitions are equivalent\n\n def incr(a: Int) -> Int:\n return a + 1\n\n def incr(a: Int, out b: Int):\n b = a + 1\n ```\n\n For more information, see the [Return values](#return-values) section of this\n page.\n\nWhere `def` and `fn` differ is error handling.", "position": 7, "token_count": 240, "has_code": true, "section_hierarchy": ["mixed", "`def` and `fn` comparison"], "metadata": {"chunk_id": "functions-007", "document_id": "functions", "position": 7, "token_count": 240, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "`def` and `fn` comparison"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#def-and-fn-comparison"}}
{"chunk_id": "functions-008", "document_id": "functions", "content": " For more information, see the [Return values](#return-values) section of this\n page.\n\nWhere `def` and `fn` differ is error handling.\n\n* The compiler doesn't allow a function declared with `fn` to raise an error\n condition unless it explicitly includes a `raises` declaration. In contrast,\n the compiler assumes that *all* functions declared with `def` *might* raise an\n error. See the [Raising and non-raising\n functions](#raising-and-non-raising-functions) section of this page for more\n information.\n\nAs far as a function caller is concerned, there is no difference between\ninvoking a function declared with `def` vs a function declared with `fn`. You\ncould reimplement a `def` function as an `fn` function without making any\nchanges to code that calls the function.\n\n## Function arguments\n\nThe rules for arguments described in this sec", "position": 8, "token_count": 187, "has_code": false, "section_hierarchy": ["mixed", "`def` and `fn` comparison"], "metadata": {"chunk_id": "functions-008", "document_id": "functions", "position": 8, "token_count": 187, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["mixed", "`def` and `fn` comparison"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#def-and-fn-comparison"}}
{"chunk_id": "functions-009", "document_id": "functions", "content": "tion apply to both `def`\nand `fn` functions.\n\nnote Functions with / and * in the argument list\n\nYou might see the following characters in\nplace of arguments: slash (`/`) and/or star (`*`). For example:\n\n```mojo\ndef myfunc(pos_only, /, pos_or_keyword, *, keyword_only):\n```\n\nArguments **before** the `/` can be passed only by position. Arguments **after**\nthe `*` can be passed only by keyword. For details, see\n[Positional-only and keyword-only arguments](#positional-only-and-keyword-only-arguments)\n\nYou may also see argument names prefixed with one or two stars (`*`):\n\n```mojo\ndef myfunc2(*names, **attributes):\n```\nAn argument name prefixed by a single star character, like `*names` identifies a\n[variadic argument](#variadic-arguments), while an argument name prefixed with\na double star, like `**attributes` identifies a\n[variadic keyword-only argument](#variadic-keyword-arguments).\n\n### Optional arguments\n\nAn optional argument is one that includes a default", "position": 9, "token_count": 233, "has_code": true, "section_hierarchy": ["mixed", "Function arguments"], "metadata": {"chunk_id": "functions-009", "document_id": "functions", "position": 9, "token_count": 233, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#function-arguments"}}
{"chunk_id": "functions-010", "document_id": "functions", "content": "value, such as the `exp`\nargument here:\n\n```mojo\nfn my_pow(base: Int, exp: Int = 2) -> Int:\n return base ** exp\n\nfn use_defaults():\n # Uses the default value for `exp`\n var z = my_pow(3)\n print(z)\n```\n\nHowever, you can't define a default value for an argument that's declared with\nthe [`mut`](/mojo/manual/values/ownership#mutable-arguments-mut) argument\nconvention.\n\nAny optional arguments must appear after any required arguments. [Keyword-only\narguments](#positional-only-and-keyword-only-arguments), discussed later, can\nalso be either required or optional.\n\n### Keyword arguments\n\nYou can also use keyword arguments when calling a function. Keywo", "position": 10, "token_count": 159, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Optional arguments"], "metadata": {"chunk_id": "functions-010", "document_id": "functions", "position": 10, "token_count": 159, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments", "Optional arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#optional-arguments"}}
{"chunk_id": "functions-011", "document_id": "functions", "content": "rd arguments\nare specified using the format\n<code><var>argument_name</var> = <var>argument_value</var></code>.\nYou can pass keyword arguments in any order:\n\n```mojo\nfn my_pow(base: Int, exp: Int = 2) -> Int:\n return base ** exp\n\nfn use_keywords():\n # Uses keyword argument names (with order reversed)\n var z = my_pow(exp=3, base=2)\n print(z)\n```\n\n### Variadic arguments\n\nVariadic arguments let a function accept a variable number of arguments. To", "position": 11, "token_count": 116, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Keyword arguments"], "metadata": {"chunk_id": "functions-011", "document_id": "functions", "position": 11, "token_count": 116, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments", "Keyword arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#keyword-arguments"}}
{"chunk_id": "functions-012", "document_id": "functions", "content": "define a function that takes a variadic argument, use the variadic argument\nsyntax <code>*<var>argument_name</var></code>:\n\n```mojo\nfn sum(*values: Int) -> Int:\n var sum: Int = 0\n for value in values:\n sum = sum + value\n return sum\n```\n\nThe variadic argument `values` here is a placeholder that accepts any number of\npassed positional arguments.\n\nYou can define zero or more arguments before the variadic argument. When calling\nthe function, any remaining positional arguments are assigned to the variadic\nargument, so any arguments declared **after** the variadic argument can only be\nspecified by keyword (see\n[Positional-only and keyword-only arguments](#positional-only-and-keyword-only-arguments)).\n\nVariadic arguments can be divided into two categories:\n\n* Homogeneous variadic arguments, where all of the passed arguments are the same\n type—all `Int`, or all `String`, for example.\n* Heterogeneous variadic arguments, which can accept a set of different argument\n types.\n\nThe following sections describe how to work with homogeneous and heterogeneous\nvariadic arguments.\n\nnote Variadic parameters", "position": 12, "token_count": 243, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments"], "metadata": {"chunk_id": "functions-012", "document_id": "functions", "position": 12, "token_count": 243, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#variadic-arguments"}}
{"chunk_id": "functions-013", "document_id": "functions", "content": "ype), use <code>*<var>argument_name</var>: <var>argument_type</var></code>:\n\n```mojo\ndef greet(*names: String):\n ...\n```\n\nInside the function body, the variadic argument is available as an iterable list\nfor ease of use. Currently there are some differences in handling the list\ndepending on whether the arguments are register-passable types (such as `Int`)\nor memory-only types (such as `String`).\n\nnote TODO\n\nWe hope to remove these differences in the future.\n\nRegister-passable types, such as `Int`, are available as a\n[`VariadicList`](/mojo/stdlib/builtin/variadics/VariadicList) type. As\nshown in the previous example, you can iterate over the values using a `for..in`\nloop.\n\n```mojo\nfn sum(*values: Int) -> Int:\n var sum: Int = 0\n for value in values:\n sum = sum+value\n return sum\n```", "position": 13, "token_count": 208, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Homogeneous variadic arguments"], "metadata": {"chunk_id": "functions-013", "document_id": "functions", "position": 13, "token_count": 208, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Homogeneous variadic arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#homogeneous-variadic-arguments"}}
{"chunk_id": "functions-014", "document_id": "functions", "content": "```mojo\nfn sum(*values: Int) -> Int:\n var sum: Int = 0\n for value in values:\n sum = sum+value\n return sum\n```\n\nMemory-only types, such as `String`, are available as a\n[`VariadicListMem`](/mojo/stdlib/builtin/variadics/VariadicListMem).\nIterating over this list directly with a `for..in` loop currently produces a\nreference to the element, which can be mutable with a `mut` variadic list. Use\nthe `ref` binding pattern to capture a mutable reference if you\nwant to mutate the elements of the list:\n\n```mojo\ndef make_worldly(mut *strs: String):\n for ref i in strs:\n i += \" world\"\n```\n\nYou can also directly index the list with integers as well:\n\n```mojo\nfn make_worldly(mut *strs: String):\n for i in range(len(strs)):\n strs[i] += \" world\"\n```\n\n#### Heterogeneous variadic arguments\n\nImplementing heterogeneous variadic arguments (each argument type may be\ndifferent) is somewhat more complicated t", "position": 14, "token_count": 236, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Homogeneous variadic arguments"], "metadata": {"chunk_id": "functions-014", "document_id": "functions", "position": 14, "token_count": 236, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Homogeneous variadic arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#homogeneous-variadic-arguments"}}
{"chunk_id": "functions-015", "document_id": "functions", "content": "han homogeneous variadic arguments. To\nhandle multiple argument types, the function must be\n[generic](/mojo/manual/functions/#variadic-arguments), which requires using\n[traits](/mojo/manual/traits) and [parameters](/mojo/manual/parameters/). So\nthe syntax may look a little unfamiliar if you haven't worked with those\nfeatures.\n\nThe signature for a function with a heterogeneous variadic argument looks like\nthis:\n\n```mojo\ndef count_many_things[*ArgTypes: Intable](*args: *ArgTypes):\n ...\n```\n\nThe parameter list, `[*ArgTypes: Intable]` specifies that the function takes an\n`ArgTypes` parameter, which is a list of types, all of which conform to the\n[`Intable`](/mojo/stdlib/builtin/int/Intable) trait. The asterisk in `*ArgTypes`\nindicates that `ArgTypes` is a **variadic type parameter** (a list of types).", "position": 15, "token_count": 207, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Heterogeneous variadic arguments"], "metadata": {"chunk_id": "functions-015", "document_id": "functions", "position": 15, "token_count": 207, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Heterogeneous variadic arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#heterogeneous-variadic-arguments"}}
{"chunk_id": "functions-016", "document_id": "functions", "content": "The argument list, `(*args: *ArgTypes)` has the familiar `*args` for the\nvariadic argument, but instead of a single type, its type is defined as the\nvariadic type list `*ArgTypes`. The asterisk in `*args` indicates a\n**variadic argument**, and the asterisk in `*ArgTypes` refers to the\nvariadic type parameter.\n\nThis means that each argument in `args` has a corresponding type in `ArgTypes`,\nso <code>args[<var>n</var>]</code> is of type <code>ArgTypes[<var>n</var>]</code>.", "position": 16, "token_count": 135, "has_code": false, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Heterogeneous variadic arguments"], "metadata": {"chunk_id": "functions-016", "document_id": "functions", "position": 16, "token_count": 135, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Heterogeneous variadic arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#heterogeneous-variadic-arguments"}}
{"chunk_id": "functions-017", "document_id": "functions", "content": "Inside the function, `args` becomes a\n[`VariadicPack`](/mojo/stdlib/builtin/variadics/VariadicPack) because the\nsyntax `*args: *ArgTypes` creates a heterogeneous variadic argument. That means\neach element in `args` can be a different type that requires a different amount\nof memory. To iterate through the `VariadicPack`, the compiler must know each\nelement's type (its memory size), so you must use a [parametric `for`\nloop](/mojo/manual/decorators/parameter/#parametric-for-statement):\n\n```mojo\nfn count_many_things[*ArgTypes: Intable](*args: *ArgTypes) -> Int:\n var total = 0\n\n @parameter\n for i in range(args.__len__()):\n total += Int(args[i])\n\n return total\n\ndef main():\n print(count_many_things(5, 11.7, 12))\n```\n\n```output\n28\n```\n\nNotice that when calling `count_many_things()`, you don't actually pass in\na list of argument types. You only need to pass in the arguments, and Mojo\ngenerates the `ArgTypes` list itself.\n\n#### Variadic keyword arguments", "position": 17, "token_count": 257, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Heterogeneous variadic arguments"], "metadata": {"chunk_id": "functions-017", "document_id": "functions", "position": 17, "token_count": 257, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Heterogeneous variadic arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#heterogeneous-variadic-arguments"}}
{"chunk_id": "functions-018", "document_id": "functions", "content": "ord\narguments. To define a function that takes a variadic keyword argument, use the\nvariadic keyword argument syntax <code>**<var>kw_argument_name</var></code>:\n\n```mojo\nfn print_nicely(**kwargs: Int) raises:\n for key in kwargs.keys():\n print(key, \"=\", kwargs[key])\n\n # prints:\n # `a = 7`\n # `y = 8`\nprint_nicely(a=7, y=8)\n```\n\nIn this example, the argument name `kwargs` is a placeholder that accepts any\nnumber of keyword arguments. Inside the body of the function, you can access\nthe arguments as a dictionary of keywords and argument values (specifically,\nan instance of\n[`OwnedKwargsDict`](/mojo/stdlib/collections/dict/OwnedKwargsDict)).\n\nThere are currently a few limitations:\n\n* Variadic keyword arguments are always implicitly treated as if they\n were declared with the `owned` [argument\n convention](/mojo/manual/values/ownership#argument-conventions), and\n can't be declared otherwise:\n\n ```mojo\n # Not supported yet.\n fn read_var_kwargs(read **kwargs: Int): ...\n ```", "position": 18, "token_count": 246, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Variadic keyword arguments"], "metadata": {"chunk_id": "functions-018", "document_id": "functions", "position": 18, "token_count": 246, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Variadic keyword arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#variadic-keyword-arguments"}}
{"chunk_id": "functions-019", "document_id": "functions", "content": " ```mojo\n # Not supported yet.\n fn read_var_kwargs(read **kwargs: Int): ...\n ```\n\n* All the variadic keyword arguments must have the same type, and this\n determines the type of the argument dictionary. For example, if the argument\n is `**kwargs: Float64` then the argument dictionary will be a\n `OwnedKwargsDict[Float64]`.\n\n* The argument type must conform to both the\n [`Movable`](/mojo/stdlib/builtin/value/Movable) and\n [`Copyable`](/mojo/stdlib/builtin/value/Copyable) traits.\n\n* Dictionary unpacking is not supported yet:\n\n ```mojo\n fn takes_dict(d: Dict[String, Int]):\n print_nicely(**d) # Not supported yet.\n ```\n\n* Variadic keyword *parameters* are not supported yet:\n\n ```mojo\n # Not supported yet.\n fn var_kwparams[**kwparams: Int](): ...\n ```\n\n### Positional-only and keyword-only arguments\n\nWhen defining a function, you can restrict some arguments so that they can\nbe passed only as positional arguments, or they can be passed only as keyword\nargumen", "position": 19, "token_count": 239, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Variadic keyword arguments"], "metadata": {"chunk_id": "functions-019", "document_id": "functions", "position": 19, "token_count": 239, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Function arguments", "Variadic arguments", "Variadic keyword arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#variadic-keyword-arguments"}}
{"chunk_id": "functions-020", "document_id": "functions", "content": "ts.\n\nTo define positional-only arguments, add a slash character (`/`) to the\nargument list. Any arguments before the `/` are positional-only: they can't be\npassed as keyword arguments. For example:\n\n```mojo\nfn min(a: Int, b: Int, /) -> Int:\n return a if a < b else b\n```\n\nThis `min()` function can be called with `min(1, 2)` but can't be called using\nkeywords, like `min(a=1, b=2)`.\n\nThere are several reasons you might want to write a function with\npositional-only arguments:\n\n* The argument names aren't meaningful for the caller.\n* You want the freedom to change the argument names later on without breaking\n backward compatibility.\n\nFor example, in the `min()` function, the argument names don't add any real\ninformation, and there's no reason to specify arguments by keyword.\n\nFor more information on positional-only arguments, see [PEP 570 – Python\nPositional-Only Parameters](https://peps.python.org/pep-0570/).", "position": 20, "token_count": 228, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Positional-only and keyword-only arguments"], "metadata": {"chunk_id": "functions-020", "document_id": "functions", "position": 20, "token_count": 228, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Function arguments", "Positional-only and keyword-only arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#positional-only-and-keyword-only-arguments"}}
{"chunk_id": "functions-021", "document_id": "functions", "content": "For more information on positional-only arguments, see [PEP 570 – Python\nPositional-Only Parameters](https://peps.python.org/pep-0570/).\n\nKeyword-only arguments are the inverse of positional-only arguments: they can\nbe specified only by keyword. If a function accepts variadic arguments, any\narguments defined *after* the variadic arguments are treated as keyword-only.\nFor example:\n\n```mojo\nfn sort(*values: Float64, ascending: Bool = True): ...\n```\n\nIn this example, the user can pass any number of `Float64` values, optionally\nfollowed by the keyword `ascending` argument:\n\n```mojo\nvar a = sort(1.1, 6.5, 4.3, ascending=False)\n```\n\nIf the function doesn't accept variadic arguments, you can add a single star\n(`*`) to the argument list to separate the keyword-only arguments:\n\n```mojo\nfn kw_only_args(a1: Int, a2: Int, *, double: Bool) -> Int:\n var product = a1 * a2\n if double:\n return product * 2\n else:\n return product\n```", "position": 21, "token_count": 244, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Positional-only and keyword-only arguments"], "metadata": {"chunk_id": "functions-021", "document_id": "functions", "position": 21, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Function arguments", "Positional-only and keyword-only arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#positional-only-and-keyword-only-arguments"}}
{"chunk_id": "functions-022", "document_id": "functions", "content": "```mojo\nfn kw_only_args(a1: Int, a2: Int, *, double: Bool) -> Int:\n var product = a1 * a2\n if double:\n return product * 2\n else:\n return product\n```\n\nKeyword-only arguments often have default values, but this is not required. If a\nkeyword-only argument doesn't have a default value, it is a *required\nkeyword-only argument*. It must be specified, and it must be specified by\nkeyword.\n\nAny required keyword-only arguments must appear in the signature before\nany optional keyword-only arguments. That is, arguments appear in the following\nsequence a function signature:\n\n* Required positional arguments.\n* Optional positional arguments.\n* Variadic arguments.\n* Required keyword-only arguments.\n* Optional keyword-only arguments.\n* Variadic keyword arguments.\n\nFor more information on keyword-only arguments, see [PEP 3102 – Keyword-Only\nArguments](https://peps.python.org/pep-3102/).\n\n## Overloaded functions\n\nAll function declarations must specify argument types, so if you want a\nwant a function to work with different data types, you need to implement\nseparate versions of the function that each specify different arg", "position": 22, "token_count": 248, "has_code": true, "section_hierarchy": ["mixed", "Function arguments", "Positional-only and keyword-only arguments"], "metadata": {"chunk_id": "functions-022", "document_id": "functions", "position": 22, "token_count": 248, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Function arguments", "Positional-only and keyword-only arguments"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#positional-only-and-keyword-only-arguments"}}
{"chunk_id": "functions-023", "document_id": "functions", "content": "ument types.\nThis is called \"overloading\" a function.\n\nFor example, here's an overloaded `add()` function that can accept either\n`Int` or `String` types:\n\n```mojo\nfn add(x: Int, y: Int) -> Int:\n return x + y\n\nfn add(x: String, y: String) -> String:\n return x + y\n```\n\nIf you pass anything other than `Int` or `String` to the `add()` function,\nyou'll get a compiler error. That is, unless `Int` or `String` can implicitly\ncast the type into their own type. For example, `String` includes an overloaded\nversion of its constructor (`__init__()`) that supports\n[implicit conversion](/mojo/manual/lifecycle/life#constructors-and-implicit-conversion)\nfrom a `StringLiteral` value. Thus, you can also pass a `StringLiteral` to a\nfunction that expects a `String`.", "position": 23, "token_count": 201, "has_code": true, "section_hierarchy": ["mixed", "Overloaded functions"], "metadata": {"chunk_id": "functions-023", "document_id": "functions", "position": 23, "token_count": 201, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Overloaded functions"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#overloaded-functions"}}
{"chunk_id": "functions-024", "document_id": "functions", "content": "When resolving an overloaded function call, the Mojo compiler tries each\ncandidate function and uses the one that works (if only one version works), or\nit picks the closest match (if it can determine a close match), or it reports\nthat the call is ambiguous (if it can't figure out which one to pick). For\ndetails on how Mojo picks the best candidate, see\n[Overload resolution](#overload-resolution).\n\nIf the compiler can't figure out which function to use, you can resolve the\nambiguity by explicitly casting your value to a supported argument type. For\nexample, the following code calls the overloaded `foo()` function,\nbut both implementations accept an argument that supports [implicit\nconversion](/mojo/manual/lifecycle/life#constructors-and-implicit-conversion)\nfrom `StringLiteral`. So, the call to `foo(string)` is ambiguous and creates a\ncompiler error. You can fix this by casting the value to the type you really\nwant:\n\n```mojo\nstruct MyString:\n @implicit\n fn __init__(out self, string: StringLiteral):\n pass\n\nfn foo(name: String):\n print(\"String\")\n\nfn foo(name: MyString):\n print(\"MyString\")", "position": 24, "token_count": 250, "has_code": true, "section_hierarchy": ["mixed", "Overloaded functions"], "metadata": {"chunk_id": "functions-024", "document_id": "functions", "position": 24, "token_count": 250, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Overloaded functions"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#overloaded-functions"}}
{"chunk_id": "functions-025", "document_id": "functions", "content": "```mojo\nstruct MyString:\n @implicit\n fn __init__(out self, string: StringLiteral):\n pass\n\nfn foo(name: String):\n print(\"String\")\n\nfn foo(name: MyString):\n print(\"MyString\")\n\nfn call_foo():\n alias string: StringLiteral = \"Hello\"\n # foo(string) # error: ambiguous call to 'foo' ... This call is ambiguous because two `foo` functions match it\n foo(MyString(string))\n```\n\nOverloading also works with combinations of both `fn` and `def` function\ndeclarations.\n\n### Overload resolution\n\nWhen resolving an overloaded function, Mojo does not consider the return type\nor other contextual information at the call site—it considers only parameter and\nargument types and whether the functions are instance methods or static methods.\n\nThe", "position": 25, "token_count": 162, "has_code": true, "section_hierarchy": ["mixed", "Overloaded functions"], "metadata": {"chunk_id": "functions-025", "document_id": "functions", "position": 25, "token_count": 162, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Overloaded functions"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#overloaded-functions"}}
{"chunk_id": "functions-026", "document_id": "functions", "content": "overload resolution logic filters for candidates according to the following\nrules, in order of precedence:\n\n1. Candidates requiring the smallest number of implicit conversions (in both\n arguments and parameters).\n2. Candidates without variadic arguments.\n3. Candidates without variadic parameters.\n4. Candidates with the shortest parameter signature.\n5. Non-`@staticmethod` candidates (over `@staticmethod` ones, if available).\n\nIf there is more than one candidate after applying these rules, the overload\nresolution fails. For example:\n\n```mojo\n@register_passable(\"trivial\")\nstruct MyInt:\n \"\"\"A type that is implicitly convertible to `Int`.\"\"\"\n var value: Int\n\n @implicit\n fn __init__(out self, _a: Int):\n self.value = _a\n\nfn foo[x: MyInt, a: Int]():\n print(\"foo[x: MyInt, a: Int]()\")\n\nfn foo[x: MyInt, y: MyInt]():\n print(\"foo[x: MyInt, y: MyInt]()\")\n\nfn bar[a: Int](b: Int):\n print(\"bar[a: Int](b: Int)\")\n\nfn bar[a: Int](*b: Int):\n print(\"bar[a: Int](*b: Int)\")", "position": 26, "token_count": 252, "has_code": true, "section_hierarchy": ["mixed", "Overloaded functions", "Overload resolution"], "metadata": {"chunk_id": "functions-026", "document_id": "functions", "position": 26, "token_count": 252, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Overloaded functions", "Overload resolution"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#overload-resolution"}}
{"chunk_id": "functions-027", "document_id": "functions", "content": "fn bar[a: Int](b: Int):\n print(\"bar[a: Int](b: Int)\")\n\nfn bar[a: Int](*b: Int):\n print(\"bar[a: Int](*b: Int)\")\n\nfn bar[*a: Int](b: Int):\n print(\"bar[*a: Int](b: Int)\")\n\nfn parameter_overloads[a: Int, b: Int, x: MyInt]():\n # `foo[x: MyInt, a: Int]()` is called because it requires no implicit\n # conversions, whereas `foo[x: MyInt, y: MyInt]()` requires one.\n foo[x, a]()\n\n # `bar[a: Int](b: Int)` is called because it does not have variadic\n # arguments or parameters.\n bar[a](b)\n\n # `bar[*a: Int](b: Int)` is called because it has variadic parameters.\n bar[a, a, a](b)\n\nparameter_overloads[1, 2, MyInt(3)]()\n\nstruct MyStruct:\n fn __init__(out self):\n pass\n\n fn foo(mut self):\n print(\"calling instance method\")\n\n @staticmethod\n fn foo():\n print(\"calling static method\")", "position": 27, "token_count": 244, "has_code": false, "section_hierarchy": ["mixed", "Overloaded functions", "Overload resolution"], "metadata": {"chunk_id": "functions-027", "document_id": "functions", "position": 27, "token_count": 244, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Overloaded functions", "Overload resolution"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#overload-resolution"}}
{"chunk_id": "functions-028", "document_id": "functions", "content": "parameter_overloads[1, 2, MyInt(3)]()\n\nstruct MyStruct:\n fn __init__(out self):\n pass\n\n fn foo(mut self):\n print(\"calling instance method\")\n\n @staticmethod\n fn foo():\n print(\"calling static method\")\n\nfn test_static_overload():\n var a = MyStruct()\n # `foo(mut self)` takes precedence over a static method.\n a.foo()\n```\n\n```output\nfoo[x: MyInt, a: Int]()\nbar[a: Int](b: Int)\nbar[*a: Int](b: Int)\n```\n\n## Return values\n\nReturn value types are declared in the signature using the\n<code><strong>-></strong> <var>type</var></code> syntax. Values are\npassed using the `return` keyword, which ends the function and returns the\nidentified value (if any) to the caller.\n\n```mojo\ndef get_greeting() -> String:\n return \"Hello\"\n```\n\nBy default, the value is returned to the caller as", "position": 28, "token_count": 208, "has_code": true, "section_hierarchy": ["mixed", "Overloaded functions", "Overload resolution"], "metadata": {"chunk_id": "functions-028", "document_id": "functions", "position": 28, "token_count": 208, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Overloaded functions", "Overload resolution"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#overload-resolution"}}
{"chunk_id": "functions-029", "document_id": "functions", "content": "an owned value. As with\narguments, a return value may be [implicitly\nconverted](/mojo/manual/lifecycle/life#constructors-and-implicit-conversion) to\nthe named return type. For example, the previous example calls `return` with a\nstring literal, `\"Hello\"`, which is implicitly converted to a `String`.\n\nnote Returning a reference\n\nA function can also return a mutable or immutable reference using a `ref` return\nvalue. For details, see\n[Lifetimes, origins, and references](/mojo/manual/values/lifetimes).\n\n### Named results\n\nNamed function results allow a function to return a value that can't be moved or\ncopied. Named result syntax lets you specify a named, uninitialized variable to\nreturn to the caller using the `out` argument convention:\n\n```mojo\ndef get_name_tag(var name: String, out name_tag: NameTag):\n name_tag = NameTag(name^)\n```\n\nThe `out` argument convention identifies an", "position": 29, "token_count": 206, "has_code": true, "section_hierarchy": ["mixed", "Return values"], "metadata": {"chunk_id": "functions-029", "document_id": "functions", "position": 29, "token_count": 206, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Return values"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#return-values"}}
{"chunk_id": "functions-030", "document_id": "functions", "content": "uninitialized variable that the\nfunction must initialize. (This is the same as the `out` convention used in\n[struct constructors](/mojo/manual/lifecycle/life#constructor).) The `out`\nargument for a named result can appear anywhere in the argument list, but by\nconvention, it should be the last argument in the list.\n\nA function can declare only one return value, whether it's declared using an\n`out` argument or using the standard <code><strong>-></strong>\n<var>type</var></code> syntax.\n\nA function with a named result argument doesn't need to include an explicit\n`return` statement, as shown above. If the function terminates without a `return`,\nor at a `return` statement with no value, the value of the `out` argument is\nreturned to the caller. If it includes a `return` statement with a value, that\nvalue is returned to the caller, as usual.\n\nThe fact that a function uses a named result is transparent to the caller. That\nis, these two signatures are interchangeable to the caller:", "position": 30, "token_count": 228, "has_code": false, "section_hierarchy": ["mixed", "Return values", "Named results"], "metadata": {"chunk_id": "functions-030", "document_id": "functions", "position": 30, "token_count": 228, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Return values", "Named results"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#named-results"}}
{"chunk_id": "functions-031", "document_id": "functions", "content": "The fact that a function uses a named result is transparent to the caller. That\nis, these two signatures are interchangeable to the caller:\n\n```mojo\ndef get_name_tag(var name: String) -> NameTag:\n ...\ndef get_name_tag(var name: String, out name_tag: NameTag):\n ...\n```\n\nIn both cases, the call looks like this:\n\n```mojo\ntag = get_name_tag(\"Judith\")\n```\n\nBecause the return value is assigned to this special `out` variable, it doesn't\nneed to be moved or copied when it's returned to the caller. This means that you\ncan create a function that returns a type that can't be moved or copied, and\nwhich takes several steps to initialize:\n\n```mojo\nstruct ImmovableObject:\n var name: String\n\n fn __init__(out self, var name: String):\n self.name = name^\n\ndef create_immovable_object(var name: String, out obj: ImmovableObject):\n obj = ImmovableObject(name^)\n obj.name += \"!\"\n # obj is implicitly returned\n\ndef main():\n my_obj = create_immovable_object(\"Blob\")\n```\n\nBy contrast, the following function with a standard return value doesn't work:", "position": 31, "token_count": 250, "has_code": true, "section_hierarchy": ["mixed", "Return values", "Named results"], "metadata": {"chunk_id": "functions-031", "document_id": "functions", "position": 31, "token_count": 250, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Return values", "Named results"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#named-results"}}
{"chunk_id": "functions-032", "document_id": "functions", "content": "def main():\n my_obj = create_immovable_object(\"Blob\")\n```\n\nBy contrast, the following function with a standard return value doesn't work:\n\n```mojo\ndef create_immovable_object2(var name: String) -> ImmovableObject:\n obj = ImmovableObject(name^)\n obj.name += \"!\"\n return obj^ # Error: ImmovableObject is not copyable or movable\n```\n\nBecause `create_immovable_object2` uses a local variable to store the object\nwhile it's under construction, the return call requires it to be either moved\nor copied to the callee. This isn't an issue if the newly-created value is\nreturned immediately:\n\n```mojo\ndef create_immovable_object3(var name: String) -> ImmovableObject:\n return ImmovableObject(name^) # OK\n```\n\n## Raising and non-raising functions\n\nBy default, when a function raises an error, the function terminates immediately\nand the error propagates to the calling function. If the calling function\ndoesn't handle the error, it continues to propagate up the call stack.\n\n```mojo\ndef raises_error():\n raise Error(\"There was an error.\")\n```\n\nThe Mojo compiler *always* treats a function declared with `def` as a *raising\nfunction*, even", "position": 32, "token_count": 261, "has_code": true, "section_hierarchy": ["mixed", "Return values", "Named results"], "metadata": {"chunk_id": "functions-032", "document_id": "functions", "position": 32, "token_count": 261, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["mixed", "Return values", "Named results"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#named-results"}}
{"chunk_id": "functions-033", "document_id": "functions", "content": "if the body of the function doesn't contain any code that could\nraise an error.\n\nFunctions declared with `fn` without the `raises` keyword are *non-raising\nfunctions*—that is, they are not allowed to propagate an error to the calling\nfunction. If a non-raising function calls a raising function, it **must handle\nany possible errors.**\n\n```mojo\n# This function will not compile\nfn unhandled_error():\n raises_error() # Error: can't call raising function in a non-raising context\n\n# Explicitly handle the error\nfn handle_error():\n try:\n raises_error()\n except e:\n print(\"Handled an error:\", e)\n\n# Explicitly propagate the error\nfn propagate_error() raises:\n raises_error()\n\n```\n\nIf you're writing code that you expect to use widely or distribute as a package,\nyou may want to us", "position": 33, "token_count": 178, "has_code": true, "section_hierarchy": ["mixed", "Raising and non-raising functions"], "metadata": {"chunk_id": "functions-033", "document_id": "functions", "position": 33, "token_count": 178, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["mixed", "Raising and non-raising functions"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#raising-and-non-raising-functions"}}
{"chunk_id": "functions-034", "document_id": "functions", "content": "e `fn` functions for APIs that don't raise errors to limit\nthe number of places users need to add unnecessary error handling code. For some", "position": 34, "token_count": 30, "has_code": false, "section_hierarchy": ["This function will not compile"], "metadata": {"chunk_id": "functions-034", "document_id": "functions", "position": 34, "token_count": 30, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["This function will not compile"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#this-function-will-not-compile"}}
{"chunk_id": "functions-035", "document_id": "functions", "content": "extremely performance-sensitive code, it may be preferable to avoid run-time\nerror-handling.\n\nFor more information, see\n[Errors, erro", "position": 35, "token_count": 29, "has_code": false, "section_hierarchy": ["Explicitly handle the error"], "metadata": {"chunk_id": "functions-035", "document_id": "functions", "position": 35, "token_count": 29, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Explicitly handle the error"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#explicitly-handle-the-error"}}
{"chunk_id": "functions-036", "document_id": "functions", "content": "r handling, and context managers](/mojo/manual/errors).", "position": 36, "token_count": 13, "has_code": false, "section_hierarchy": ["Explicitly propagate the error"], "metadata": {"chunk_id": "functions-036", "document_id": "functions", "position": 36, "token_count": 13, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Explicitly propagate the error"], "file_path": "functions.mdx", "url": "https://docs.modular.com/mojo/manual/functions", "title": "Functions", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/functions#explicitly-propagate-the-error"}}

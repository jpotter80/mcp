{"chunk_id": "get-started-000", "document_id": "get-started", "content": "Get ready to learn Mojo! This tutorial gives you a tour of Mojo by building a\ncomplete program that does much more than simply printing \"Hello, world!\"\n\nWe'll build a version of [Conway's Game of\nLife](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life), which is a\nsimulation of self-replicating systems. If you haven't heard of it before,\ndon't worry—it will make sense when you see it in action. Let's get\nstarted so you can learn Mojo programming basics, including the following:\n\n- Using basic built-in types like `Int` and `String`\n- Using a `List` to manage a sequence of values\n- Creating custom types in the form of structs (data structures)\n- Creating and importing Mojo modules\n- Importing and using Python libraries\n\nThere's a lot to learn, but we've tried to keep the explanations simple. If you\njust want to see the finished code, you can [get it on\nGitHub](https://github.com/modular/modular/tree/main/examples/mojo/life).\n\nSystem requirements:\n\n## 1. Create a Mojo project", "position": 0, "token_count": 237, "has_code": false, "section_hierarchy": [], "metadata": {"chunk_id": "get-started-000", "document_id": "get-started", "position": 0, "token_count": 237, "has_code": false, "overlap_with_previous": false, "section_hierarchy": [], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started"}}
{"chunk_id": "get-started-001", "document_id": "get-started", "content": "and:\n\n ```sh\n curl -fsSL https://pixi.sh/install.sh | sh\n ```\n\n2. Navigate to the directory where you want to create the project and execute:\n\n ```bash\n pixi init life \\\n -c https://conda.modular.com/max-nightly/ -c conda-forge \\\n && cd life\n ```\n\n This creates a project directory named `life`, adds the Modular conda package\n channel, and navigates into the directory.\n\n [tip]\n You can skip the `-c` options if you [add these channels as\n defaults](/pixi#create-a-project-and-virtual-environment).\n\n\n\n3. Install the `mojo` package:\n\n ```bash\n pixi add mojo\n ```\n\n4. Now let's list the project contents:\n\n ```bash\n ls -A\n ```\n\n ```output\n .gitattributes\n .gitignore\n .pixi\n pixi.lock\n pixi.toml\n ```\n\nYou should see that the project directory contains:\n\n- An initial `pixi.toml` manifest file, which defines the project\n dependencies and other features", "position": 1, "token_count": 223, "has_code": true, "section_hierarchy": ["1. Create a Mojo project"], "metadata": {"chunk_id": "get-started-001", "document_id": "get-started", "position": 1, "token_count": 223, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["1. Create a Mojo project"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#1-create-a-mojo-project"}}
{"chunk_id": "get-started-002", "document_id": "get-started", "content": "You should see that the project directory contains:\n\n- An initial `pixi.toml` manifest file, which defines the project\n dependencies and other features\n\n- A [lock file](https://pixi.sh/latest/workspace/lockfile/) named `pixi.lock`,\n which specifies the transitive dependencies and actual package versions\n installed in the project's virtual environment\n\n [note]\n Never edit the lock file directly. The `pixi` command automatically updates\n the lock file if you edit the manifest file.\n\n\n\n- A `.pixi` subdirectory containing the conda virtual environment for the\n project\n- Initial `.gitignore` and `.gitattributes` files that you can optionally use if\n you plan to use Git version control with the project\n\nLet's verify that our project is configured correctly by checking the\nversion of Mojo that's installed in our project's virtual environment.\n`pixi run` executes a command in the project's virtual environment, so let's\nuse it to execute `mojo --version`:\n\n```bash\npixi run mojo --version\n```", "position": 2, "token_count": 218, "has_code": true, "section_hierarchy": ["1. Create a Mojo project"], "metadata": {"chunk_id": "get-started-002", "document_id": "get-started", "position": 2, "token_count": 218, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["1. Create a Mojo project"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#1-create-a-mojo-project"}}
{"chunk_id": "get-started-003", "document_id": "get-started", "content": "```bash\npixi run mojo --version\n```\n\nYou should see a version string indicating the version of Mojo installed, which\nby default should be the latest version. You can view and edit the version for\nyour project in the dependencies list in the `pixi.toml` file.\n\nGreat! Now let's write our first Mojo program.\n\n## 2. Create a \"Hello, world\" program\n\nIn the project directory, create a file named `life.mojo` containing the\nfollowing lines of code:\n\n```mojo title=\"life.mojo\"\n# My first Mojo program!\ndef main():\n print(\"Hello, World!\")\n```\n\n[note]\nYou can use any editor or IDE that you like. If you're using [Visual Studio\nCode](https://code.visu", "position": 3, "token_count": 161, "has_code": true, "section_hierarchy": ["1. Create a Mojo project"], "metadata": {"chunk_id": "get-started-003", "document_id": "get-started", "position": 3, "token_count": 161, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["1. Create a Mojo project"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#1-create-a-mojo-project"}}
{"chunk_id": "get-started-004", "document_id": "get-started", "content": "alstudio.com/) you can take advantage of the [Mojo for\nVisual Studio Code\nextension](https://marketplace.visualstudio.com/items?itemName=modular-mojotools.vscode-mo", "position": 4, "token_count": 42, "has_code": false, "section_hierarchy": ["2. Create a \"Hello, world\" program"], "metadata": {"chunk_id": "get-started-004", "document_id": "get-started", "position": 4, "token_count": 42, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["2. Create a \"Hello, world\" program"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#2-create-a-hello-world-program"}}
{"chunk_id": "get-started-005", "document_id": "get-started", "content": "jo),\nwhich provides features like syntax highlighting, code completion, and debugging\nsupport. For [Cursor](https://cursor.com/) and other editors that support VS\nCode extensions, you can install the\n[Mojo for Visual Studio Code extension](https://open-vsx.org/extension/modular-mojotools/vscode-mojo)\nfrom the [Open VSX Registry](https://open-vsx.org/). See\n[Add the VS Code extension](/mojo/manual/install/#add-the-vs-code-extension) for\nmore information.\n\nIf you've programmed in Python before, this should look familiar.\n\n- We're using the `def` keyword to define a function named `main`.\n- You can use any number of spaces or tabs for indentation as long as you use\n the same indentation for the entire code block. We'll follow the [Python style\n guide](https://peps.python.org/pep-0008/) and use 4 spaces.\n- This [`print()`](/mojo/stdlib/builtin/io/print) function is a Mojo built-in,\n so it doesn't require an import.", "position": 5, "token_count": 230, "has_code": false, "section_hierarchy": ["My first Mojo program!"], "metadata": {"chunk_id": "get-started-005", "document_id": "get-started", "position": 5, "token_count": 230, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["My first Mojo program!"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#my-first-mojo-program"}}
{"chunk_id": "get-started-006", "document_id": "get-started", "content": "An executable Mojo program *requires* you to define a no-argument `main()`\nfunction as its entry point. Running the program automatically invokes the\n`main()` function, and your program exits when the `main()` function returns.\n\nTo run the program, we first need to start a shell session in our project's\nvirtual environment:\n\n```bash\npixi shell\n```\n\nLater on, when you want to exit the virtual environment, just type `exit`.\n\nNow we can use the `mojo` command to run our program.\n\n```bash\nmojo life.mojo\n```\n\n```output\nHello, World!\n```\n\nMojo is a compiled language, not an interpreted one like Python. When we run\nour program like this, `mojo` performs [just-in-time\ncompilation](https://en.wikipedia.org/wiki/Just-in-time_compilation) (JIT) and\nthen runs the result.\n\nWe can also compile our program into an executable file using [`mojo\nbuild`](/mojo/cli/build) like this:\n\n```bash\nmojo build life.mojo\n```\n\nBy default, this saves an executable file named `life` to the current directory.\n\n```bash\n./life\n```\n\n```output\nHello, World!\n```", "position": 6, "token_count": 261, "has_code": true, "section_hierarchy": ["My first Mojo program!"], "metadata": {"chunk_id": "get-started-006", "document_id": "get-started", "position": 6, "token_count": 261, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["My first Mojo program!"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#my-first-mojo-program"}}
{"chunk_id": "get-started-007", "document_id": "get-started", "content": "```bash\nmojo build life.mojo\n```\n\nBy default, this saves an executable file named `life` to the current directory.\n\n```bash\n./life\n```\n\n```output\nHello, World!\n```\n\n## 3. Create and use variables\n\nLet's extend this basic program by prompting the user for their name and\nincluding it in the greeting. The built-in\n[`input()`](/mojo/stdlib/builtin/io/input) function accepts an optional\n[`String`](/mojo/stdlib/collections/string/string/String) argument to use as a\nprompt and returns a `String` consisting of the ch", "position": 7, "token_count": 130, "has_code": true, "section_hierarchy": ["My first Mojo program!"], "metadata": {"chunk_id": "get-started-007", "document_id": "get-started", "position": 7, "token_count": 130, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["My first Mojo program!"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#my-first-mojo-program"}}
{"chunk_id": "get-started-008", "document_id": "get-started", "content": "aracters the user entered\n(with the newline character at the end stripped off).\n\nLet's declare a variable, assign the return value from `input()` to it, and\nbuild a customized greeting.\n\n```mojo title=\"life.mojo\"\ndef main():\n var name: String = input(\"Who are you? \")\n var greeting: String = \"Hi, \" + name + \"!\"\n print(greeting)\n```\n\nGo ahead and run it:\n\n```bash\nmojo life.mojo\n```\n\n```output\nWho are you? Edna\nHi, Edna!\n```\n\nNotice that this code uses a `String` type annotation that indicates the type of\nvalue the variable can contain. The Mojo compiler performs [static type\nchecking](https://en.wikipedia.org/wiki/Type_system#Static_type_checking), which\nmeans you'll encounter a compile-time error if your code tries to assign a\nvalue of one type to a variable of a different type.\n\nMojo also supports implicitly declared variables, where you simply assign a\nvalue to a new variable without using the `var` keyword or indicating its type.\nWe can replace the code we just entered with the following, and it works\nexactly the same.", "position": 8, "token_count": 248, "has_code": true, "section_hierarchy": ["My first Mojo program!", "3. Create and use variables"], "metadata": {"chunk_id": "get-started-008", "document_id": "get-started", "position": 8, "token_count": 248, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["My first Mojo program!", "3. Create and use variables"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#3-create-and-use-variables"}}
{"chunk_id": "get-started-009", "document_id": "get-started", "content": "```mojo title=\"life.mojo\"\ndef main():\n name = input(\"Who are you? \")\n greeting = \"Hi, \" + name + \"!\"\n print(greeting)\n```\n\nHowever, implicitly declared variables still have a fixed type, which Mojo\nautomatically infers from the initial value assignment. In this example, both\n`name` and `greeting` are inferred as `String` type variables. If you then try\nto assign an integer value like 42 to the `name` variable, you'll get a\ncompile-time error because of the type mismatch. You can learn more about Mojo\nvariables in the [Variables](/mojo/manual/variables) section of the Mojo manual.\n\n## 4. Use Mojo `Int` and `List` types to represent the game state\n\nAs originally envisioned by John Conway, the game's \"world\" is an infinite,\ntwo-dimensional grid of square cells, but for our implementation, we'll constrain\nthe grid to a finite size. A drawback of making the edges of the grid a hard\nboundary is that there are fewer neighboring cells around the edg", "position": 9, "token_count": 229, "has_code": true, "section_hierarchy": ["My first Mojo program!", "3. Create and use variables"], "metadata": {"chunk_id": "get-started-009", "document_id": "get-started", "position": 9, "token_count": 229, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["My first Mojo program!", "3. Create and use variables"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#3-create-and-use-variables"}}
{"chunk_id": "get-started-010", "document_id": "get-started", "content": "es compared to\nthe interior, which tends to cause die-offs. Therefore, we'll model the world as\na toroid (a donut shape), where the top row is considered adjacent to the bottom\nrow, and the left column is considered adjacent to the right column. This will\ncome into play later when we implement the algorithm for calculating each\nsubsequent generation.\n\nTo keep track of the height and width of our grid, we'll use\n[`Int`](/mojo/stdlib/builtin/int/Int), which represents a signed integer of the\n[word size](https://en.wikipedia.org/wiki/Word_(computer_architecture)) of the\nCPU, typically 32 or 64 bits.\n\nTo represent the state of an individual cell, we'll use an `Int` value of 1\n(populated) or 0 (unpopulated). Later, when we need to determine the number of\npopulated neighbors surrounding a cell, we can simply add the values of the\nneighboring cells.", "position": 10, "token_count": 208, "has_code": false, "section_hierarchy": ["My first Mojo program!", "4. Use Mojo `Int` and `List` types to represent the game state"], "metadata": {"chunk_id": "get-started-010", "document_id": "get-started", "position": 10, "token_count": 208, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["My first Mojo program!", "4. Use Mojo `Int` and `List` types to represent the game state"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#4-use-mojo-int-and-list-types-to-represent-the-game-state"}}
{"chunk_id": "get-started-011", "document_id": "get-started", "content": "To represent the state of the entire grid, we need a [collection\ntype](/mojo/manual/types#collection-types). The most appropriate for this use\ncase is [`List`](/mojo/stdlib/collections/list/List), which is a\ndynamically-sized sequence of values.\n\nAll values in a Mojo `List` must be the same type so the Mojo compiler can\nensure type safety. (For example, when we retrieve a value from a `List[Int]`,\nthe compiler knows the value is an `Int` and can verify that we use it\ncorrectly.) Mojo collections are implemented as [generic\ntypes](https://en.wikipedia.org/wiki/Generic_programming), so we can indicate\nthe type of values the specific collection will hold by specifying a\n[type parameter](/mojo/manual/parameters/#parameterized-structs) in square\nbrackets like this:\n\n```mojo\n# The List in row can contain only Int values\nrow = List[Int]()\n\n# The List in names can contain only String values\nnames = List[String]()\n```", "position": 11, "token_count": 221, "has_code": true, "section_hierarchy": ["My first Mojo program!", "4. Use Mojo `Int` and `List` types to represent the game state"], "metadata": {"chunk_id": "get-started-011", "document_id": "get-started", "position": 11, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["My first Mojo program!", "4. Use Mojo `Int` and `List` types to represent the game state"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#4-use-mojo-int-and-list-types-to-represent-the-game-state"}}
{"chunk_id": "get-started-012", "document_id": "get-started", "content": "lues in\nsquare brackets (`[]`).\n\n```mojo\n# Create a List[Int] wit", "position": 12, "token_count": 21, "has_code": true, "section_hierarchy": ["The List in row can contain only Int values"], "metadata": {"chunk_id": "get-started-012", "document_id": "get-started", "position": 12, "token_count": 21, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["The List in row can contain only Int values"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#the-list-in-row-can-contain-only-int-values"}}
{"chunk_id": "get-started-013", "document_id": "get-started", "content": "h the List constructor, inferring the type\nnums1 = List(12, -7, 64)\n\n# Create a List[Int] with the list literal syntax, inferring the type\nnums2 = [12, -7, 64]\n```\n\nThe Mojo `List` type includes the ability to append to the list, pop values from\nthe list, and access list items using subscript notation. Here's a taste of\nthose operations:\n\n``", "position": 13, "token_count": 94, "has_code": true, "section_hierarchy": ["The List in names can contain only String values"], "metadata": {"chunk_id": "get-started-013", "document_id": "get-started", "position": 13, "token_count": 94, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["The List in names can contain only String values"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#the-list-in-names-can-contain-only-string-values"}}
{"chunk_id": "get-started-014", "document_id": "get-started", "content": "`mojo\nnums = [12, -7, 64]\nnums.append(-937)\nprint(\"Number of elements in the list:\", len(nums", "position": 14, "token_count": 31, "has_code": false, "section_hierarchy": ["Create a List[Int] with the List constructor, inferring the type"], "metadata": {"chunk_id": "get-started-014", "document_id": "get-started", "position": 14, "token_count": 31, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the List constructor, inferring the type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#create-a-listint-with-the-list-constructor-inferring-the-type"}}
{"chunk_id": "get-started-015", "document_id": "get-started", "content": "))\nprint(\"Popping last element off the list:\", nums.pop())\nprint(\"First element of the list:\", nums[0])\nprint(\"Second element of the list:\", nums[1])\nprint(\"Last element of the list:\", nums[-1])\n```\n\n```output\nNumber of elements in the list: 4\nPopping last element off the list: -937\nFirst element of the list: 12\nSecond element of the list: -7\nLast element of the list: 64\n```\n\nWe can also nest `List`s:\n\n```mojo\ngrid = [\n [11, 22],\n [33, 44]\n]\nprint(\"Row 0, Column 0:\", grid[0][0])\nprint(\"Row 0, Column 1:\", grid[0][1])\nprint(\"Row 1, Column 0:\", grid[1][0])\nprint(\"Row 1, Column 1:\", grid[1][1])\n```\n\n```output\nRow 0, Column 0: 11\nRow 0, Column 1: 22\nRow 1, Column 0: 33\nRow 1, Column 1: 44\n```", "position": 15, "token_count": 247, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "metadata": {"chunk_id": "get-started-015", "document_id": "get-started", "position": 15, "token_count": 247, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#create-a-listint-with-the-list-literal-syntax-inferring-the-type"}}
{"chunk_id": "get-started-016", "document_id": "get-started", "content": "```output\nRow 0, Column 0: 11\nRow 0, Column 1: 22\nRow 1, Column 0: 33\nRow 1, Column 1: 44\n```\n\nThis looks like a good way to represent the state of the grid for our program.\nLet's update the `main()` function with the following code that defines an\n8×8 grid containing the initial state of a\n\"[glider](https://en.wikipedia.org/wiki/Glider_(Conway%27s_Game_of_Life))\"\npattern.", "position": 16, "token_count": 118, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "metadata": {"chunk_id": "get-started-016", "document_id": "get-started", "position": 16, "token_count": 118, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#create-a-listint-with-the-list-literal-syntax-inferring-the-type"}}
{"chunk_id": "get-started-017", "document_id": "get-started", "content": "```mojo title=\"life.mojo\"\ndef main():\n num_rows = 8\n num_cols = 8\n glider = [\n [0, 1, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 0, 0, 0, 0],\n [1, 1, 1, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n ]\n```\n\n### Copying values in Mojo", "position": 17, "token_count": 229, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "metadata": {"chunk_id": "get-started-017", "document_id": "get-started", "position": 17, "token_count": 229, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#create-a-listint-with-the-list-literal-syntax-inferring-the-type"}}
{"chunk_id": "get-started-018", "document_id": "get-started", "content": "### Copying values in Mojo\n\nBefore we move on, let's take a moment to discuss how Mojo handles copying\nvalues. There's an important difference in Mojo between copying simple types\nlike `Int` and `String` and more complex types like `List`:\n\n- An *explicitly copyable* type can be copied by calling its `copy()` method.\n `List` is explicitly copyable, so if `first` is a `List`, you can copy it like\n this:\n\n ```mojo\n first = [1, 2, 3]\n secon", "position": 18, "token_count": 118, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "metadata": {"chunk_id": "get-started-018", "document_id": "get-started", "position": 18, "token_count": 118, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#create-a-listint-with-the-list-literal-syntax-inferring-the-type"}}
{"chunk_id": "get-started-019", "document_id": "get-started", "content": "d = first.copy() # explicit copy\n ```\n\n This leaves `first` unchanged and assigns `second` its own, uniquely owned\n copy of the list.\n\n- An *implicitly copyable* type can be copied without an explicit call to a\n `copy()` method. `Int` and `String` are implicitly copyable types, so if\n `one_value` is an `Int`, you can copy it like this:\n\n ```mojo\n one_value = 15\n another_value = one_value # implicit copy\n ```\n\n Here, `one_value` is unchanged, and `another_value` gets a copy of the value.\n\nImplicit copying is useful for simple types like `Int` and `String`, where\ncopying is inexpensive and has no side effects. In contrast, a `List` might\noccupy megabytes of memory, and unintentionally copying it could be a\nsignificant performance hit. Therefore, the `List` type supports only explicit\ncopying to prevent accidental copying. Understanding this distinction will be\nimportant when we define and use our own custom types later in this tutorial.", "position": 19, "token_count": 225, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "Copying values in Mojo"], "metadata": {"chunk_id": "get-started-019", "document_id": "get-started", "position": 19, "token_count": 225, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "Copying values in Mojo"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#copying-values-in-mojo"}}
{"chunk_id": "get-started-020", "document_id": "get-started", "content": "[tip]\nYou can determine whether a type is explicitly or implicitly copyable by\nchecking its API documentation to see what *traits* it conforms to. A Mojo\n[trait](/mojo/manual/traits) is a set of requirements that a type must\nimplement, usually in the form of one or more method signatures.\n\n- The `List` type and other Mojo collection types like\n [`Dict`](/mojo/stdlib/collections/dict/Dict/) and\n [`Set`](/mojo/stdlib/collections/set/Set/) conform to the\n [`Copyable`](/mojo/stdlib/builtin/value/Copyable/) trait, which indicates that\n they are **explicitly copyable**.\n\n- The `String`, `Int` and other numeric types conform to the\n [`ImplicitlyCopyable`](/mojo/stdlib/builtin/value/ImplicitlyCopyable/) trait,\n which indicates that they are **implicitly copyable**. Additionally, the\n `ImplicitlyCopyable` trait inherits from the `Copyable` trait, so you can also\n use types that conform to the `ImplicitlyCopyable` trait in the same way you\n can use types that conform to the `Copyable` trait.", "position": 20, "token_count": 251, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "Copying values in Mojo"], "metadata": {"chunk_id": "get-started-020", "document_id": "get-started", "position": 20, "token_count": 251, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "Copying values in Mojo"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#copying-values-in-mojo"}}
{"chunk_id": "get-started-021", "document_id": "get-started", "content": "## 5. Create and use a function to print the grid\n\nNow let's create a function to generate a string representation of the game grid\nso we can print it to the terminal.\n\nThere are actually two different keywords we can use to define functions in\nMojo: `def` and `fn`. Using `fn` gives us finer-level control over the function\ndefinition, whereas `def` provides a good set of default behaviors for most use\ncases. See [Functions](/mojo/manual/functions) for more information a", "position": 21, "token_count": 109, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "Copying values in Mojo"], "metadata": {"chunk_id": "get-started-021", "document_id": "get-started", "position": 21, "token_count": 109, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "Copying values in Mojo"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#copying-values-in-mojo"}}
{"chunk_id": "get-started-022", "document_id": "get-started", "content": "bout\ndefining and using functions in Mojo.\n\nLet's add the following definition of a function named `grid_str()` to our\nprogram. The Mojo compiler doesn't care whether we add our function before or\nafter `main()`, but the convention is to put `main()` at the end.\n\n```mojo title=\"life.mojo\"\nfn grid_str(rows: Int, cols: Int, grid: List[List[Int]]) -> String:\n # Create an empty String\n str = String()\n\n # Iterate through rows 0 through rows-1\n for row in range(rows):\n # Iterate through columns 0 through cols-1\n for col in range(cols):\n if grid[row][col] == 1:\n str += \"*\" # If cell is populated, append an asterisk\n else:\n str += \" \" # If cell is not populated, append a space\n if row != rows-1:\n str += \"\\n\" # Add a newline between rows, but not at the end\n return str\n```", "position": 22, "token_count": 204, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "metadata": {"chunk_id": "get-started-022", "document_id": "get-started", "position": 22, "token_count": 204, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#5-create-and-use-a-function-to-print-the-grid"}}
{"chunk_id": "get-started-023", "document_id": "get-started", "content": "When we pass a value to a Mojo function, the default behavior is that an\nargument is treated as a *read-only reference* to the value. This is\nparticularly useful for values like `List`s, where copying them could be\nexpensive. As we'll see later, we can specify different behavior by including an\nexplicit [argument\nconvention](/mojo/manual/values/ownership#argument-conventions).\n\nEach argument name is followed by a type annotation indicating the type of value\nyou can pass to the argument. Just like when assigning a value to a variable,\nyou'll encounter a compile-time error if your code tries to pass a value of one\ntype to an argument of a different type. Finally, the `-> String` following the\nargument list indicates that this function has a `String` type return value.", "position": 23, "token_count": 170, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "metadata": {"chunk_id": "get-started-023", "document_id": "get-started", "position": 23, "token_count": 170, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#5-create-and-use-a-function-to-print-the-grid"}}
{"chunk_id": "get-started-024", "document_id": "get-started", "content": "In the body of the function, we generate a `String` by appending an asterisk for\neach populated cell and a space for each unpopulated cell, separating each row\nof the grid with a newline character. We use nested `for` loops to iterate\nthrough each row and column of the grid, using\n[`range()`](/mojo/stdlib/builtin/range/range) to generate a sequence of integers\nfrom 0 up to (but not including) the given end value. Then we append the correct\ncharacters to the `String` representation. See [Control\nflow](/mojo/manual/control-flow) for more information about `if`, `for`, and\nother control flow structures in Mojo.\n\n[note]\nAs described in [The `for`\nstatement](/mojo/manual/control-flow#the-for-statement) section of the Mojo\nmanual, it's possible to iterate over the elements of a `List` directly instead\nof iterating over the values of a `range()` and then accessing the `List`\nelements by their numeric index.\n\n```mojo\nnums = [12, -7, 64]\nfor value in nums:\n print(\"Value:\", value)\n```", "position": 24, "token_count": 248, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "metadata": {"chunk_id": "get-started-024", "document_id": "get-started", "position": 24, "token_count": 248, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#5-create-and-use-a-function-to-print-the-grid"}}
{"chunk_id": "get-started-025", "document_id": "get-started", "content": "```mojo\nnums = [12, -7, 64]\nfor value in nums:\n print(\"Value:\", value)\n```\n\nNow that we've defined our `grid_str()` function, let's invoke it from `main()`.\n\n```mojo title=\"life.mojo\"\ndef main():\n ...\n result = grid_str(num_rows, num_cols, glider)\n print(result)\n```\n\nThen run the program to see the result:\n\n```bash\nmojo life.mojo\n```\n\n```output\n *\n *\n***\n\n```\n\nWe can see that the position of the asterisks matches the location of the 1s in\nthe `glider` grid.\n\n## 6. Create a module and define a custom type\n\nWe're currently passing three arguments to `grid_str()` to describe the size and\nstate of the grid to print. A better approach would be to define our own custom\ntype that encapsulates all information about the grid. Then any function that\nneeds to manipulate a grid can accept a single argument. We can do this by\ndefining a Mojo *struct*, which is a custom data structure.\n\nA [Mojo struct](/mojo/manual/structs) is a custom type consisting of:", "position": 25, "token_count": 250, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "metadata": {"chunk_id": "get-started-025", "document_id": "get-started", "position": 25, "token_count": 250, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "5. Create and use a function to print the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#5-create-and-use-a-function-to-print-the-grid"}}
{"chunk_id": "get-started-026", "document_id": "get-started", "content": "ctions that we can optionally define to manipulate\n instances of the struct that we create\n- Optionally, a set of traits that the struct conforms to\n\n[note]\nMojo structs are similar to classes. However, Mojo structs do *not* support\ninheritance. Mojo doesn't support classes at this time.\n\nWe could define the struct in our existing `life.mojo` source file, but let's\ncreate a separate *module* for the struct. A module is simply a Mojo source file\ncontaining struct and function definitions that can be imported into other Mojo\nsource files. To learn more about creating and importing modules, see the\n[Modules and packages](/mojo/manual/packages) section of the Mojo manual.\n\nCreate a new source file named `gridv1.mojo` in the project directory containing\nthe following definition of a struct named `Grid` with three fields:\n\n```mojo title=\"gridv1.mojo\"\n@fieldwise_init\nstruct Grid(Copyable, Movable):\n var rows: Int\n var cols: Int\n var data: List[List[Int]]\n```", "position": 26, "token_count": 224, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "metadata": {"chunk_id": "get-started-026", "document_id": "get-started", "position": 26, "token_count": 224, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#6-create-a-module-and-define-a-custom-type"}}
{"chunk_id": "get-started-027", "document_id": "get-started", "content": "```mojo title=\"gridv1.mojo\"\n@fieldwise_init\nstruct Grid(Copyable, Movable):\n var rows: Int\n var cols: Int\n var data: List[List[Int]]\n```\n\nMojo requires you to declare all fields in the struct definition. You\ncan't add fields dynamically at run-time. You must declare the type for each\nfield, but you cannot assign a value as part of the field declaration.\n\nThe [constructor](/mojo/manual/lifecycle/life#constructor) is responsible for\ninitializing the value of all fields, as well as allocating additional resources\nand performing any other configuration required by a new instance of the struct.\nYou implement a constructor by defining a method named `__init__()` in the\nstruct definition. Here's an example of how we *could* implement the\nconstructor for `Grid`:\n\n```mojo\n fn __init__(out self, rows: Int, cols: Int, var data: List[List[Int]]):\n self.rows = rows\n self.cols = cols\n self.data = data^\n```", "position": 27, "token_count": 222, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "metadata": {"chunk_id": "get-started-027", "document_id": "get-started", "position": 27, "token_count": 222, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#6-create-a-module-and-define-a-custom-type"}}
{"chunk_id": "get-started-028", "document_id": "get-started", "content": "```mojo\n fn __init__(out self, rows: Int, cols: Int, var data: List[List[Int]]):\n self.rows = rows\n self.cols = cols\n self.data = data^\n```\n\nThe first argument of a constructor is the newly created instance of the struct,\nwhich by convention is named `self`. The Mojo compiler automatically passes the\ninstance to the constructor when you create a new instance of the struct. Note\nthat in a constructor, you must include the `out` [argument\nconvention](/mojo/manual/values/ownership#argument-conventions) for the `self`\nargument. The values of the remaining arguments are assigned to the\ncorresponding fields of the new instance. (Don't worry about the `var` keyword\nand `^` character for now. We'll discuss both of them in more detail later.)", "position": 28, "token_count": 178, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "metadata": {"chunk_id": "get-started-028", "document_id": "get-started", "position": 28, "token_count": 178, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#6-create-a-module-and-define-a-custom-type"}}
{"chunk_id": "get-started-029", "document_id": "get-started", "content": "To reduce the amount of boilerplate code you need to write, Mojo provides a\ndecorator called [`@fieldwise_init`](/mojo/manual/decorators/fieldwise-init)\nthat automatically generates a constructor for you that performs \"field-wise\"\ninitialization. The constructor's arguments have the same names and types as the\nstruct's fields and appear in the same order. This means that given our original\ndefinition of `Grid`, we can create an instance of `Grid` like this:\n\n```mojo\nmy_grid = Grid(2, 2, [[0, 1], [1, 1]])\n```\n\nWe can then access the field values with \"dot\" syntax like this:\n\n```mojo\nprint(\"Rows:\", my_grid.rows)\n```\n\n```output\nRows: 2\n```\n\nHowever, we also need to be able to copy and move instances of `Grid`—for\nexample, when we pass an instance of `Grid` to a function or method. Mojo\nstructs support several different [lifecycle methods](/mojo/manual/lifecycle/)\nthat define the behavior when an instance of the struct is created, moved,\ncopied, and destroyed.", "position": 29, "token_count": 245, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "metadata": {"chunk_id": "get-started-029", "document_id": "get-started", "position": 29, "token_count": 245, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#6-create-a-module-and-define-a-custom-type"}}
{"chunk_id": "get-started-030", "document_id": "get-started", "content": "Structs that conform to the [`Movable`](/mojo/stdlib/builtin/value/Movable/)\n[trait](/mojo/manual/traits) denote a type whose value can be moved, and structs\nthat conform to the [`Copyable`](/mojo/stdlib/builtin/value/Copyable/) trait\ndenote a type whose value can be *explicitly* copied. You can then implement\ncustom move and copy constructors that perform the necessary operations to move\nor copy the instance.\n\nAs a convenience for structs that are basic aggregations of other types and\ndon't require custom resource management or lifecycle behaviors, you can simply\nindicate that the struct conforms to the `Movable` and `Copyable` traits without\nimplementing the corresponding lifecycle methods. In that case, the Mojo\ncompiler automatically generates the missing methods for you. For our simple\n`Grid` struct, indicating that it conforms to the `Movable` and `Copyable`\ntraits is enough to have the Mojo compiler automatically generate the missing\nmethods for us. The `Copyable` trait also provides a default implementation of\nthe `copy()` method, so you don't need to implement it yourself.", "position": 30, "token_count": 244, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "metadata": {"chunk_id": "get-started-030", "document_id": "get-started", "position": 30, "token_count": 244, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#6-create-a-module-and-define-a-custom-type"}}
{"chunk_id": "get-started-031", "document_id": "get-started", "content": "[note]\nIf you define a simple struct where all fields are types that conform to the\n`ImplicitlyCopyable` trait—such as `String` and numeric types—you could indicate\nthat your struct conforms to the `ImplicitlyCopyable` trait instead of the\n`Copyable` trait. However, our `Grid` struct uses a `List[List[Int]]` field,\nwhich is not implicitly copyable.\n\nAlso see the [Life of a value](/mojo/manual/lifecycle/life) section of the Mojo\nManual for more information about the different lifecycle methods and how to\nimplement them.\n\n## 7. Import a module and use our custom `Grid` type\n\nNow let's edit `life.mojo` to import `Grid` from our new module and update our\ncode to use it.\n\n```mojo title=\"life.mojo\"\nfrom gridv1 import Grid\n\nfn grid_str(grid: Grid) -> String:\n # Create an empty String\n str = String()", "position": 31, "token_count": 204, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "metadata": {"chunk_id": "get-started-031", "document_id": "get-started", "position": 31, "token_count": 204, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#6-create-a-module-and-define-a-custom-type"}}
{"chunk_id": "get-started-032", "document_id": "get-started", "content": "```mojo title=\"life.mojo\"\nfrom gridv1 import Grid\n\nfn grid_str(grid: Grid) -> String:\n # Create an empty String\n str = String()\n\n # Iterate through rows 0 through rows-1\n for row in range(grid.rows):\n # Iterate through columns 0 through cols-1\n for col in range(grid.cols):\n if grid.data[row][col] == 1:\n str += \"*\" # If cell is populated, append an asterisk\n else:\n str += \" \" # If cell is not populated, append a space\n if row != grid.rows - 1:\n str += \"\\n\" # Add a newline between rows, but not at t", "position": 32, "token_count": 139, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "metadata": {"chunk_id": "get-started-032", "document_id": "get-started", "position": 32, "token_count": 139, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "6. Create a module and define a custom type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#6-create-a-module-and-define-a-custom-type"}}
{"chunk_id": "get-started-033", "document_id": "get-started", "content": "he end\n return str\n\ndef main():\n glider = [\n [0, 1, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 0, 0, 0, 0],\n [1, 1, 1, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n ]\n start = Grid(8, 8, glider^)\n result = grid_str(start)\n print(result)\n```", "position": 33, "token_count": 229, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "metadata": {"chunk_id": "get-started-033", "document_id": "get-started", "position": 33, "token_count": 229, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#7-import-a-module-and-use-our-custom-grid-type"}}
{"chunk_id": "get-started-034", "document_id": "get-started", "content": "All these changes are straightforward except for the line where we create the\n`Grid` instance. Our new `Grid` needs to take *ownership* of the\n`List[List[Int]]` representing the grid state. (Technically, the `data` field of\nthe `Grid` will own the value.) However, the `glider` variable currently owns\nthe list.\n\nOne alternative—if we plan to use the value of the `glider` variable again later\nin `main()`—would be to create a copy of the `glider` list to pass to the `Grid`\nconstructor, like this:\n\n```mojo\n start = Grid(8, 8, glider.copy())\n```", "position": 34, "token_count": 145, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "metadata": {"chunk_id": "get-started-034", "document_id": "get-started", "position": 34, "token_count": 145, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#7-import-a-module-and-use-our-custom-grid-type"}}
{"chunk_id": "get-started-035", "document_id": "get-started", "content": "```mojo\n start = Grid(8, 8, glider.copy())\n```\n\nIn our case, we don't need to use the `glider` variable again later, so we can\ninstead use the `^` transfer sigil to *transfer ownership* of the list to the\ncorresponding argument of the `Grid` constructor. After the transfer, the\n`glider` variable is uninitialized. You would need to assign a new value to it\nif you want to use the variable again. For more information about ownership and\nthe `^` transfer sigil, see the [Ownership](/mojo/manual/values/ownership)\nsection of the Mojo manual.\n\nAt this point, we've made several changes to improve the structure of our\nprogram, but the output should remain the same.\n\n```bash\nmojo life.mojo\n```\n\n```output\n *\n *\n***\n\n```\n\n## 8. Implement `grid_str()` as a method\n\nOur `grid_str()` function is really a utility function unique to the `Grid`\ntype. Rather than defining it as a standalone function, it makes more sense\nto define it as part of the `Grid` type as a method.", "position": 35, "token_count": 247, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "metadata": {"chunk_id": "get-started-035", "document_id": "get-started", "position": 35, "token_count": 247, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#7-import-a-module-and-use-our-custom-grid-type"}}
{"chunk_id": "get-started-036", "document_id": "get-started", "content": "Our `grid_str()` function is really a utility function unique to the `Grid`\ntype. Rather than defining it as a standalone function, it makes more sense\nto define it as part of the `Grid` type as a method.\n\nTo do so, move the function into `gridv1.mojo` and edit it to look like this (or\nsimply copy the code below into `gridv1.mojo`):\n\n```mojo title=\"gridv1.mojo\"\n@fieldwise_init\nstruct Grid(Copyable, Movable):\n var rows: Int\n var cols: Int\n var data: List[List[Int]]\n\n fn grid_str(self) -> String:\n # Create an empty String\n str = String()\n\n # Iterate through rows 0 through rows-1\n for row in range(self.rows):\n # Iterate through columns 0 through cols-1\n for col in range(self.cols):\n if self.data[row][col] == 1:\n str += \"*\" # If cell is populated, append an asterisk\n else:\n str += \" \" #", "position": 36, "token_count": 216, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "metadata": {"chunk_id": "get-started-036", "document_id": "get-started", "position": 36, "token_count": 216, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "7. Import a module and use our custom `Grid` type"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#7-import-a-module-and-use-our-custom-grid-type"}}
{"chunk_id": "get-started-037", "document_id": "get-started", "content": "Aside from moving the code from one source file to another, there are a few\nother changes we've made:\n\n- The function definition is indented to indicate that it's a method defined by\n the `Grid` struct. This also changes how we invoke the function.\n Instead of `grid_str(my_grid)`, we now write `my_grid.grid_str()`.\n- We've changed the argument name to `self`. When you invoke an instance method,\n Mojo automatically passes the instance as the first argument, followed by any\n explicit arguments you provide. Although we could use any name we like\n for this argument, the convention is to call it `self`.\n- We've deleted the argument's type annotation. The compiler knows the\n first argument of the method is an instance of the struct, so it doesn't\n require an explicit type annotation.\n- We don't need to add an explicit [argument\n convention](/mojo/manual/values/ownership#argument-conventions) to the `self`\n argument because we're using it as a read-only reference to the instance,\n which is the default behavior for a method argument.", "position": 37, "token_count": 227, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "metadata": {"chunk_id": "get-started-037", "document_id": "get-started", "position": 37, "token_count": 227, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#8-implement-gridstr-as-a-method"}}
{"chunk_id": "get-started-038", "document_id": "get-started", "content": "```mojo title=\"life.mojo\"\nfrom gridv1 import Grid\n\ndef main():\n glider = [\n [0, 1, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 0, 0, 0, 0],\n [1, 1, 1, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n ]\n start = Grid(8, 8, glider^)\n print(start.grid_str())\n```", "position": 38, "token_count": 235, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "metadata": {"chunk_id": "get-started-038", "document_id": "get-started", "position": 38, "token_count": 235, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#8-implement-gridstr-as-a-method"}}
{"chunk_id": "get-started-039", "document_id": "get-started", "content": "Once again, our refactoring has improved the structure of our code, but it still\nproduces the same output. You can verify this by running the program again.\n\n## 9. Implement support for the `Stringable` trait\n\nYou can convert most Mojo types to `String` using `String(my_val)` to produce a\n`String` representation of that instance. However, you'll get an error if you\ntry to do that with our current implementation of `Grid`. Let's fix that.\n\nBecause the Mojo compiler performs static type checking, a `String` constructor\ncan accept a value only if its type implements some required behavior—in this\ncase, it only accepts types that can generate a `String` representation.", "position": 39, "token_count": 148, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "metadata": {"chunk_id": "get-started-039", "document_id": "get-started", "position": 39, "token_count": 148, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#8-implement-gridstr-as-a-method"}}
{"chunk_id": "get-started-040", "document_id": "get-started", "content": "Because the Mojo compiler performs static type checking, a `String` constructor\ncan accept a value only if its type implements some required behavior—in this\ncase, it only accepts types that can generate a `String` representation.\n\nTo enforce this, the `String()` constructors require a type to conform to either\nthe [`Stringable`](/mojo/stdlib/builtin/str/Stringable) or\n[`StringableRaising`](/mojo/stdlib/builtin/str/StringableRaising) trait. (This\ntype of function is sometimes referred to as a [*generic*\nfunction](/mojo/manual/parameters/#parameters-and-generics).) Each trait\nrequires a conforming type to implement a `__str__()` method that returns a\n`String` representation. The only difference between the two traits is that\n`Stringable` requires that the method *cannot* raise an error, w", "position": 40, "token_count": 186, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "metadata": {"chunk_id": "get-started-040", "document_id": "get-started", "position": 40, "token_count": 186, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "8. Implement `grid_str()` as a method"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#8-implement-gridstr-as-a-method"}}
{"chunk_id": "get-started-041", "document_id": "get-started", "content": "hereas\n`StringableRaising` indicates that the method *might* raise an error. (To learn\nmore, read [The `Stringable`, `Representable`, and `Writable`\ntraits](/mojo/manual/traits#the-stringable-representable-and-writable-traits).)\n\nOur `grid_str()` method already returns a `String` representation, so it looks\nlike we just have to rename it to `__str__()`. However, we also need to indicate\nwhich trait `Grid` conforms to. In our case, it must be `Stringable` instead of\n`StringableRaising` because we used `fn` to define the method. If you define\na function or method with `def`, the compiler *always* assumes the\nfunction *can* raise an error. In contrast, an `fn` function is a [non-raising\nfunction](/mojo/manual/functions#raising-and-non-raising-functions) by default\n(though you can still declare that it might raise an error using the [`raises`\nkeyword](/mojo/manual/errors#declare-a-raising-function)).", "position": 41, "token_count": 233, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "metadata": {"chunk_id": "get-started-041", "document_id": "get-started", "position": 41, "token_count": 233, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#9-implement-support-for-the-stringable-trait"}}
{"chunk_id": "get-started-042", "document_id": "get-started", "content": "In `gridv1.mojo`, we need to update the `Grid` declaration to indicate that\nthe type conforms to `Stringable` and rename the `grid_str()` method to\n`__str__()`:\n\n```mojo title=\"gridv1.mojo\"\n@fieldwise_init\nstruct Grid(Copyable, Movable, Stringable):\n ...\n fn __str__(self) -> String:\n ...\n```\n\nNow let's verify that `String()` works with an instance of `Grid`.\n\n```mojo title=\"life.mojo\"\ndef main():\n ...\n start = Grid(8, 8, glider^)\n print(String(start))\n```\n\nIf you run the program again, you should still see the same glider pattern as\nbefore.\n\n```bash\nmojo life.mojo\n```\n\n```output\n *\n *\n***\n\n```\n\n## 10. Implement methods to support indexing", "position": 42, "token_count": 182, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "metadata": {"chunk_id": "get-started-042", "document_id": "get-started", "position": 42, "token_count": 182, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#9-implement-support-for-the-stringable-trait"}}
{"chunk_id": "get-started-043", "document_id": "get-started", "content": "If you run the program again, you should still see the same glider pattern as\nbefore.\n\n```bash\nmojo life.mojo\n```\n\n```output\n *\n *\n***\n\n```\n\n## 10. Implement methods to support indexing\n\nLooking at the implementation of `__str__()`, you'll notice that we use\n`self.data[row][col]` to retrieve the value of a cell in the grid. If\n`my_grid` is an instance of `Grid`, we would use `my_grid.data[row][col]` to\nrefer to a cell in the grid. This breaks a fundamental principle of\nencapsulation because we need to know that `Grid` stores the game state in a\nfield called `data`, and that field is a `List[List[Int]]`. If we later decide\nto change the internal implementation of `Grid`, there could be a lot of\ncode that would need to be changed.", "position": 43, "token_count": 190, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "metadata": {"chunk_id": "get-started-043", "document_id": "get-started", "position": 43, "token_count": 190, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#9-implement-support-for-the-stringable-trait"}}
{"chunk_id": "get-started-044", "document_id": "get-started", "content": "A cleaner approach is to provide \"getter\" and \"setter\" methods to access cell\nvalues. We could simply define methods like `get_cell()` and `set_cell()`, but\nthis is a good opportunity to show how we can define the behavior of built-in\noperators for custom Mojo types. Specifically, we'll implement support for\nindexing so we can refer to a cell with syntax like `my_grid[row, col]`.\nThis will be useful when we implement support for evolving the state of the\ngrid.\n\nAs described in [Operators, expressions, and", "position": 44, "token_count": 115, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "metadata": {"chunk_id": "get-started-044", "document_id": "get-started", "position": 44, "token_count": 115, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "9. Implement support for the `Stringable` trait"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#9-implement-support-for-the-stringable-trait"}}
{"chunk_id": "get-started-045", "document_id": "get-started", "content": "dunder\nmethods](/mojo/manual/operators), Mojo allows us to define the behavior of many\nbuilt-in operators for a custom type by implementing special *dunder*\n(double underscore) methods. In the case of indexing, the two methods are\n`__getitem__()` and `__setitem__()`. Let's add the following methods to the\n`Grid` struct in `gridv1.mojo`:\n\n```mojo title=\"gridv1.mojo\"\n@fieldwise_init\nstruct Grid(Copyable, Movable, Stringable):\n ...\n fn __getitem__(self, row: Int, col: Int) -> Int:\n return self.data[row][col]\n\n fn __setitem__(mut self, row: Int, col: Int, value: Int) -> None:\n self.data[row][col] = value\n```\n\nThe implementation of `__getitem__()` is straightforward. For the given values\nof `row` and `col`, we just need to retrieve and return the corresponding value\nfrom the nested `List[List[Int]]` stored in the `data` field of the instance.", "position": 45, "token_count": 227, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "metadata": {"chunk_id": "get-started-045", "document_id": "get-started", "position": 45, "token_count": 227, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#10-implement-methods-to-support-indexing"}}
{"chunk_id": "get-started-046", "document_id": "get-started", "content": "The body of `__setitem__()` is similarly straightforward. We just take the given\n`value` and store it in the corresponding `row` and `col` in `data`. One new\nthing in the declaration is that we set the return type to `None` to indicate\nthat the method doesn't have a return value. More notable is that we've added\nthe `mut`\n[argument convention](/mojo/manual/values/ownership#argument-conventions) to the\n`self` argument to explicitly tell the Mojo compiler that we want to mutate the\nstate of the current instance. If we were to omit `mut`, we would get an error\nbecause the compiler would default to read-only access for the argument.\n\nNow that we've implemented these methods, we can update `__str__()` to use\nindexing syntax to access the cell value.\n\n```mojo title=\"gridv1.mojo\"\n@fieldwise_init\nstruct Grid(Copyable, Movable, Stringable):\n ...\n fn __str__(self) -> String:\n ...\n # Iterate through columns 0 through cols-1\n for col in range(self.cols):\n if self[row, col] == 1:\n ...\n```", "position": 46, "token_count": 248, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "metadata": {"chunk_id": "get-started-046", "document_id": "get-started", "position": 46, "token_count": 248, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#10-implement-methods-to-support-indexing"}}
{"chunk_id": "get-started-047", "document_id": "get-started", "content": "<details>\n <summary>Click here to see the complete `gridv1.mojo` so far:</summary>\n\n```mojo title=\"gridv1.mojo\"\n@fieldwise_init\nstruct Grid(Copyable, Movable, Stringable):\n var rows: Int\n var cols: Int\n var data: List[List[Int]]\n\n fn __str__(self) -> String:\n # Create an empty String\n str = String()\n\n # Iterate through rows 0 through rows-1\n for row in range(self.rows):\n # Iterate through columns 0 through cols-1\n for col in range(self.cols):\n if self[row, col] == 1:\n str += \"*\" # If cell is populated, append an asterisk\n else:\n str += \" \" # If cell is not populated, append a space\n if row != self.rows - 1:\n str += \"\\n\" # Add a newline between rows, but not at the end\n return str\n\n fn __getitem__(self, row: Int, col: Int) -> Int:\n return self.data[row][col]\n\n fn __setitem__(mut self, row: Int, col: Int, value: Int) -> None:\n self.data[row][col] = value\n```\n\n</details>", "position": 47, "token_count": 256, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "metadata": {"chunk_id": "get-started-047", "document_id": "get-started", "position": 47, "token_count": 256, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#10-implement-methods-to-support-indexing"}}
{"chunk_id": "get-started-048", "document_id": "get-started", "content": " fn __setitem__(mut self, row: Int, col: Int, value: Int) -> None:\n self.data[row][col] = value\n```\n\n</details>\n\nOur refactoring hasn't changed our program's behavior, but it's still a good\nidea to run it to ensure we don't have any errors in our code.\n\n## 11. Define a static method to generate random grids\n\nSo far, we've used the glider to build the basic functionality of our `Grid`\ntype. However, what's much more interesting is to start with a grid in a random\nstate and see how it evolves over time.\n\nLet's add a *static method* named `random()` to the `Grid` struct to generate\nand return an instance of `Grid` with a random state. A static method doesn't\noperate on specific instances of the type, so it can be invoked as a utility\nfunction. We indicate that a method is static by using the\n`@staticmethod` decorator.\n\n```mojo title=\"gridv1.mojo\"\nimport random", "position": 48, "token_count": 220, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "metadata": {"chunk_id": "get-started-048", "document_id": "get-started", "position": 48, "token_count": 220, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#10-implement-methods-to-support-indexing"}}
{"chunk_id": "get-started-049", "document_id": "get-started", "content": "```mojo title=\"gridv1.mojo\"\nimport random\n\n@fieldwise_init\nstruct Grid(Copyable, Movable, Stringable):\n ...\n @staticmethod\n fn random(rows: Int, cols: Int) -> Self:\n # Seed the random number generator using the current time.\n random.seed()\n\n var data: List[List[Int]] = []\n\n for _ in range(rows):\n var row_data: List[Int] = []\n for _ in range(cols):\n # Generate a random 0 or 1 and append it to the row.\n row_data.append(Int(random.random_si64(0, 1)))\n data.append(row_data^)\n\n return Self(rows, cols, data^)\n```\n\nAt the top of the file, we're importing the `random` package from the Mojo\nstandard library. It includes several functions related to random number\ngeneration.\n\nBy default, the [pseudorandom number\ngenerator](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) used by\nthe Mojo standard library", "position": 49, "token_count": 205, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "metadata": {"chunk_id": "get-started-049", "document_id": "get-started", "position": 49, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "10. Implement methods to support indexing"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#10-implement-methods-to-support-indexing"}}
{"chunk_id": "get-started-050", "document_id": "get-started", "content": "currently uses a fixed seed. This means it generates\nthe same sequence of numbers unless you provide a different seed, which is\nuseful for testing purposes. However, for this application, we want to call\n`random.seed()` to set a seed value based on the current time, which gives us a\nunique value every time.\n\nThen we create `data` as an empty `List[List[Int]]`, which we'll populate with a\nrandom initial state. For each cell, we call\n[`random.random_si64()`](/mojo/stdlib/random/random/random_si64), which returns\na random integer value from the provided minimum and maximum values of 0 and 1,\nrespectively. This function actually returns a value of type `Int64`, which is a\nsigned 64-bit integer value. As described in [Numeric\ntypes](/mojo/manual/types#numeric-types), this is *not* the same as the `Int`\ntype, whose precision is dependent on the native word size of the system.\nTherefore, we're passing this value to the\n[`Int()`](/mojo/stdlib/builtin/int/Int/#__init__) constructor, which explicitly\nconverts a numeric value to an `Int`.", "position": 50, "token_count": 253, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "metadata": {"chunk_id": "get-started-050", "document_id": "get-started", "position": 50, "token_count": 253, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#11-define-a-static-method-to-generate-random-grids"}}
{"chunk_id": "get-started-051", "document_id": "get-started", "content": "After creating a complete row of random values, we append it to `data`. The\n`List` in `data` *owns* all its elements, so when we call `append()`, we need\nto decide whether to transfer ownership of the new row or provide a copy of it.\nIn this case, we don't need to use the row again, so we use the `^` transfer\nsigil to transfer ownership of the row to the `List` in `data`. (We didn't need\nto use the `^` sigil when appending the `Int` values because they're\n*implicitly* copyable.)\n\nThe return type of the method is `Self`, which is an alias for the type of the\nstruct. This is a convenient shortcut if the actual name of the struct is long\nor includes parameters. The last line uses `Self()` to invoke the struct's\nconstructor and return a newly created instance with random data. Once again, we\nuse the `^` transfer sigil to transfer ownership of the newly created\n`List[List[Int]]` to the new instance rather than make a copy of it.", "position": 51, "token_count": 235, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "metadata": {"chunk_id": "get-started-051", "document_id": "get-started", "position": 51, "token_count": 235, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#11-define-a-static-method-to-generate-random-grids"}}
{"chunk_id": "get-started-052", "document_id": "get-started", "content": "[note]\nThe `for` loops in the code above assign the loop value to \"`_`\", the [*discard\npattern*](/mojo/manual/lifecycle/death#explicit-lifetime-extension), to indicate\nthat it's intentionally not used. Without this, the Mojo compiler would\nreport a warning that the loop variable is unused.\n\nNow we can update the `main()` function in `life.mojo` to create a random `Grid`\nand print it.\n\n```mojo title=\"life.mojo\"\n...\n\ndef main():\n start = Grid.random(8, 16)\n print(String(start))\n```\n\nRun the program a few times to verify that it generates a different grid each\ntime.\n\n```bash\nmojo life.mojo\n```\n\n```output\n*** * ****\n* **** ******\n* * *****\n* * ** **\n * * ** ****\n* ** * * * ***\n * * ** ** **\n * ***** **\n```\n\n## 12. Implement a method to evolve the grid", "position": 52, "token_count": 205, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "metadata": {"chunk_id": "get-started-052", "document_id": "get-started", "position": 52, "token_count": 205, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#11-define-a-static-method-to-generate-random-grids"}}
{"chunk_id": "get-started-053", "document_id": "get-started", "content": "```output\n*** * ****\n* **** ******\n* * *****\n* * ** **\n * * ** ****\n* ** * * * ***\n * * ** ** **\n * ***** **\n```\n\n## 12. Implement a method to evolve the grid\n\nIt's finally time to let our world evolve. We'll implement an `evolve()` method\nto calculate the state of the grid for the next generation. One option would be\nto do an in-place modification of the existing `Grid` instance. Instead,\nwe'll have `evolve()` return a new instance of `Grid` for the next generation.\n\n```mojo title=\"gridv1.mojo\"\n...\nstruct Grid(Copyable, Movable, Stringable):\n ...\n fn evolve(self) -> Self:\n next_generation = List[List[Int]]()\n\n for row in range(self.rows):\n row_data = List[Int]()\n\n # Calculate neighboring row indices, handling \"wrap-around\"\n row_above = (row - 1) % self.rows\n row_below = (row + 1) % self.rows\n\n for col in range(self.cols):\n # Calculate neighboring column indices, handling \"wrap-around\"\n col_left = (col - 1) % self.cols\n col_right = (col + 1) % self.cols", "position": 53, "token_count": 259, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "metadata": {"chunk_id": "get-started-053", "document_id": "get-started", "position": 53, "token_count": 259, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#11-define-a-static-method-to-generate-random-grids"}}
{"chunk_id": "get-started-054", "document_id": "get-started", "content": " for col in range(self.cols):\n # Calculate neighboring column indices, handling \"wrap-around\"\n col_left = (col - 1) % self.cols\n col_right = (col + 1) % self.cols\n\n # Determine number of populated cells around the current cell\n num_neighbors = (\n self[row_above, col_left]\n + self[row_above, col]\n + self[row_above, col_right]\n + self[row, col_left]\n + self[row, col_right]\n + self[row_below, col_left]\n + self[row_below, col]\n + self[row_below, col_right]\n )\n\n # Determine the state of the current cell for the next generation\n new_state = 0\n if self[row, col] == 1 and (\n num_neighbors == 2 or num_neighbors == 3\n ):\n new_state = 1\n elif self[row, col] == 0 and num_neighbors == 3:\n new_state = 1\n row_data.append(new_state)\n\n next_generation.append(row_data^)\n\n return Self(self.rows, self.cols, next_generation^)\n```\n\nWe start with a", "position": 54, "token_count": 221, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "metadata": {"chunk_id": "get-started-054", "document_id": "get-started", "position": 54, "token_count": 221, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "11. Define a static method to generate random grids"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#11-define-a-static-method-to-generate-random-grids"}}
{"chunk_id": "get-started-055", "document_id": "get-started", "content": "n empty `List[List[Int]]` to represent the state of the next\ngeneration. Then we use nested `for` loops to iterate over each row and column\nof the existing `Grid` to determine the state of each cell in the next\ngeneration.\n\nFor each cell in the grid, we need to count the number of populated neighboring\ncells. Because we're modeling the world as a toroid, we need to consider the top\nand bottom rows as adjacent and the leftmost and rightmost columns as\nadjacent. As we iterate through each row and column, we're using the modulo\noperator (`%`) to handle \"wrap-around\" when we calculate the indices of the rows\nabove and below and the columns to the left and right of the current cell. (For\nexample, if there are 8 rows, then `-1 % 8` is 7.)\n\nThen we apply the Game of Life rules that determine whether the current cell is\npopulated (1) or unpopulated (0) for the next generation:", "position": 55, "token_count": 214, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "metadata": {"chunk_id": "get-started-055", "document_id": "get-started", "position": 55, "token_count": 214, "has_code": false, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#12-implement-a-method-to-evolve-the-grid"}}
{"chunk_id": "get-started-056", "document_id": "get-started", "content": "Then we apply the Game of Life rules that determine whether the current cell is\npopulated (1) or unpopulated (0) for the next generation:\n\n- A populated cell with either 2 or 3 populated neighbors remains populated in\n the next generation\n- An unpopulated cell with exactly 3 populated neighbors becomes populated in\n the next generation\n- All other cells become unpopulated in the next generation\n\nAfter calculating the state of the next generation, we use `Self()` to create a\nnew instance of `Grid`, and return the newly created instance.\n\nNow that we can evolve the grid, let's use it in `life.mojo`. We'll add a\n`run_display()` function to control the game's main loop:\n\n- Display the current `Grid`\n- Prompt the user to continue or quit\n- Break out of the loop if the user enters `q`\n- Otherwise, calculate the next generation and loop again", "position": 56, "token_count": 193, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "metadata": {"chunk_id": "get-started-056", "document_id": "get-started", "position": 56, "token_count": 193, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#12-implement-a-method-to-evolve-the-grid"}}
{"chunk_id": "get-started-057", "document_id": "get-started", "content": "- Display the current `Grid`\n- Prompt the user to continue or quit\n- Break out of the loop if the user enters `q`\n- Otherwise, calculate the next generation and loop again\n\nNote that `run_display()` declares the `grid` argument with the `var` argument\nconvention to take ownership of the `Grid` instance. If we used the default\n`read` argument convention instead, `grid` would be an immutable reference\nbinding to the original `Grid` instance. In that case, we'd get a compile-time\nerror when we tried to assign the result of `grid.evolve()` to `grid` because\nMojo doesn't allow you to re-bind a reference to a different value. See\n[Reference bindings](/mojo/manual/variables#reference-bindings) for more\ninformation.\n\nThen we'll update `main()` to create a random initial `Grid` and pass it to\n`run_display()`, transferring ownership with the `^` sigil. Here's\nthe updated version of `life.mojo`:\n\n```mojo title=\"life.mojo\"\nfrom gridv1 import Grid", "position": 57, "token_count": 234, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "metadata": {"chunk_id": "get-started-057", "document_id": "get-started", "position": 57, "token_count": 234, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#12-implement-a-method-to-evolve-the-grid"}}
{"chunk_id": "get-started-058", "document_id": "get-started", "content": "```mojo title=\"life.mojo\"\nfrom gridv1 import Grid\n\ndef run_display(var grid: Grid) -> None:\n while True:\n print(String(grid))\n print()\n if input(\"Enter 'q' to quit or press <Enter> to continue: \") == \"q\":\n break\n grid = grid.evolve()\n\ndef main():\n start = Grid.random(16, 16)\n run_display(start^)\n```\n\nRun the program and verify that each call to `evolve()` successfully produces a\nnew generation.\n\nNow we have a working version of the Game of Life, but the terminal interface\nisn't very appealing. Let's spice things up with a nicer graphical user\ninterface using a Python library.\n\n## 13. Import and use a Python package\n\nMojo lets you import Python modules, call Python functions, and interact with\nPython objects from Mojo code. To demonstrate this capability, we'll\nuse a Python package called [pygame](https://www.pygame.org) to create and\nmanage a graphical user interface for our Game of Life program.", "position": 58, "token_count": 218, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "metadata": {"chunk_id": "get-started-058", "document_id": "get-started", "position": 58, "token_count": 218, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#12-implement-a-method-to-evolve-the-grid"}}
{"chunk_id": "get-started-059", "document_id": "get-started", "content": "First, we need to update our `pixi.toml` file to add a dependency on\nPython and the `pygame` package. In the project directory, execute the\nfollowing command from the terminal:\n\n```bash\npixi add \"python>=3.11,<3.13\" \"pygame>=2.6.1,<3\"\n```\n\n[note]\nWhen you use Python code and packages as part of your Mojo program, you create a\nrun-time dependency on a compatible Python runtime and packages. Building an\nexecutable version of your program with `mojo build` does *not* incorporate a\nPython runtime or Python packages into the resulting executable file. These\nrun-time Python dependencies must be provided by the environment where you run\nthe executable. The easiest way to ensure this requirement is met is to deploy\nand run your Mojo executable in a virtual environment, such as one managed by\n[Pixi](https://pixi.sh/latest/) or [conda](https://docs.conda.io/).", "position": 59, "token_count": 207, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "metadata": {"chunk_id": "get-started-059", "document_id": "get-started", "position": 59, "token_count": 207, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#12-implement-a-method-to-evolve-the-grid"}}
{"chunk_id": "get-started-060", "document_id": "get-started", "content": "You can import a Python module in Mojo using\n[`Python.import_module()`](/mojo/stdlib/python/python/Python#import_module).\nThis returns a reference to the module in the form of a `PythonObject` wrapper.\nYou must store the reference in a variable so that you can then access the\nfunctions and objects in the module. For example:\n\n```mojo\nfrom python import Python\n\ndef run_display():\n # This is roughly equivalent to Python's `import pygame`\n pygame = Python.import_module(\"pygame\")\n\n # Initialize pygame modules\n pygame.init()\n```\n\n[note]\nBecause Mojo doesn't support globally scoped variables, you must either import a\nPython module into each Mojo function that needs to use it or pass the\n`PythonObject`-wrapped module as an argument between functions.\n\nYou can learn more about importing and using Python modules in Mojo by reading\n[Python integration](/mojo/manual/p", "position": 60, "token_count": 185, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "metadata": {"chunk_id": "get-started-060", "document_id": "get-started", "position": 60, "token_count": 185, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "12. Implement a method to evolve the grid"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#12-implement-a-method-to-evolve-the-grid"}}
{"chunk_id": "get-started-061", "document_id": "get-started", "content": "ython/).\n\nOnce we import `pygame`, we can call its APIs as if we were writing Python code.\nFor this project, we'll use `pygame` to create a new window and draw the entire\ngame UI. This requires a complete rewrite of the `run_display()` function. Take\na look at the updated code for `life.mojo`, and we'll explain more below:\n\n```mojo title=\"life.mojo\"\nimport time\n\nfrom gridv1 import Grid\nfrom python import Python\n\ndef run_display(\n var grid: Grid,\n window_height: Int = 600,\n window_width: Int = 600,\n background_color: String = \"black\",\n cell_color: String = \"green\",\n pause: Float64 = 0.1,\n) -> None:\n # Import the pygame Python package\n pygame = Python.import_module(\"pygame\")\n\n # Initialize pygame modules\n pygame.init()\n\n # Create a window and set its title\n window = pygame.display.set_mode(Python.tuple(window_height, window_width))\n pygame.display.set_caption(\"Conway's Game of Life\")", "position": 61, "token_count": 218, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "metadata": {"chunk_id": "get-started-061", "document_id": "get-started", "position": 61, "token_count": 218, "has_code": true, "overlap_with_previous": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#13-import-and-use-a-python-package"}}
{"chunk_id": "get-started-062", "document_id": "get-started", "content": " # Initialize pygame modules\n pygame.init()\n\n # Create a window and set its title\n window = pygame.display.set_mode(Python.tuple(window_height, window_width))\n pygame.display.set_caption(\"Conway's Game of Life\")\n\n cell_height = window_height / grid.rows\n cell_width = window_width / grid.cols\n border_size = 1\n cell_fill_color = pygame.Color(cell_color)\n background_fill_color = pygame.Color(background_color)\n\n running = True\n while running:\n # Poll for events\n event = pygame.event.poll()\n if event.type == pygame.QUIT:\n # Quit if the window is closed\n running = False\n elif event.type == pygame.KEYDOWN:\n # Also quit if the user presses <Escape> or 'q'\n if event.key == pygame.K_ESCAPE or event.key == pygame.K_q:\n running = False\n\n # Clear the window by painting with the background color\n window.fill(background_fill_color)", "position": 62, "token_count": 183, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "metadata": {"chunk_id": "get-started-062", "document_id": "get-started", "position": 62, "token_count": 183, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#13-import-and-use-a-python-package"}}
{"chunk_id": "get-started-063", "document_id": "get-started", "content": " # Clear the window by painting with the background color\n window.fill(background_fill_color)\n\n # Draw each live cell in the grid\n for row in range(grid.rows):\n for col in range(grid.cols):\n if grid[row, col]:\n x = col * cell_width + border_size\n y = row * cell_height + border_size\n width = cell_width - border_size\n height = cell_height - border_size\n pygame.draw.rect(\n window,\n cell_fill_color,\n Python.tuple(x, y, width, height),\n )\n\n # Update the display\n pygame.display.flip()\n\n # Pause to let the user appreciate the scene\n time.sleep(pause)\n\n # Next generation\n grid = grid.evolve()\n\n # Shut down pygame cleanly\n pygame.quit()\n\ndef main():\n start = Grid.random(128, 128)\n run_display(start^)\n```\n\nEach argument for `run_display()` other than `grid` has a default value\nassociated with it (for example, the default `window_height` is 600 pixels). If\nyou don't explicitly pass a value for an argument when you invoke\n`run_display()`, Mojo uses the default value specified in the function\ndefinition.\n\nAfter importing the `pygame` module, we call `pygame.init()` to initialize all\npygame subsystems.", "position": 63, "token_count": 257, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "metadata": {"chunk_id": "get-started-063", "document_id": "get-started", "position": 63, "token_count": 257, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#13-import-and-use-a-python-package"}}
{"chunk_id": "get-started-064", "document_id": "get-started", "content": "After importing the `pygame` module, we call `pygame.init()` to initialize all\npygame subsystems.\n\nThe `set_mode()` function creates and initializes a window with the height and\nwidth passed as a Python tuple of two values. This returns a\n[`PythonObject`](/mojo/stdlib/python/python_object/PythonObject) wrapper for the\nwindow, which we can then use to call functions and set attributes to manipulate\nthe window. (For more information about interacting with Python objects from\nMojo, see [Python types](/mojo/manual/python/types).)\n\nThe bulk of the `run_display()` function is a loop that uses `pygame` to poll\nfor events like key presses and mouse clicks. If it detects that the user\npresses `q` or the `<Escape>` key or closes the display window, it ends the\nprogram with `pygame.quit()`. Otherwise, it clears the window and iterates\nthrough all cells in the grid to display the populated cells. After sleeping for\n`pause` seconds, it evolves the grid to the next generation and loops again.\n\nNow it's time to try it out.\n\n```bash\nmojo life.mojo\n```", "position": 64, "token_count": 244, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "metadata": {"chunk_id": "get-started-064", "document_id": "get-started", "position": 64, "token_count": 244, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#13-import-and-use-a-python-package"}}
{"chunk_id": "get-started-065", "document_id": "get-started", "content": "Now it's time to try it out.\n\n```bash\nmojo life.mojo\n```\n\nWhen you run the program, you should see a new window appear on screen\ndisplaying your evolving grid. We now have a fully functional implementation of\nthe Game of Life with a nice interface. We've come quite a way from just\ndisplaying a few asterisks in the terminal!\n\n![game_of_life_screen.png](images/game-of-life-screen.png)\n\nTo quit the program, press the `q` or `<Escape>` key, or close the window.\n\nNow that we're done with the tutorial, exit our project's virtual environment:\n\n```bash\nexit\n```\n\n## Summary\n\nCongratulations on writing a complete Mojo application from scratch! Along the\nway, you experienced:", "position": 65, "token_count": 158, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "metadata": {"chunk_id": "get-started-065", "document_id": "get-started", "position": 65, "token_count": 158, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#13-import-and-use-a-python-package"}}
{"chunk_id": "get-started-066", "document_id": "get-started", "content": "Now that we're done with the tutorial, exit our project's virtual environment:\n\n```bash\nexit\n```\n\n## Summary\n\nCongratulations on writing a complete Mojo application from scratch! Along the\nway, you experienced:\n\n- Using Pixi to create, build, and run a Mojo program\n- Using Mojo built-in types like `Int`, `String`, and `List`\n- Manipulating explicitly and implicitly copyable types\n- Managing value ownership and references\n- Creating and using variables and functions\n- Using control structures like `if`, `while`, and `for`\n- Defining and using a custom Mojo struct\n- Creating and importing a Mojo module\n- Using modules from the Mojo standard library\n- Importing and using a Python module\n\n## Next steps\n\nNow that you've seen what Mojo can do, here are some suggestions for continuing\nyour learning journey:\n\nexport const Puzzles = {\n title: \"GPU Puzzles\",\n description: \"Learn to program GPUs in Mojo by solving increasingly complex challenges\",\n metadata: {\n permalink: \"https://puzzles.modular.com/introduction.html\"\n }\n};", "position": 66, "token_count": 227, "has_code": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "metadata": {"chunk_id": "get-started-066", "document_id": "get-started", "position": 66, "token_count": 227, "has_code": true, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#13-import-and-use-a-python-package"}}
{"chunk_id": "get-started-067", "document_id": "get-started", "content": "export const Puzzles = {\n title: \"GPU Puzzles\",\n description: \"Learn to program GPUs in Mojo by solving increasingly complex challenges\",\n metadata: {\n permalink: \"https://puzzles.modular.com/introduction.html\"\n }\n};\n\nexport const Examples = {\n title: \"Code examples\",\n description: \"Browse a wide range of Mojo code examples on GitHub\",\n metadata: {\n permalink: \"https://github.com/modular/modular/tree/main/examples/mojo\"\n }\n};\n\nexport const nextSteps = [\n '../gpu/intro-tutorial',\n Puzzles,\n Examples,\n]\n\n[tip]\n**Tip:** To use AI coding assistants with Mojo, see our guide on\n[using AI coding assistants](/max/coding-assistants/).", "position": 67, "token_count": 152, "has_code": false, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "metadata": {"chunk_id": "get-started-067", "document_id": "get-started", "position": 67, "token_count": 152, "has_code": false, "overlap_with_previous": true, "section_hierarchy": ["Create a List[Int] with the list literal syntax, inferring the type", "13. Import and use a Python package"], "file_path": "get-started.mdx", "url": "https://docs.modular.com/mojo/manual/get-started", "title": "Get started with Mojo", "category": null, "tags": [], "section_url": "https://docs.modular.com/mojo/manual/get-started#13-import-and-use-a-python-package"}}
